
FREE_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000561e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  0000561e  000056b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000646  00800066  00800066  000056b8  2**0
                  ALLOC
  3 .stab         000087f0  00000000  00000000  000056b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004a50  00000000  00000000  0000dea8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e1       	ldi	r30, 0x1E	; 30
      68:	f6 e5       	ldi	r31, 0x56	; 86
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 36       	cpi	r26, 0x66	; 102
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a6 e6       	ldi	r26, 0x66	; 102
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3a       	cpi	r26, 0xAC	; 172
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4b 2a 	call	0x5496	; 0x5496 <main>
      8a:	0c 94 0d 2b 	jmp	0x561a	; 0x561a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xEventGroupCreate>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <xEventGroupCreate+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	8b e0       	ldi	r24, 0x0B	; 11
      9e:	90 e0       	ldi	r25, 0x00	; 0
      a0:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
      a4:	9a 83       	std	Y+2, r25	; 0x02
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	9a 81       	ldd	r25, Y+2	; 0x02
      ac:	00 97       	sbiw	r24, 0x00	; 0
      ae:	49 f0       	breq	.+18     	; 0xc2 <xEventGroupCreate+0x30>
      b0:	e9 81       	ldd	r30, Y+1	; 0x01
      b2:	fa 81       	ldd	r31, Y+2	; 0x02
      b4:	11 82       	std	Z+1, r1	; 0x01
      b6:	10 82       	st	Z, r1
      b8:	89 81       	ldd	r24, Y+1	; 0x01
      ba:	9a 81       	ldd	r25, Y+2	; 0x02
      bc:	02 96       	adiw	r24, 0x02	; 2
      be:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
      c2:	89 81       	ldd	r24, Y+1	; 0x01
      c4:	9a 81       	ldd	r25, Y+2	; 0x02
      c6:	0f 90       	pop	r0
      c8:	0f 90       	pop	r0
      ca:	cf 91       	pop	r28
      cc:	df 91       	pop	r29
      ce:	08 95       	ret

000000d0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
      d0:	df 93       	push	r29
      d2:	cf 93       	push	r28
      d4:	cd b7       	in	r28, 0x3d	; 61
      d6:	de b7       	in	r29, 0x3e	; 62
      d8:	60 97       	sbiw	r28, 0x10	; 16
      da:	0f b6       	in	r0, 0x3f	; 63
      dc:	f8 94       	cli
      de:	de bf       	out	0x3e, r29	; 62
      e0:	0f be       	out	0x3f, r0	; 63
      e2:	cd bf       	out	0x3d, r28	; 61
      e4:	9a 87       	std	Y+10, r25	; 0x0a
      e6:	89 87       	std	Y+9, r24	; 0x09
      e8:	7c 87       	std	Y+12, r23	; 0x0c
      ea:	6b 87       	std	Y+11, r22	; 0x0b
      ec:	5e 87       	std	Y+14, r21	; 0x0e
      ee:	4d 87       	std	Y+13, r20	; 0x0d
      f0:	38 8b       	std	Y+16, r19	; 0x10
      f2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
      f4:	89 85       	ldd	r24, Y+9	; 0x09
      f6:	9a 85       	ldd	r25, Y+10	; 0x0a
      f8:	9c 83       	std	Y+4, r25	; 0x04
      fa:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
      fc:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      fe:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     102:	eb 81       	ldd	r30, Y+3	; 0x03
     104:	fc 81       	ldd	r31, Y+4	; 0x04
     106:	80 81       	ld	r24, Z
     108:	91 81       	ldd	r25, Z+1	; 0x01
     10a:	98 87       	std	Y+8, r25	; 0x08
     10c:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     10e:	89 85       	ldd	r24, Y+9	; 0x09
     110:	9a 85       	ldd	r25, Y+10	; 0x0a
     112:	2b 85       	ldd	r18, Y+11	; 0x0b
     114:	3c 85       	ldd	r19, Y+12	; 0x0c
     116:	b9 01       	movw	r22, r18
     118:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     11c:	2f 81       	ldd	r18, Y+7	; 0x07
     11e:	38 85       	ldd	r19, Y+8	; 0x08
     120:	8b 85       	ldd	r24, Y+11	; 0x0b
     122:	9c 85       	ldd	r25, Y+12	; 0x0c
     124:	28 2b       	or	r18, r24
     126:	39 2b       	or	r19, r25
     128:	8d 85       	ldd	r24, Y+13	; 0x0d
     12a:	9e 85       	ldd	r25, Y+14	; 0x0e
     12c:	28 23       	and	r18, r24
     12e:	39 23       	and	r19, r25
     130:	8d 85       	ldd	r24, Y+13	; 0x0d
     132:	9e 85       	ldd	r25, Y+14	; 0x0e
     134:	28 17       	cp	r18, r24
     136:	39 07       	cpc	r19, r25
     138:	c9 f4       	brne	.+50     	; 0x16c <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     13a:	2f 81       	ldd	r18, Y+7	; 0x07
     13c:	38 85       	ldd	r19, Y+8	; 0x08
     13e:	8b 85       	ldd	r24, Y+11	; 0x0b
     140:	9c 85       	ldd	r25, Y+12	; 0x0c
     142:	82 2b       	or	r24, r18
     144:	93 2b       	or	r25, r19
     146:	9e 83       	std	Y+6, r25	; 0x06
     148:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     14a:	eb 81       	ldd	r30, Y+3	; 0x03
     14c:	fc 81       	ldd	r31, Y+4	; 0x04
     14e:	20 81       	ld	r18, Z
     150:	31 81       	ldd	r19, Z+1	; 0x01
     152:	8d 85       	ldd	r24, Y+13	; 0x0d
     154:	9e 85       	ldd	r25, Y+14	; 0x0e
     156:	80 95       	com	r24
     158:	90 95       	com	r25
     15a:	82 23       	and	r24, r18
     15c:	93 23       	and	r25, r19
     15e:	eb 81       	ldd	r30, Y+3	; 0x03
     160:	fc 81       	ldd	r31, Y+4	; 0x04
     162:	91 83       	std	Z+1, r25	; 0x01
     164:	80 83       	st	Z, r24

			xTicksToWait = 0;
     166:	18 8a       	std	Y+16, r1	; 0x10
     168:	1f 86       	std	Y+15, r1	; 0x0f
     16a:	1e c0       	rjmp	.+60     	; 0x1a8 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     16c:	8f 85       	ldd	r24, Y+15	; 0x0f
     16e:	98 89       	ldd	r25, Y+16	; 0x10
     170:	00 97       	sbiw	r24, 0x00	; 0
     172:	91 f0       	breq	.+36     	; 0x198 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	bc 01       	movw	r22, r24
     17a:	6e 5f       	subi	r22, 0xFE	; 254
     17c:	7f 4f       	sbci	r23, 0xFF	; 255
     17e:	8d 85       	ldd	r24, Y+13	; 0x0d
     180:	9e 85       	ldd	r25, Y+14	; 0x0e
     182:	9c 01       	movw	r18, r24
     184:	35 60       	ori	r19, 0x05	; 5
     186:	4f 85       	ldd	r20, Y+15	; 0x0f
     188:	58 89       	ldd	r21, Y+16	; 0x10
     18a:	cb 01       	movw	r24, r22
     18c:	b9 01       	movw	r22, r18
     18e:	0e 94 77 1e 	call	0x3cee	; 0x3cee <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     192:	1e 82       	std	Y+6, r1	; 0x06
     194:	1d 82       	std	Y+5, r1	; 0x05
     196:	08 c0       	rjmp	.+16     	; 0x1a8 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     198:	eb 81       	ldd	r30, Y+3	; 0x03
     19a:	fc 81       	ldd	r31, Y+4	; 0x04
     19c:	80 81       	ld	r24, Z
     19e:	91 81       	ldd	r25, Z+1	; 0x01
     1a0:	9e 83       	std	Y+6, r25	; 0x06
     1a2:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     1a4:	81 e0       	ldi	r24, 0x01	; 1
     1a6:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1a8:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
     1ac:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     1ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     1b0:	98 89       	ldd	r25, Y+16	; 0x10
     1b2:	00 97       	sbiw	r24, 0x00	; 0
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <xEventGroupSync+0xe8>
     1b6:	3a c0       	rjmp	.+116    	; 0x22c <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     1b8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ba:	88 23       	and	r24, r24
     1bc:	11 f4       	brne	.+4      	; 0x1c2 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     1be:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1c2:	0e 94 8f 22 	call	0x451e	; 0x451e <uxTaskResetEventItemValue>
     1c6:	9e 83       	std	Y+6, r25	; 0x06
     1c8:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1ca:	8d 81       	ldd	r24, Y+5	; 0x05
     1cc:	9e 81       	ldd	r25, Y+6	; 0x06
     1ce:	80 70       	andi	r24, 0x00	; 0
     1d0:	92 70       	andi	r25, 0x02	; 2
     1d2:	00 97       	sbiw	r24, 0x00	; 0
     1d4:	31 f5       	brne	.+76     	; 0x222 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     1dc:	eb 81       	ldd	r30, Y+3	; 0x03
     1de:	fc 81       	ldd	r31, Y+4	; 0x04
     1e0:	80 81       	ld	r24, Z
     1e2:	91 81       	ldd	r25, Z+1	; 0x01
     1e4:	9e 83       	std	Y+6, r25	; 0x06
     1e6:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     1e8:	2d 81       	ldd	r18, Y+5	; 0x05
     1ea:	3e 81       	ldd	r19, Y+6	; 0x06
     1ec:	8d 85       	ldd	r24, Y+13	; 0x0d
     1ee:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f0:	28 23       	and	r18, r24
     1f2:	39 23       	and	r19, r25
     1f4:	8d 85       	ldd	r24, Y+13	; 0x0d
     1f6:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f8:	28 17       	cp	r18, r24
     1fa:	39 07       	cpc	r19, r25
     1fc:	71 f4       	brne	.+28     	; 0x21a <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1fe:	eb 81       	ldd	r30, Y+3	; 0x03
     200:	fc 81       	ldd	r31, Y+4	; 0x04
     202:	20 81       	ld	r18, Z
     204:	31 81       	ldd	r19, Z+1	; 0x01
     206:	8d 85       	ldd	r24, Y+13	; 0x0d
     208:	9e 85       	ldd	r25, Y+14	; 0x0e
     20a:	80 95       	com	r24
     20c:	90 95       	com	r25
     20e:	82 23       	and	r24, r18
     210:	93 23       	and	r25, r19
     212:	eb 81       	ldd	r30, Y+3	; 0x03
     214:	fc 81       	ldd	r31, Y+4	; 0x04
     216:	91 83       	std	Z+1, r25	; 0x01
     218:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     222:	8d 81       	ldd	r24, Y+5	; 0x05
     224:	9e 81       	ldd	r25, Y+6	; 0x06
     226:	90 70       	andi	r25, 0x00	; 0
     228:	9e 83       	std	Y+6, r25	; 0x06
     22a:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     22c:	8d 81       	ldd	r24, Y+5	; 0x05
     22e:	9e 81       	ldd	r25, Y+6	; 0x06
}
     230:	60 96       	adiw	r28, 0x10	; 16
     232:	0f b6       	in	r0, 0x3f	; 63
     234:	f8 94       	cli
     236:	de bf       	out	0x3e, r29	; 62
     238:	0f be       	out	0x3f, r0	; 63
     23a:	cd bf       	out	0x3d, r28	; 61
     23c:	cf 91       	pop	r28
     23e:	df 91       	pop	r29
     240:	08 95       	ret

00000242 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	df 93       	push	r29
     248:	cf 93       	push	r28
     24a:	cd b7       	in	r28, 0x3d	; 61
     24c:	de b7       	in	r29, 0x3e	; 62
     24e:	63 97       	sbiw	r28, 0x13	; 19
     250:	0f b6       	in	r0, 0x3f	; 63
     252:	f8 94       	cli
     254:	de bf       	out	0x3e, r29	; 62
     256:	0f be       	out	0x3f, r0	; 63
     258:	cd bf       	out	0x3d, r28	; 61
     25a:	9d 87       	std	Y+13, r25	; 0x0d
     25c:	8c 87       	std	Y+12, r24	; 0x0c
     25e:	7f 87       	std	Y+15, r23	; 0x0f
     260:	6e 87       	std	Y+14, r22	; 0x0e
     262:	48 8b       	std	Y+16, r20	; 0x10
     264:	29 8b       	std	Y+17, r18	; 0x11
     266:	1b 8b       	std	Y+19, r17	; 0x13
     268:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     26a:	8c 85       	ldd	r24, Y+12	; 0x0c
     26c:	9d 85       	ldd	r25, Y+13	; 0x0d
     26e:	9b 87       	std	Y+11, r25	; 0x0b
     270:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     272:	1f 82       	std	Y+7, r1	; 0x07
     274:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     276:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     278:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     27c:	ea 85       	ldd	r30, Y+10	; 0x0a
     27e:	fb 85       	ldd	r31, Y+11	; 0x0b
     280:	80 81       	ld	r24, Z
     282:	91 81       	ldd	r25, Z+1	; 0x01
     284:	9a 83       	std	Y+2, r25	; 0x02
     286:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     288:	89 81       	ldd	r24, Y+1	; 0x01
     28a:	9a 81       	ldd	r25, Y+2	; 0x02
     28c:	2e 85       	ldd	r18, Y+14	; 0x0e
     28e:	3f 85       	ldd	r19, Y+15	; 0x0f
     290:	b9 01       	movw	r22, r18
     292:	49 89       	ldd	r20, Y+17	; 0x11
     294:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     298:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     29a:	8d 81       	ldd	r24, Y+5	; 0x05
     29c:	88 23       	and	r24, r24
     29e:	c1 f0       	breq	.+48     	; 0x2d0 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	99 87       	std	Y+9, r25	; 0x09
     2a6:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     2a8:	1b 8a       	std	Y+19, r1	; 0x13
     2aa:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     2ac:	88 89       	ldd	r24, Y+16	; 0x10
     2ae:	88 23       	and	r24, r24
     2b0:	e9 f1       	breq	.+122    	; 0x32c <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     2b2:	ea 85       	ldd	r30, Y+10	; 0x0a
     2b4:	fb 85       	ldd	r31, Y+11	; 0x0b
     2b6:	20 81       	ld	r18, Z
     2b8:	31 81       	ldd	r19, Z+1	; 0x01
     2ba:	8e 85       	ldd	r24, Y+14	; 0x0e
     2bc:	9f 85       	ldd	r25, Y+15	; 0x0f
     2be:	80 95       	com	r24
     2c0:	90 95       	com	r25
     2c2:	82 23       	and	r24, r18
     2c4:	93 23       	and	r25, r19
     2c6:	ea 85       	ldd	r30, Y+10	; 0x0a
     2c8:	fb 85       	ldd	r31, Y+11	; 0x0b
     2ca:	91 83       	std	Z+1, r25	; 0x01
     2cc:	80 83       	st	Z, r24
     2ce:	2e c0       	rjmp	.+92     	; 0x32c <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     2d0:	8a 89       	ldd	r24, Y+18	; 0x12
     2d2:	9b 89       	ldd	r25, Y+19	; 0x13
     2d4:	00 97       	sbiw	r24, 0x00	; 0
     2d6:	39 f4       	brne	.+14     	; 0x2e6 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     2d8:	89 81       	ldd	r24, Y+1	; 0x01
     2da:	9a 81       	ldd	r25, Y+2	; 0x02
     2dc:	99 87       	std	Y+9, r25	; 0x09
     2de:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     2e0:	81 e0       	ldi	r24, 0x01	; 1
     2e2:	8b 83       	std	Y+3, r24	; 0x03
     2e4:	23 c0       	rjmp	.+70     	; 0x32c <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     2e6:	88 89       	ldd	r24, Y+16	; 0x10
     2e8:	88 23       	and	r24, r24
     2ea:	29 f0       	breq	.+10     	; 0x2f6 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     2ec:	8e 81       	ldd	r24, Y+6	; 0x06
     2ee:	9f 81       	ldd	r25, Y+7	; 0x07
     2f0:	91 60       	ori	r25, 0x01	; 1
     2f2:	9f 83       	std	Y+7, r25	; 0x07
     2f4:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     2f6:	89 89       	ldd	r24, Y+17	; 0x11
     2f8:	88 23       	and	r24, r24
     2fa:	29 f0       	breq	.+10     	; 0x306 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     2fc:	8e 81       	ldd	r24, Y+6	; 0x06
     2fe:	9f 81       	ldd	r25, Y+7	; 0x07
     300:	94 60       	ori	r25, 0x04	; 4
     302:	9f 83       	std	Y+7, r25	; 0x07
     304:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     306:	8a 85       	ldd	r24, Y+10	; 0x0a
     308:	9b 85       	ldd	r25, Y+11	; 0x0b
     30a:	bc 01       	movw	r22, r24
     30c:	6e 5f       	subi	r22, 0xFE	; 254
     30e:	7f 4f       	sbci	r23, 0xFF	; 255
     310:	2e 85       	ldd	r18, Y+14	; 0x0e
     312:	3f 85       	ldd	r19, Y+15	; 0x0f
     314:	8e 81       	ldd	r24, Y+6	; 0x06
     316:	9f 81       	ldd	r25, Y+7	; 0x07
     318:	28 2b       	or	r18, r24
     31a:	39 2b       	or	r19, r25
     31c:	4a 89       	ldd	r20, Y+18	; 0x12
     31e:	5b 89       	ldd	r21, Y+19	; 0x13
     320:	cb 01       	movw	r24, r22
     322:	b9 01       	movw	r22, r18
     324:	0e 94 77 1e 	call	0x3cee	; 0x3cee <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     328:	19 86       	std	Y+9, r1	; 0x09
     32a:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     32c:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
     330:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     332:	8a 89       	ldd	r24, Y+18	; 0x12
     334:	9b 89       	ldd	r25, Y+19	; 0x13
     336:	00 97       	sbiw	r24, 0x00	; 0
     338:	09 f4       	brne	.+2      	; 0x33c <xEventGroupWaitBits+0xfa>
     33a:	3c c0       	rjmp	.+120    	; 0x3b4 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	88 23       	and	r24, r24
     340:	11 f4       	brne	.+4      	; 0x346 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     342:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     346:	0e 94 8f 22 	call	0x451e	; 0x451e <uxTaskResetEventItemValue>
     34a:	99 87       	std	Y+9, r25	; 0x09
     34c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     34e:	88 85       	ldd	r24, Y+8	; 0x08
     350:	99 85       	ldd	r25, Y+9	; 0x09
     352:	80 70       	andi	r24, 0x00	; 0
     354:	92 70       	andi	r25, 0x02	; 2
     356:	00 97       	sbiw	r24, 0x00	; 0
     358:	41 f5       	brne	.+80     	; 0x3aa <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     360:	ea 85       	ldd	r30, Y+10	; 0x0a
     362:	fb 85       	ldd	r31, Y+11	; 0x0b
     364:	80 81       	ld	r24, Z
     366:	91 81       	ldd	r25, Z+1	; 0x01
     368:	99 87       	std	Y+9, r25	; 0x09
     36a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     36c:	88 85       	ldd	r24, Y+8	; 0x08
     36e:	99 85       	ldd	r25, Y+9	; 0x09
     370:	2e 85       	ldd	r18, Y+14	; 0x0e
     372:	3f 85       	ldd	r19, Y+15	; 0x0f
     374:	b9 01       	movw	r22, r18
     376:	49 89       	ldd	r20, Y+17	; 0x11
     378:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     37c:	88 23       	and	r24, r24
     37e:	89 f0       	breq	.+34     	; 0x3a2 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     380:	88 89       	ldd	r24, Y+16	; 0x10
     382:	88 23       	and	r24, r24
     384:	71 f0       	breq	.+28     	; 0x3a2 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     386:	ea 85       	ldd	r30, Y+10	; 0x0a
     388:	fb 85       	ldd	r31, Y+11	; 0x0b
     38a:	20 81       	ld	r18, Z
     38c:	31 81       	ldd	r19, Z+1	; 0x01
     38e:	8e 85       	ldd	r24, Y+14	; 0x0e
     390:	9f 85       	ldd	r25, Y+15	; 0x0f
     392:	80 95       	com	r24
     394:	90 95       	com	r25
     396:	82 23       	and	r24, r18
     398:	93 23       	and	r25, r19
     39a:	ea 85       	ldd	r30, Y+10	; 0x0a
     39c:	fb 85       	ldd	r31, Y+11	; 0x0b
     39e:	91 83       	std	Z+1, r25	; 0x01
     3a0:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     3a6:	0f 90       	pop	r0
     3a8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3aa:	88 85       	ldd	r24, Y+8	; 0x08
     3ac:	99 85       	ldd	r25, Y+9	; 0x09
     3ae:	90 70       	andi	r25, 0x00	; 0
     3b0:	99 87       	std	Y+9, r25	; 0x09
     3b2:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     3b4:	88 85       	ldd	r24, Y+8	; 0x08
     3b6:	99 85       	ldd	r25, Y+9	; 0x09
}
     3b8:	63 96       	adiw	r28, 0x13	; 19
     3ba:	0f b6       	in	r0, 0x3f	; 63
     3bc:	f8 94       	cli
     3be:	de bf       	out	0x3e, r29	; 62
     3c0:	0f be       	out	0x3f, r0	; 63
     3c2:	cd bf       	out	0x3d, r28	; 61
     3c4:	cf 91       	pop	r28
     3c6:	df 91       	pop	r29
     3c8:	1f 91       	pop	r17
     3ca:	0f 91       	pop	r16
     3cc:	08 95       	ret

000003ce <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     3ce:	df 93       	push	r29
     3d0:	cf 93       	push	r28
     3d2:	cd b7       	in	r28, 0x3d	; 61
     3d4:	de b7       	in	r29, 0x3e	; 62
     3d6:	28 97       	sbiw	r28, 0x08	; 8
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	de bf       	out	0x3e, r29	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	cd bf       	out	0x3d, r28	; 61
     3e2:	9e 83       	std	Y+6, r25	; 0x06
     3e4:	8d 83       	std	Y+5, r24	; 0x05
     3e6:	78 87       	std	Y+8, r23	; 0x08
     3e8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	9c 83       	std	Y+4, r25	; 0x04
     3f0:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     3f2:	0f b6       	in	r0, 0x3f	; 63
     3f4:	f8 94       	cli
     3f6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     3f8:	eb 81       	ldd	r30, Y+3	; 0x03
     3fa:	fc 81       	ldd	r31, Y+4	; 0x04
     3fc:	80 81       	ld	r24, Z
     3fe:	91 81       	ldd	r25, Z+1	; 0x01
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     404:	eb 81       	ldd	r30, Y+3	; 0x03
     406:	fc 81       	ldd	r31, Y+4	; 0x04
     408:	20 81       	ld	r18, Z
     40a:	31 81       	ldd	r19, Z+1	; 0x01
     40c:	8f 81       	ldd	r24, Y+7	; 0x07
     40e:	98 85       	ldd	r25, Y+8	; 0x08
     410:	80 95       	com	r24
     412:	90 95       	com	r25
     414:	82 23       	and	r24, r18
     416:	93 23       	and	r25, r19
     418:	eb 81       	ldd	r30, Y+3	; 0x03
     41a:	fc 81       	ldd	r31, Y+4	; 0x04
     41c:	91 83       	std	Z+1, r25	; 0x01
     41e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     420:	0f 90       	pop	r0
     422:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     424:	89 81       	ldd	r24, Y+1	; 0x01
     426:	9a 81       	ldd	r25, Y+2	; 0x02
}
     428:	28 96       	adiw	r28, 0x08	; 8
     42a:	0f b6       	in	r0, 0x3f	; 63
     42c:	f8 94       	cli
     42e:	de bf       	out	0x3e, r29	; 62
     430:	0f be       	out	0x3f, r0	; 63
     432:	cd bf       	out	0x3d, r28	; 61
     434:	cf 91       	pop	r28
     436:	df 91       	pop	r29
     438:	08 95       	ret

0000043a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     43a:	df 93       	push	r29
     43c:	cf 93       	push	r28
     43e:	cd b7       	in	r28, 0x3d	; 61
     440:	de b7       	in	r29, 0x3e	; 62
     442:	27 97       	sbiw	r28, 0x07	; 7
     444:	0f b6       	in	r0, 0x3f	; 63
     446:	f8 94       	cli
     448:	de bf       	out	0x3e, r29	; 62
     44a:	0f be       	out	0x3f, r0	; 63
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	9f 83       	std	Y+7, r25	; 0x07
     450:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     452:	8e 81       	ldd	r24, Y+6	; 0x06
     454:	9f 81       	ldd	r25, Y+7	; 0x07
     456:	9c 83       	std	Y+4, r25	; 0x04
     458:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     45a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     45c:	eb 81       	ldd	r30, Y+3	; 0x03
     45e:	fc 81       	ldd	r31, Y+4	; 0x04
     460:	80 81       	ld	r24, Z
     462:	91 81       	ldd	r25, Z+1	; 0x01
     464:	9a 83       	std	Y+2, r25	; 0x02
     466:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     46c:	27 96       	adiw	r28, 0x07	; 7
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	65 97       	sbiw	r28, 0x15	; 21
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	9b 8b       	std	Y+19, r25	; 0x13
     494:	8a 8b       	std	Y+18, r24	; 0x12
     496:	7d 8b       	std	Y+21, r23	; 0x15
     498:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     49a:	19 86       	std	Y+9, r1	; 0x09
     49c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     49e:	8a 89       	ldd	r24, Y+18	; 0x12
     4a0:	9b 89       	ldd	r25, Y+19	; 0x13
     4a2:	9b 83       	std	Y+3, r25	; 0x03
     4a4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     4a6:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     4a8:	8a 81       	ldd	r24, Y+2	; 0x02
     4aa:	9b 81       	ldd	r25, Y+3	; 0x03
     4ac:	02 96       	adiw	r24, 0x02	; 2
     4ae:	9b 87       	std	Y+11, r25	; 0x0b
     4b0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4b2:	8a 85       	ldd	r24, Y+10	; 0x0a
     4b4:	9b 85       	ldd	r25, Y+11	; 0x0b
     4b6:	03 96       	adiw	r24, 0x03	; 3
     4b8:	9d 87       	std	Y+13, r25	; 0x0d
     4ba:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     4bc:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     4c0:	ea 85       	ldd	r30, Y+10	; 0x0a
     4c2:	fb 85       	ldd	r31, Y+11	; 0x0b
     4c4:	85 81       	ldd	r24, Z+5	; 0x05
     4c6:	96 81       	ldd	r25, Z+6	; 0x06
     4c8:	99 8b       	std	Y+17, r25	; 0x11
     4ca:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     4cc:	ea 81       	ldd	r30, Y+2	; 0x02
     4ce:	fb 81       	ldd	r31, Y+3	; 0x03
     4d0:	20 81       	ld	r18, Z
     4d2:	31 81       	ldd	r19, Z+1	; 0x01
     4d4:	8c 89       	ldd	r24, Y+20	; 0x14
     4d6:	9d 89       	ldd	r25, Y+21	; 0x15
     4d8:	82 2b       	or	r24, r18
     4da:	93 2b       	or	r25, r19
     4dc:	ea 81       	ldd	r30, Y+2	; 0x02
     4de:	fb 81       	ldd	r31, Y+3	; 0x03
     4e0:	91 83       	std	Z+1, r25	; 0x01
     4e2:	80 83       	st	Z, r24
     4e4:	59 c0       	rjmp	.+178    	; 0x598 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     4e6:	e8 89       	ldd	r30, Y+16	; 0x10
     4e8:	f9 89       	ldd	r31, Y+17	; 0x11
     4ea:	82 81       	ldd	r24, Z+2	; 0x02
     4ec:	93 81       	ldd	r25, Z+3	; 0x03
     4ee:	9f 87       	std	Y+15, r25	; 0x0f
     4f0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     4f2:	e8 89       	ldd	r30, Y+16	; 0x10
     4f4:	f9 89       	ldd	r31, Y+17	; 0x11
     4f6:	80 81       	ld	r24, Z
     4f8:	91 81       	ldd	r25, Z+1	; 0x01
     4fa:	9f 83       	std	Y+7, r25	; 0x07
     4fc:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     4fe:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     500:	8e 81       	ldd	r24, Y+6	; 0x06
     502:	9f 81       	ldd	r25, Y+7	; 0x07
     504:	80 70       	andi	r24, 0x00	; 0
     506:	9d 83       	std	Y+5, r25	; 0x05
     508:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     50a:	8e 81       	ldd	r24, Y+6	; 0x06
     50c:	9f 81       	ldd	r25, Y+7	; 0x07
     50e:	90 70       	andi	r25, 0x00	; 0
     510:	9f 83       	std	Y+7, r25	; 0x07
     512:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     514:	8c 81       	ldd	r24, Y+4	; 0x04
     516:	9d 81       	ldd	r25, Y+5	; 0x05
     518:	80 70       	andi	r24, 0x00	; 0
     51a:	94 70       	andi	r25, 0x04	; 4
     51c:	00 97       	sbiw	r24, 0x00	; 0
     51e:	69 f4       	brne	.+26     	; 0x53a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     520:	ea 81       	ldd	r30, Y+2	; 0x02
     522:	fb 81       	ldd	r31, Y+3	; 0x03
     524:	20 81       	ld	r18, Z
     526:	31 81       	ldd	r19, Z+1	; 0x01
     528:	8e 81       	ldd	r24, Y+6	; 0x06
     52a:	9f 81       	ldd	r25, Y+7	; 0x07
     52c:	82 23       	and	r24, r18
     52e:	93 23       	and	r25, r19
     530:	00 97       	sbiw	r24, 0x00	; 0
     532:	91 f0       	breq	.+36     	; 0x558 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	89 83       	std	Y+1, r24	; 0x01
     538:	0f c0       	rjmp	.+30     	; 0x558 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     53a:	ea 81       	ldd	r30, Y+2	; 0x02
     53c:	fb 81       	ldd	r31, Y+3	; 0x03
     53e:	20 81       	ld	r18, Z
     540:	31 81       	ldd	r19, Z+1	; 0x01
     542:	8e 81       	ldd	r24, Y+6	; 0x06
     544:	9f 81       	ldd	r25, Y+7	; 0x07
     546:	28 23       	and	r18, r24
     548:	39 23       	and	r19, r25
     54a:	8e 81       	ldd	r24, Y+6	; 0x06
     54c:	9f 81       	ldd	r25, Y+7	; 0x07
     54e:	28 17       	cp	r18, r24
     550:	39 07       	cpc	r19, r25
     552:	11 f4       	brne	.+4      	; 0x558 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	88 23       	and	r24, r24
     55c:	c9 f0       	breq	.+50     	; 0x590 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     55e:	8c 81       	ldd	r24, Y+4	; 0x04
     560:	9d 81       	ldd	r25, Y+5	; 0x05
     562:	80 70       	andi	r24, 0x00	; 0
     564:	91 70       	andi	r25, 0x01	; 1
     566:	00 97       	sbiw	r24, 0x00	; 0
     568:	41 f0       	breq	.+16     	; 0x57a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     56a:	88 85       	ldd	r24, Y+8	; 0x08
     56c:	99 85       	ldd	r25, Y+9	; 0x09
     56e:	2e 81       	ldd	r18, Y+6	; 0x06
     570:	3f 81       	ldd	r19, Y+7	; 0x07
     572:	82 2b       	or	r24, r18
     574:	93 2b       	or	r25, r19
     576:	99 87       	std	Y+9, r25	; 0x09
     578:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     57a:	ea 81       	ldd	r30, Y+2	; 0x02
     57c:	fb 81       	ldd	r31, Y+3	; 0x03
     57e:	80 81       	ld	r24, Z
     580:	91 81       	ldd	r25, Z+1	; 0x01
     582:	9c 01       	movw	r18, r24
     584:	32 60       	ori	r19, 0x02	; 2
     586:	88 89       	ldd	r24, Y+16	; 0x10
     588:	99 89       	ldd	r25, Y+17	; 0x11
     58a:	b9 01       	movw	r22, r18
     58c:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     590:	8e 85       	ldd	r24, Y+14	; 0x0e
     592:	9f 85       	ldd	r25, Y+15	; 0x0f
     594:	99 8b       	std	Y+17, r25	; 0x11
     596:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     598:	28 89       	ldd	r18, Y+16	; 0x10
     59a:	39 89       	ldd	r19, Y+17	; 0x11
     59c:	8c 85       	ldd	r24, Y+12	; 0x0c
     59e:	9d 85       	ldd	r25, Y+13	; 0x0d
     5a0:	28 17       	cp	r18, r24
     5a2:	39 07       	cpc	r19, r25
     5a4:	09 f0       	breq	.+2      	; 0x5a8 <xEventGroupSetBits+0x12a>
     5a6:	9f cf       	rjmp	.-194    	; 0x4e6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     5a8:	ea 81       	ldd	r30, Y+2	; 0x02
     5aa:	fb 81       	ldd	r31, Y+3	; 0x03
     5ac:	20 81       	ld	r18, Z
     5ae:	31 81       	ldd	r19, Z+1	; 0x01
     5b0:	88 85       	ldd	r24, Y+8	; 0x08
     5b2:	99 85       	ldd	r25, Y+9	; 0x09
     5b4:	80 95       	com	r24
     5b6:	90 95       	com	r25
     5b8:	82 23       	and	r24, r18
     5ba:	93 23       	and	r25, r19
     5bc:	ea 81       	ldd	r30, Y+2	; 0x02
     5be:	fb 81       	ldd	r31, Y+3	; 0x03
     5c0:	91 83       	std	Z+1, r25	; 0x01
     5c2:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     5c4:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     5c8:	ea 81       	ldd	r30, Y+2	; 0x02
     5ca:	fb 81       	ldd	r31, Y+3	; 0x03
     5cc:	80 81       	ld	r24, Z
     5ce:	91 81       	ldd	r25, Z+1	; 0x01
}
     5d0:	65 96       	adiw	r28, 0x15	; 21
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	de bf       	out	0x3e, r29	; 62
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	cd bf       	out	0x3d, r28	; 61
     5dc:	cf 91       	pop	r28
     5de:	df 91       	pop	r29
     5e0:	08 95       	ret

000005e2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     5e2:	df 93       	push	r29
     5e4:	cf 93       	push	r28
     5e6:	00 d0       	rcall	.+0      	; 0x5e8 <vEventGroupDelete+0x6>
     5e8:	00 d0       	rcall	.+0      	; 0x5ea <vEventGroupDelete+0x8>
     5ea:	00 d0       	rcall	.+0      	; 0x5ec <vEventGroupDelete+0xa>
     5ec:	cd b7       	in	r28, 0x3d	; 61
     5ee:	de b7       	in	r29, 0x3e	; 62
     5f0:	9e 83       	std	Y+6, r25	; 0x06
     5f2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     5f4:	8d 81       	ldd	r24, Y+5	; 0x05
     5f6:	9e 81       	ldd	r25, Y+6	; 0x06
     5f8:	9c 83       	std	Y+4, r25	; 0x04
     5fa:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     5fc:	8b 81       	ldd	r24, Y+3	; 0x03
     5fe:	9c 81       	ldd	r25, Y+4	; 0x04
     600:	02 96       	adiw	r24, 0x02	; 2
     602:	9a 83       	std	Y+2, r25	; 0x02
     604:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     606:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
     60a:	08 c0       	rjmp	.+16     	; 0x61c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     60c:	e9 81       	ldd	r30, Y+1	; 0x01
     60e:	fa 81       	ldd	r31, Y+2	; 0x02
     610:	85 81       	ldd	r24, Z+5	; 0x05
     612:	96 81       	ldd	r25, Z+6	; 0x06
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	72 e0       	ldi	r23, 0x02	; 2
     618:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     61c:	e9 81       	ldd	r30, Y+1	; 0x01
     61e:	fa 81       	ldd	r31, Y+2	; 0x02
     620:	80 81       	ld	r24, Z
     622:	88 23       	and	r24, r24
     624:	99 f7       	brne	.-26     	; 0x60c <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	9c 81       	ldd	r25, Y+4	; 0x04
     62a:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     62e:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
}
     632:	26 96       	adiw	r28, 0x06	; 6
     634:	0f b6       	in	r0, 0x3f	; 63
     636:	f8 94       	cli
     638:	de bf       	out	0x3e, r29	; 62
     63a:	0f be       	out	0x3f, r0	; 63
     63c:	cd bf       	out	0x3d, r28	; 61
     63e:	cf 91       	pop	r28
     640:	df 91       	pop	r29
     642:	08 95       	ret

00000644 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     644:	df 93       	push	r29
     646:	cf 93       	push	r28
     648:	00 d0       	rcall	.+0      	; 0x64a <vEventGroupSetBitsCallback+0x6>
     64a:	00 d0       	rcall	.+0      	; 0x64c <vEventGroupSetBitsCallback+0x8>
     64c:	00 d0       	rcall	.+0      	; 0x64e <vEventGroupSetBitsCallback+0xa>
     64e:	cd b7       	in	r28, 0x3d	; 61
     650:	de b7       	in	r29, 0x3e	; 62
     652:	9a 83       	std	Y+2, r25	; 0x02
     654:	89 83       	std	Y+1, r24	; 0x01
     656:	4b 83       	std	Y+3, r20	; 0x03
     658:	5c 83       	std	Y+4, r21	; 0x04
     65a:	6d 83       	std	Y+5, r22	; 0x05
     65c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	9a 81       	ldd	r25, Y+2	; 0x02
     662:	2b 81       	ldd	r18, Y+3	; 0x03
     664:	3c 81       	ldd	r19, Y+4	; 0x04
     666:	b9 01       	movw	r22, r18
     668:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
}
     66c:	26 96       	adiw	r28, 0x06	; 6
     66e:	0f b6       	in	r0, 0x3f	; 63
     670:	f8 94       	cli
     672:	de bf       	out	0x3e, r29	; 62
     674:	0f be       	out	0x3f, r0	; 63
     676:	cd bf       	out	0x3d, r28	; 61
     678:	cf 91       	pop	r28
     67a:	df 91       	pop	r29
     67c:	08 95       	ret

0000067e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     67e:	df 93       	push	r29
     680:	cf 93       	push	r28
     682:	00 d0       	rcall	.+0      	; 0x684 <vEventGroupClearBitsCallback+0x6>
     684:	00 d0       	rcall	.+0      	; 0x686 <vEventGroupClearBitsCallback+0x8>
     686:	00 d0       	rcall	.+0      	; 0x688 <vEventGroupClearBitsCallback+0xa>
     688:	cd b7       	in	r28, 0x3d	; 61
     68a:	de b7       	in	r29, 0x3e	; 62
     68c:	9a 83       	std	Y+2, r25	; 0x02
     68e:	89 83       	std	Y+1, r24	; 0x01
     690:	4b 83       	std	Y+3, r20	; 0x03
     692:	5c 83       	std	Y+4, r21	; 0x04
     694:	6d 83       	std	Y+5, r22	; 0x05
     696:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     698:	89 81       	ldd	r24, Y+1	; 0x01
     69a:	9a 81       	ldd	r25, Y+2	; 0x02
     69c:	2b 81       	ldd	r18, Y+3	; 0x03
     69e:	3c 81       	ldd	r19, Y+4	; 0x04
     6a0:	b9 01       	movw	r22, r18
     6a2:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
}
     6a6:	26 96       	adiw	r28, 0x06	; 6
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	cf 91       	pop	r28
     6b4:	df 91       	pop	r29
     6b6:	08 95       	ret

000006b8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     6b8:	df 93       	push	r29
     6ba:	cf 93       	push	r28
     6bc:	00 d0       	rcall	.+0      	; 0x6be <prvTestWaitCondition+0x6>
     6be:	00 d0       	rcall	.+0      	; 0x6c0 <prvTestWaitCondition+0x8>
     6c0:	00 d0       	rcall	.+0      	; 0x6c2 <prvTestWaitCondition+0xa>
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
     6c6:	9b 83       	std	Y+3, r25	; 0x03
     6c8:	8a 83       	std	Y+2, r24	; 0x02
     6ca:	7d 83       	std	Y+5, r23	; 0x05
     6cc:	6c 83       	std	Y+4, r22	; 0x04
     6ce:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     6d0:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     6d2:	8e 81       	ldd	r24, Y+6	; 0x06
     6d4:	88 23       	and	r24, r24
     6d6:	59 f4       	brne	.+22     	; 0x6ee <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	2c 81       	ldd	r18, Y+4	; 0x04
     6de:	3d 81       	ldd	r19, Y+5	; 0x05
     6e0:	82 23       	and	r24, r18
     6e2:	93 23       	and	r25, r19
     6e4:	00 97       	sbiw	r24, 0x00	; 0
     6e6:	81 f0       	breq	.+32     	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	89 83       	std	Y+1, r24	; 0x01
     6ec:	0d c0       	rjmp	.+26     	; 0x708 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6ee:	2a 81       	ldd	r18, Y+2	; 0x02
     6f0:	3b 81       	ldd	r19, Y+3	; 0x03
     6f2:	8c 81       	ldd	r24, Y+4	; 0x04
     6f4:	9d 81       	ldd	r25, Y+5	; 0x05
     6f6:	28 23       	and	r18, r24
     6f8:	39 23       	and	r19, r25
     6fa:	8c 81       	ldd	r24, Y+4	; 0x04
     6fc:	9d 81       	ldd	r25, Y+5	; 0x05
     6fe:	28 17       	cp	r18, r24
     700:	39 07       	cpc	r19, r25
     702:	11 f4       	brne	.+4      	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     708:	89 81       	ldd	r24, Y+1	; 0x01
}
     70a:	26 96       	adiw	r28, 0x06	; 6
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	f8 94       	cli
     710:	de bf       	out	0x3e, r29	; 62
     712:	0f be       	out	0x3f, r0	; 63
     714:	cd bf       	out	0x3d, r28	; 61
     716:	cf 91       	pop	r28
     718:	df 91       	pop	r29
     71a:	08 95       	ret

0000071c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     71c:	df 93       	push	r29
     71e:	cf 93       	push	r28
     720:	00 d0       	rcall	.+0      	; 0x722 <pvPortMalloc+0x6>
     722:	00 d0       	rcall	.+0      	; 0x724 <pvPortMalloc+0x8>
     724:	cd b7       	in	r28, 0x3d	; 61
     726:	de b7       	in	r29, 0x3e	; 62
     728:	9c 83       	std	Y+4, r25	; 0x04
     72a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     72c:	1a 82       	std	Y+2, r1	; 0x02
     72e:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     730:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     734:	80 91 68 00 	lds	r24, 0x0068
     738:	90 91 69 00 	lds	r25, 0x0069
     73c:	00 97       	sbiw	r24, 0x00	; 0
     73e:	31 f4       	brne	.+12     	; 0x74c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     740:	8b e6       	ldi	r24, 0x6B	; 107
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	90 93 69 00 	sts	0x0069, r25
     748:	80 93 68 00 	sts	0x0068, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     74c:	80 91 66 00 	lds	r24, 0x0066
     750:	90 91 67 00 	lds	r25, 0x0067
     754:	2b 81       	ldd	r18, Y+3	; 0x03
     756:	3c 81       	ldd	r19, Y+4	; 0x04
     758:	82 0f       	add	r24, r18
     75a:	93 1f       	adc	r25, r19
     75c:	25 e0       	ldi	r18, 0x05	; 5
     75e:	8b 3d       	cpi	r24, 0xDB	; 219
     760:	92 07       	cpc	r25, r18
     762:	38 f5       	brcc	.+78     	; 0x7b2 <pvPortMalloc+0x96>
     764:	20 91 66 00 	lds	r18, 0x0066
     768:	30 91 67 00 	lds	r19, 0x0067
     76c:	8b 81       	ldd	r24, Y+3	; 0x03
     76e:	9c 81       	ldd	r25, Y+4	; 0x04
     770:	28 0f       	add	r18, r24
     772:	39 1f       	adc	r19, r25
     774:	80 91 66 00 	lds	r24, 0x0066
     778:	90 91 67 00 	lds	r25, 0x0067
     77c:	82 17       	cp	r24, r18
     77e:	93 07       	cpc	r25, r19
     780:	c0 f4       	brcc	.+48     	; 0x7b2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     782:	20 91 68 00 	lds	r18, 0x0068
     786:	30 91 69 00 	lds	r19, 0x0069
     78a:	80 91 66 00 	lds	r24, 0x0066
     78e:	90 91 67 00 	lds	r25, 0x0067
     792:	82 0f       	add	r24, r18
     794:	93 1f       	adc	r25, r19
     796:	9a 83       	std	Y+2, r25	; 0x02
     798:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     79a:	20 91 66 00 	lds	r18, 0x0066
     79e:	30 91 67 00 	lds	r19, 0x0067
     7a2:	8b 81       	ldd	r24, Y+3	; 0x03
     7a4:	9c 81       	ldd	r25, Y+4	; 0x04
     7a6:	82 0f       	add	r24, r18
     7a8:	93 1f       	adc	r25, r19
     7aa:	90 93 67 00 	sts	0x0067, r25
     7ae:	80 93 66 00 	sts	0x0066, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     7b2:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7ba:	0f 90       	pop	r0
     7bc:	0f 90       	pop	r0
     7be:	0f 90       	pop	r0
     7c0:	0f 90       	pop	r0
     7c2:	cf 91       	pop	r28
     7c4:	df 91       	pop	r29
     7c6:	08 95       	ret

000007c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7c8:	df 93       	push	r29
     7ca:	cf 93       	push	r28
     7cc:	00 d0       	rcall	.+0      	; 0x7ce <vPortFree+0x6>
     7ce:	cd b7       	in	r28, 0x3d	; 61
     7d0:	de b7       	in	r29, 0x3e	; 62
     7d2:	9a 83       	std	Y+2, r25	; 0x02
     7d4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	cf 91       	pop	r28
     7dc:	df 91       	pop	r29
     7de:	08 95       	ret

000007e0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7e0:	df 93       	push	r29
     7e2:	cf 93       	push	r28
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7e8:	10 92 67 00 	sts	0x0067, r1
     7ec:	10 92 66 00 	sts	0x0066, r1
}
     7f0:	cf 91       	pop	r28
     7f2:	df 91       	pop	r29
     7f4:	08 95       	ret

000007f6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7f6:	df 93       	push	r29
     7f8:	cf 93       	push	r28
     7fa:	cd b7       	in	r28, 0x3d	; 61
     7fc:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     7fe:	20 91 66 00 	lds	r18, 0x0066
     802:	30 91 67 00 	lds	r19, 0x0067
     806:	8b ed       	ldi	r24, 0xDB	; 219
     808:	95 e0       	ldi	r25, 0x05	; 5
     80a:	82 1b       	sub	r24, r18
     80c:	93 0b       	sbc	r25, r19
}
     80e:	cf 91       	pop	r28
     810:	df 91       	pop	r29
     812:	08 95       	ret

00000814 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     814:	df 93       	push	r29
     816:	cf 93       	push	r28
     818:	00 d0       	rcall	.+0      	; 0x81a <vListInitialise+0x6>
     81a:	cd b7       	in	r28, 0x3d	; 61
     81c:	de b7       	in	r29, 0x3e	; 62
     81e:	9a 83       	std	Y+2, r25	; 0x02
     820:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	9a 81       	ldd	r25, Y+2	; 0x02
     826:	03 96       	adiw	r24, 0x03	; 3
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	fa 81       	ldd	r31, Y+2	; 0x02
     82c:	92 83       	std	Z+2, r25	; 0x02
     82e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     830:	e9 81       	ldd	r30, Y+1	; 0x01
     832:	fa 81       	ldd	r31, Y+2	; 0x02
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	9f ef       	ldi	r25, 0xFF	; 255
     838:	94 83       	std	Z+4, r25	; 0x04
     83a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	9a 81       	ldd	r25, Y+2	; 0x02
     840:	03 96       	adiw	r24, 0x03	; 3
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	96 83       	std	Z+6, r25	; 0x06
     848:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	9a 81       	ldd	r25, Y+2	; 0x02
     84e:	03 96       	adiw	r24, 0x03	; 3
     850:	e9 81       	ldd	r30, Y+1	; 0x01
     852:	fa 81       	ldd	r31, Y+2	; 0x02
     854:	90 87       	std	Z+8, r25	; 0x08
     856:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     85e:	0f 90       	pop	r0
     860:	0f 90       	pop	r0
     862:	cf 91       	pop	r28
     864:	df 91       	pop	r29
     866:	08 95       	ret

00000868 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     868:	df 93       	push	r29
     86a:	cf 93       	push	r28
     86c:	00 d0       	rcall	.+0      	; 0x86e <vListInitialiseItem+0x6>
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	9a 83       	std	Y+2, r25	; 0x02
     874:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     876:	e9 81       	ldd	r30, Y+1	; 0x01
     878:	fa 81       	ldd	r31, Y+2	; 0x02
     87a:	11 86       	std	Z+9, r1	; 0x09
     87c:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	cf 91       	pop	r28
     884:	df 91       	pop	r29
     886:	08 95       	ret

00000888 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	00 d0       	rcall	.+0      	; 0x88e <vListInsertEnd+0x6>
     88e:	00 d0       	rcall	.+0      	; 0x890 <vListInsertEnd+0x8>
     890:	00 d0       	rcall	.+0      	; 0x892 <vListInsertEnd+0xa>
     892:	cd b7       	in	r28, 0x3d	; 61
     894:	de b7       	in	r29, 0x3e	; 62
     896:	9c 83       	std	Y+4, r25	; 0x04
     898:	8b 83       	std	Y+3, r24	; 0x03
     89a:	7e 83       	std	Y+6, r23	; 0x06
     89c:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     89e:	eb 81       	ldd	r30, Y+3	; 0x03
     8a0:	fc 81       	ldd	r31, Y+4	; 0x04
     8a2:	81 81       	ldd	r24, Z+1	; 0x01
     8a4:	92 81       	ldd	r25, Z+2	; 0x02
     8a6:	9a 83       	std	Y+2, r25	; 0x02
     8a8:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8aa:	ed 81       	ldd	r30, Y+5	; 0x05
     8ac:	fe 81       	ldd	r31, Y+6	; 0x06
     8ae:	89 81       	ldd	r24, Y+1	; 0x01
     8b0:	9a 81       	ldd	r25, Y+2	; 0x02
     8b2:	93 83       	std	Z+3, r25	; 0x03
     8b4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8b6:	e9 81       	ldd	r30, Y+1	; 0x01
     8b8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ba:	84 81       	ldd	r24, Z+4	; 0x04
     8bc:	95 81       	ldd	r25, Z+5	; 0x05
     8be:	ed 81       	ldd	r30, Y+5	; 0x05
     8c0:	fe 81       	ldd	r31, Y+6	; 0x06
     8c2:	95 83       	std	Z+5, r25	; 0x05
     8c4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8c6:	e9 81       	ldd	r30, Y+1	; 0x01
     8c8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ca:	04 80       	ldd	r0, Z+4	; 0x04
     8cc:	f5 81       	ldd	r31, Z+5	; 0x05
     8ce:	e0 2d       	mov	r30, r0
     8d0:	8d 81       	ldd	r24, Y+5	; 0x05
     8d2:	9e 81       	ldd	r25, Y+6	; 0x06
     8d4:	93 83       	std	Z+3, r25	; 0x03
     8d6:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	9e 81       	ldd	r25, Y+6	; 0x06
     8e0:	95 83       	std	Z+5, r25	; 0x05
     8e2:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     8e4:	ed 81       	ldd	r30, Y+5	; 0x05
     8e6:	fe 81       	ldd	r31, Y+6	; 0x06
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	91 87       	std	Z+9, r25	; 0x09
     8ee:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8f0:	eb 81       	ldd	r30, Y+3	; 0x03
     8f2:	fc 81       	ldd	r31, Y+4	; 0x04
     8f4:	80 81       	ld	r24, Z
     8f6:	8f 5f       	subi	r24, 0xFF	; 255
     8f8:	eb 81       	ldd	r30, Y+3	; 0x03
     8fa:	fc 81       	ldd	r31, Y+4	; 0x04
     8fc:	80 83       	st	Z, r24
}
     8fe:	26 96       	adiw	r28, 0x06	; 6
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	de bf       	out	0x3e, r29	; 62
     906:	0f be       	out	0x3f, r0	; 63
     908:	cd bf       	out	0x3d, r28	; 61
     90a:	cf 91       	pop	r28
     90c:	df 91       	pop	r29
     90e:	08 95       	ret

00000910 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     910:	df 93       	push	r29
     912:	cf 93       	push	r28
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	28 97       	sbiw	r28, 0x08	; 8
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	f8 94       	cli
     91e:	de bf       	out	0x3e, r29	; 62
     920:	0f be       	out	0x3f, r0	; 63
     922:	cd bf       	out	0x3d, r28	; 61
     924:	9e 83       	std	Y+6, r25	; 0x06
     926:	8d 83       	std	Y+5, r24	; 0x05
     928:	78 87       	std	Y+8, r23	; 0x08
     92a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     92c:	ef 81       	ldd	r30, Y+7	; 0x07
     92e:	f8 85       	ldd	r31, Y+8	; 0x08
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	9a 83       	std	Y+2, r25	; 0x02
     936:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	2f ef       	ldi	r18, 0xFF	; 255
     93e:	8f 3f       	cpi	r24, 0xFF	; 255
     940:	92 07       	cpc	r25, r18
     942:	39 f4       	brne	.+14     	; 0x952 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     944:	ed 81       	ldd	r30, Y+5	; 0x05
     946:	fe 81       	ldd	r31, Y+6	; 0x06
     948:	87 81       	ldd	r24, Z+7	; 0x07
     94a:	90 85       	ldd	r25, Z+8	; 0x08
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	8b 83       	std	Y+3, r24	; 0x03
     950:	18 c0       	rjmp	.+48     	; 0x982 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     952:	8d 81       	ldd	r24, Y+5	; 0x05
     954:	9e 81       	ldd	r25, Y+6	; 0x06
     956:	03 96       	adiw	r24, 0x03	; 3
     958:	9c 83       	std	Y+4, r25	; 0x04
     95a:	8b 83       	std	Y+3, r24	; 0x03
     95c:	06 c0       	rjmp	.+12     	; 0x96a <vListInsert+0x5a>
     95e:	eb 81       	ldd	r30, Y+3	; 0x03
     960:	fc 81       	ldd	r31, Y+4	; 0x04
     962:	82 81       	ldd	r24, Z+2	; 0x02
     964:	93 81       	ldd	r25, Z+3	; 0x03
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
     96a:	eb 81       	ldd	r30, Y+3	; 0x03
     96c:	fc 81       	ldd	r31, Y+4	; 0x04
     96e:	02 80       	ldd	r0, Z+2	; 0x02
     970:	f3 81       	ldd	r31, Z+3	; 0x03
     972:	e0 2d       	mov	r30, r0
     974:	20 81       	ld	r18, Z
     976:	31 81       	ldd	r19, Z+1	; 0x01
     978:	89 81       	ldd	r24, Y+1	; 0x01
     97a:	9a 81       	ldd	r25, Y+2	; 0x02
     97c:	82 17       	cp	r24, r18
     97e:	93 07       	cpc	r25, r19
     980:	70 f7       	brcc	.-36     	; 0x95e <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     982:	eb 81       	ldd	r30, Y+3	; 0x03
     984:	fc 81       	ldd	r31, Y+4	; 0x04
     986:	82 81       	ldd	r24, Z+2	; 0x02
     988:	93 81       	ldd	r25, Z+3	; 0x03
     98a:	ef 81       	ldd	r30, Y+7	; 0x07
     98c:	f8 85       	ldd	r31, Y+8	; 0x08
     98e:	93 83       	std	Z+3, r25	; 0x03
     990:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     992:	ef 81       	ldd	r30, Y+7	; 0x07
     994:	f8 85       	ldd	r31, Y+8	; 0x08
     996:	02 80       	ldd	r0, Z+2	; 0x02
     998:	f3 81       	ldd	r31, Z+3	; 0x03
     99a:	e0 2d       	mov	r30, r0
     99c:	8f 81       	ldd	r24, Y+7	; 0x07
     99e:	98 85       	ldd	r25, Y+8	; 0x08
     9a0:	95 83       	std	Z+5, r25	; 0x05
     9a2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9a4:	ef 81       	ldd	r30, Y+7	; 0x07
     9a6:	f8 85       	ldd	r31, Y+8	; 0x08
     9a8:	8b 81       	ldd	r24, Y+3	; 0x03
     9aa:	9c 81       	ldd	r25, Y+4	; 0x04
     9ac:	95 83       	std	Z+5, r25	; 0x05
     9ae:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	8f 81       	ldd	r24, Y+7	; 0x07
     9b6:	98 85       	ldd	r25, Y+8	; 0x08
     9b8:	93 83       	std	Z+3, r25	; 0x03
     9ba:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     9bc:	ef 81       	ldd	r30, Y+7	; 0x07
     9be:	f8 85       	ldd	r31, Y+8	; 0x08
     9c0:	8d 81       	ldd	r24, Y+5	; 0x05
     9c2:	9e 81       	ldd	r25, Y+6	; 0x06
     9c4:	91 87       	std	Z+9, r25	; 0x09
     9c6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9c8:	ed 81       	ldd	r30, Y+5	; 0x05
     9ca:	fe 81       	ldd	r31, Y+6	; 0x06
     9cc:	80 81       	ld	r24, Z
     9ce:	8f 5f       	subi	r24, 0xFF	; 255
     9d0:	ed 81       	ldd	r30, Y+5	; 0x05
     9d2:	fe 81       	ldd	r31, Y+6	; 0x06
     9d4:	80 83       	st	Z, r24
}
     9d6:	28 96       	adiw	r28, 0x08	; 8
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	de bf       	out	0x3e, r29	; 62
     9de:	0f be       	out	0x3f, r0	; 63
     9e0:	cd bf       	out	0x3d, r28	; 61
     9e2:	cf 91       	pop	r28
     9e4:	df 91       	pop	r29
     9e6:	08 95       	ret

000009e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9e8:	df 93       	push	r29
     9ea:	cf 93       	push	r28
     9ec:	00 d0       	rcall	.+0      	; 0x9ee <uxListRemove+0x6>
     9ee:	00 d0       	rcall	.+0      	; 0x9f0 <uxListRemove+0x8>
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	9c 83       	std	Y+4, r25	; 0x04
     9f6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     9f8:	eb 81       	ldd	r30, Y+3	; 0x03
     9fa:	fc 81       	ldd	r31, Y+4	; 0x04
     9fc:	80 85       	ldd	r24, Z+8	; 0x08
     9fe:	91 85       	ldd	r25, Z+9	; 0x09
     a00:	9a 83       	std	Y+2, r25	; 0x02
     a02:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	a2 81       	ldd	r26, Z+2	; 0x02
     a0a:	b3 81       	ldd	r27, Z+3	; 0x03
     a0c:	eb 81       	ldd	r30, Y+3	; 0x03
     a0e:	fc 81       	ldd	r31, Y+4	; 0x04
     a10:	84 81       	ldd	r24, Z+4	; 0x04
     a12:	95 81       	ldd	r25, Z+5	; 0x05
     a14:	15 96       	adiw	r26, 0x05	; 5
     a16:	9c 93       	st	X, r25
     a18:	8e 93       	st	-X, r24
     a1a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a1c:	eb 81       	ldd	r30, Y+3	; 0x03
     a1e:	fc 81       	ldd	r31, Y+4	; 0x04
     a20:	a4 81       	ldd	r26, Z+4	; 0x04
     a22:	b5 81       	ldd	r27, Z+5	; 0x05
     a24:	eb 81       	ldd	r30, Y+3	; 0x03
     a26:	fc 81       	ldd	r31, Y+4	; 0x04
     a28:	82 81       	ldd	r24, Z+2	; 0x02
     a2a:	93 81       	ldd	r25, Z+3	; 0x03
     a2c:	13 96       	adiw	r26, 0x03	; 3
     a2e:	9c 93       	st	X, r25
     a30:	8e 93       	st	-X, r24
     a32:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a34:	e9 81       	ldd	r30, Y+1	; 0x01
     a36:	fa 81       	ldd	r31, Y+2	; 0x02
     a38:	21 81       	ldd	r18, Z+1	; 0x01
     a3a:	32 81       	ldd	r19, Z+2	; 0x02
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	28 17       	cp	r18, r24
     a42:	39 07       	cpc	r19, r25
     a44:	41 f4       	brne	.+16     	; 0xa56 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	84 81       	ldd	r24, Z+4	; 0x04
     a4c:	95 81       	ldd	r25, Z+5	; 0x05
     a4e:	e9 81       	ldd	r30, Y+1	; 0x01
     a50:	fa 81       	ldd	r31, Y+2	; 0x02
     a52:	92 83       	std	Z+2, r25	; 0x02
     a54:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     a56:	eb 81       	ldd	r30, Y+3	; 0x03
     a58:	fc 81       	ldd	r31, Y+4	; 0x04
     a5a:	11 86       	std	Z+9, r1	; 0x09
     a5c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a5e:	e9 81       	ldd	r30, Y+1	; 0x01
     a60:	fa 81       	ldd	r31, Y+2	; 0x02
     a62:	80 81       	ld	r24, Z
     a64:	81 50       	subi	r24, 0x01	; 1
     a66:	e9 81       	ldd	r30, Y+1	; 0x01
     a68:	fa 81       	ldd	r31, Y+2	; 0x02
     a6a:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     a6c:	e9 81       	ldd	r30, Y+1	; 0x01
     a6e:	fa 81       	ldd	r31, Y+2	; 0x02
     a70:	80 81       	ld	r24, Z
}
     a72:	0f 90       	pop	r0
     a74:	0f 90       	pop	r0
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	cf 91       	pop	r28
     a7c:	df 91       	pop	r29
     a7e:	08 95       	ret

00000a80 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     a80:	df 93       	push	r29
     a82:	cf 93       	push	r28
     a84:	cd b7       	in	r28, 0x3d	; 61
     a86:	de b7       	in	r29, 0x3e	; 62
     a88:	28 97       	sbiw	r28, 0x08	; 8
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	de bf       	out	0x3e, r29	; 62
     a90:	0f be       	out	0x3f, r0	; 63
     a92:	cd bf       	out	0x3d, r28	; 61
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03
     a98:	7e 83       	std	Y+6, r23	; 0x06
     a9a:	6d 83       	std	Y+5, r22	; 0x05
     a9c:	58 87       	std	Y+8, r21	; 0x08
     a9e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	81 e1       	ldi	r24, 0x11	; 17
     aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
     aa8:	8b 81       	ldd	r24, Y+3	; 0x03
     aaa:	9c 81       	ldd	r25, Y+4	; 0x04
     aac:	01 97       	sbiw	r24, 0x01	; 1
     aae:	9c 83       	std	Y+4, r25	; 0x04
     ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	82 e2       	ldi	r24, 0x22	; 34
     ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	9c 83       	std	Y+4, r25	; 0x04
     ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ac4:	eb 81       	ldd	r30, Y+3	; 0x03
     ac6:	fc 81       	ldd	r31, Y+4	; 0x04
     ac8:	83 e3       	ldi	r24, 0x33	; 51
     aca:	80 83       	st	Z, r24
	pxTopOfStack--;
     acc:	8b 81       	ldd	r24, Y+3	; 0x03
     ace:	9c 81       	ldd	r25, Y+4	; 0x04
     ad0:	01 97       	sbiw	r24, 0x01	; 1
     ad2:	9c 83       	std	Y+4, r25	; 0x04
     ad4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     ad6:	8d 81       	ldd	r24, Y+5	; 0x05
     ad8:	9e 81       	ldd	r25, Y+6	; 0x06
     ada:	9a 83       	std	Y+2, r25	; 0x02
     adc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	9c 83       	std	Y+4, r25	; 0x04
     aee:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	9a 81       	ldd	r25, Y+2	; 0x02
     af4:	89 2f       	mov	r24, r25
     af6:	99 27       	eor	r25, r25
     af8:	9a 83       	std	Y+2, r25	; 0x02
     afa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	80 83       	st	Z, r24
	pxTopOfStack--;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	9c 81       	ldd	r25, Y+4	; 0x04
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	9c 83       	std	Y+4, r25	; 0x04
     b0c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b0e:	eb 81       	ldd	r30, Y+3	; 0x03
     b10:	fc 81       	ldd	r31, Y+4	; 0x04
     b12:	10 82       	st	Z, r1
	pxTopOfStack--;
     b14:	8b 81       	ldd	r24, Y+3	; 0x03
     b16:	9c 81       	ldd	r25, Y+4	; 0x04
     b18:	01 97       	sbiw	r24, 0x01	; 1
     b1a:	9c 83       	std	Y+4, r25	; 0x04
     b1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b1e:	eb 81       	ldd	r30, Y+3	; 0x03
     b20:	fc 81       	ldd	r31, Y+4	; 0x04
     b22:	80 e8       	ldi	r24, 0x80	; 128
     b24:	80 83       	st	Z, r24
	pxTopOfStack--;
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	9c 81       	ldd	r25, Y+4	; 0x04
     b2a:	01 97       	sbiw	r24, 0x01	; 1
     b2c:	9c 83       	std	Y+4, r25	; 0x04
     b2e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b30:	eb 81       	ldd	r30, Y+3	; 0x03
     b32:	fc 81       	ldd	r31, Y+4	; 0x04
     b34:	10 82       	st	Z, r1
	pxTopOfStack--;
     b36:	8b 81       	ldd	r24, Y+3	; 0x03
     b38:	9c 81       	ldd	r25, Y+4	; 0x04
     b3a:	01 97       	sbiw	r24, 0x01	; 1
     b3c:	9c 83       	std	Y+4, r25	; 0x04
     b3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b40:	eb 81       	ldd	r30, Y+3	; 0x03
     b42:	fc 81       	ldd	r31, Y+4	; 0x04
     b44:	82 e0       	ldi	r24, 0x02	; 2
     b46:	80 83       	st	Z, r24
	pxTopOfStack--;
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	9c 81       	ldd	r25, Y+4	; 0x04
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	9c 83       	std	Y+4, r25	; 0x04
     b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b52:	eb 81       	ldd	r30, Y+3	; 0x03
     b54:	fc 81       	ldd	r31, Y+4	; 0x04
     b56:	83 e0       	ldi	r24, 0x03	; 3
     b58:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b64:	eb 81       	ldd	r30, Y+3	; 0x03
     b66:	fc 81       	ldd	r31, Y+4	; 0x04
     b68:	84 e0       	ldi	r24, 0x04	; 4
     b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	85 e0       	ldi	r24, 0x05	; 5
     b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	9c 83       	std	Y+4, r25	; 0x04
     b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b88:	eb 81       	ldd	r30, Y+3	; 0x03
     b8a:	fc 81       	ldd	r31, Y+4	; 0x04
     b8c:	86 e0       	ldi	r24, 0x06	; 6
     b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	01 97       	sbiw	r24, 0x01	; 1
     b96:	9c 83       	std	Y+4, r25	; 0x04
     b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b9a:	eb 81       	ldd	r30, Y+3	; 0x03
     b9c:	fc 81       	ldd	r31, Y+4	; 0x04
     b9e:	87 e0       	ldi	r24, 0x07	; 7
     ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	01 97       	sbiw	r24, 0x01	; 1
     ba8:	9c 83       	std	Y+4, r25	; 0x04
     baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     bac:	eb 81       	ldd	r30, Y+3	; 0x03
     bae:	fc 81       	ldd	r31, Y+4	; 0x04
     bb0:	88 e0       	ldi	r24, 0x08	; 8
     bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	9c 81       	ldd	r25, Y+4	; 0x04
     bb8:	01 97       	sbiw	r24, 0x01	; 1
     bba:	9c 83       	std	Y+4, r25	; 0x04
     bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     bbe:	eb 81       	ldd	r30, Y+3	; 0x03
     bc0:	fc 81       	ldd	r31, Y+4	; 0x04
     bc2:	89 e0       	ldi	r24, 0x09	; 9
     bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     bd0:	eb 81       	ldd	r30, Y+3	; 0x03
     bd2:	fc 81       	ldd	r31, Y+4	; 0x04
     bd4:	80 e1       	ldi	r24, 0x10	; 16
     bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	9c 81       	ldd	r25, Y+4	; 0x04
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	9c 83       	std	Y+4, r25	; 0x04
     be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	81 e1       	ldi	r24, 0x11	; 17
     be8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	9c 83       	std	Y+4, r25	; 0x04
     bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     bf4:	eb 81       	ldd	r30, Y+3	; 0x03
     bf6:	fc 81       	ldd	r31, Y+4	; 0x04
     bf8:	82 e1       	ldi	r24, 0x12	; 18
     bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	9c 83       	std	Y+4, r25	; 0x04
     c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     c06:	eb 81       	ldd	r30, Y+3	; 0x03
     c08:	fc 81       	ldd	r31, Y+4	; 0x04
     c0a:	83 e1       	ldi	r24, 0x13	; 19
     c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     c18:	eb 81       	ldd	r30, Y+3	; 0x03
     c1a:	fc 81       	ldd	r31, Y+4	; 0x04
     c1c:	84 e1       	ldi	r24, 0x14	; 20
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	85 e1       	ldi	r24, 0x15	; 21
     c30:	80 83       	st	Z, r24
	pxTopOfStack--;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	9c 83       	std	Y+4, r25	; 0x04
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c3c:	eb 81       	ldd	r30, Y+3	; 0x03
     c3e:	fc 81       	ldd	r31, Y+4	; 0x04
     c40:	86 e1       	ldi	r24, 0x16	; 22
     c42:	80 83       	st	Z, r24
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c4e:	eb 81       	ldd	r30, Y+3	; 0x03
     c50:	fc 81       	ldd	r31, Y+4	; 0x04
     c52:	87 e1       	ldi	r24, 0x17	; 23
     c54:	80 83       	st	Z, r24
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c60:	eb 81       	ldd	r30, Y+3	; 0x03
     c62:	fc 81       	ldd	r31, Y+4	; 0x04
     c64:	88 e1       	ldi	r24, 0x18	; 24
     c66:	80 83       	st	Z, r24
	pxTopOfStack--;
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	9c 83       	std	Y+4, r25	; 0x04
     c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c72:	eb 81       	ldd	r30, Y+3	; 0x03
     c74:	fc 81       	ldd	r31, Y+4	; 0x04
     c76:	89 e1       	ldi	r24, 0x19	; 25
     c78:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	9c 81       	ldd	r25, Y+4	; 0x04
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	9c 83       	std	Y+4, r25	; 0x04
     c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	80 e2       	ldi	r24, 0x20	; 32
     c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	9c 83       	std	Y+4, r25	; 0x04
     c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     c96:	eb 81       	ldd	r30, Y+3	; 0x03
     c98:	fc 81       	ldd	r31, Y+4	; 0x04
     c9a:	81 e2       	ldi	r24, 0x21	; 33
     c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	9c 83       	std	Y+4, r25	; 0x04
     ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     ca8:	eb 81       	ldd	r30, Y+3	; 0x03
     caa:	fc 81       	ldd	r31, Y+4	; 0x04
     cac:	82 e2       	ldi	r24, 0x22	; 34
     cae:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	9c 83       	std	Y+4, r25	; 0x04
     cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     cba:	eb 81       	ldd	r30, Y+3	; 0x03
     cbc:	fc 81       	ldd	r31, Y+4	; 0x04
     cbe:	83 e2       	ldi	r24, 0x23	; 35
     cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     ccc:	8f 81       	ldd	r24, Y+7	; 0x07
     cce:	98 85       	ldd	r25, Y+8	; 0x08
     cd0:	9a 83       	std	Y+2, r25	; 0x02
     cd2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	eb 81       	ldd	r30, Y+3	; 0x03
     cd8:	fc 81       	ldd	r31, Y+4	; 0x04
     cda:	80 83       	st	Z, r24
	pxTopOfStack--;
     cdc:	8b 81       	ldd	r24, Y+3	; 0x03
     cde:	9c 81       	ldd	r25, Y+4	; 0x04
     ce0:	01 97       	sbiw	r24, 0x01	; 1
     ce2:	9c 83       	std	Y+4, r25	; 0x04
     ce4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	9a 81       	ldd	r25, Y+2	; 0x02
     cea:	89 2f       	mov	r24, r25
     cec:	99 27       	eor	r25, r25
     cee:	9a 83       	std	Y+2, r25	; 0x02
     cf0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	eb 81       	ldd	r30, Y+3	; 0x03
     cf6:	fc 81       	ldd	r31, Y+4	; 0x04
     cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfa:	8b 81       	ldd	r24, Y+3	; 0x03
     cfc:	9c 81       	ldd	r25, Y+4	; 0x04
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9c 83       	std	Y+4, r25	; 0x04
     d02:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d04:	eb 81       	ldd	r30, Y+3	; 0x03
     d06:	fc 81       	ldd	r31, Y+4	; 0x04
     d08:	86 e2       	ldi	r24, 0x26	; 38
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	87 e2       	ldi	r24, 0x27	; 39
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	88 e2       	ldi	r24, 0x28	; 40
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	89 e2       	ldi	r24, 0x29	; 41
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	80 e3       	ldi	r24, 0x30	; 48
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	81 e3       	ldi	r24, 0x31	; 49
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d74:	28 96       	adiw	r28, 0x08	; 8
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	cd b7       	in	r28, 0x3d	; 61
     d8c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d8e:	0e 94 b5 07 	call	0xf6a	; 0xf6a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d92:	a0 91 46 06 	lds	r26, 0x0646
     d96:	b0 91 47 06 	lds	r27, 0x0647
     d9a:	cd 91       	ld	r28, X+
     d9c:	cd bf       	out	0x3d, r28	; 61
     d9e:	dd 91       	ld	r29, X+
     da0:	de bf       	out	0x3e, r29	; 62
     da2:	ff 91       	pop	r31
     da4:	ef 91       	pop	r30
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	bf 91       	pop	r27
     dac:	af 91       	pop	r26
     dae:	9f 91       	pop	r25
     db0:	8f 91       	pop	r24
     db2:	7f 91       	pop	r23
     db4:	6f 91       	pop	r22
     db6:	5f 91       	pop	r21
     db8:	4f 91       	pop	r20
     dba:	3f 91       	pop	r19
     dbc:	2f 91       	pop	r18
     dbe:	1f 91       	pop	r17
     dc0:	0f 91       	pop	r16
     dc2:	ff 90       	pop	r15
     dc4:	ef 90       	pop	r14
     dc6:	df 90       	pop	r13
     dc8:	cf 90       	pop	r12
     dca:	bf 90       	pop	r11
     dcc:	af 90       	pop	r10
     dce:	9f 90       	pop	r9
     dd0:	8f 90       	pop	r8
     dd2:	7f 90       	pop	r7
     dd4:	6f 90       	pop	r6
     dd6:	5f 90       	pop	r5
     dd8:	4f 90       	pop	r4
     dda:	3f 90       	pop	r3
     ddc:	2f 90       	pop	r2
     dde:	1f 90       	pop	r1
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
     de4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     de6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     de8:	81 e0       	ldi	r24, 0x01	; 1
}
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	08 95       	ret

00000df0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     df0:	df 93       	push	r29
     df2:	cf 93       	push	r28
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	08 95       	ret

00000dfe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dfe:	0f 92       	push	r0
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
     e06:	1f 92       	push	r1
     e08:	11 24       	eor	r1, r1
     e0a:	2f 92       	push	r2
     e0c:	3f 92       	push	r3
     e0e:	4f 92       	push	r4
     e10:	5f 92       	push	r5
     e12:	6f 92       	push	r6
     e14:	7f 92       	push	r7
     e16:	8f 92       	push	r8
     e18:	9f 92       	push	r9
     e1a:	af 92       	push	r10
     e1c:	bf 92       	push	r11
     e1e:	cf 92       	push	r12
     e20:	df 92       	push	r13
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	2f 93       	push	r18
     e2c:	3f 93       	push	r19
     e2e:	4f 93       	push	r20
     e30:	5f 93       	push	r21
     e32:	6f 93       	push	r22
     e34:	7f 93       	push	r23
     e36:	8f 93       	push	r24
     e38:	9f 93       	push	r25
     e3a:	af 93       	push	r26
     e3c:	bf 93       	push	r27
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	ef 93       	push	r30
     e44:	ff 93       	push	r31
     e46:	a0 91 46 06 	lds	r26, 0x0646
     e4a:	b0 91 47 06 	lds	r27, 0x0647
     e4e:	0d b6       	in	r0, 0x3d	; 61
     e50:	0d 92       	st	X+, r0
     e52:	0e b6       	in	r0, 0x3e	; 62
     e54:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e56:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e5a:	a0 91 46 06 	lds	r26, 0x0646
     e5e:	b0 91 47 06 	lds	r27, 0x0647
     e62:	cd 91       	ld	r28, X+
     e64:	cd bf       	out	0x3d, r28	; 61
     e66:	dd 91       	ld	r29, X+
     e68:	de bf       	out	0x3e, r29	; 62
     e6a:	ff 91       	pop	r31
     e6c:	ef 91       	pop	r30
     e6e:	df 91       	pop	r29
     e70:	cf 91       	pop	r28
     e72:	bf 91       	pop	r27
     e74:	af 91       	pop	r26
     e76:	9f 91       	pop	r25
     e78:	8f 91       	pop	r24
     e7a:	7f 91       	pop	r23
     e7c:	6f 91       	pop	r22
     e7e:	5f 91       	pop	r21
     e80:	4f 91       	pop	r20
     e82:	3f 91       	pop	r19
     e84:	2f 91       	pop	r18
     e86:	1f 91       	pop	r17
     e88:	0f 91       	pop	r16
     e8a:	ff 90       	pop	r15
     e8c:	ef 90       	pop	r14
     e8e:	df 90       	pop	r13
     e90:	cf 90       	pop	r12
     e92:	bf 90       	pop	r11
     e94:	af 90       	pop	r10
     e96:	9f 90       	pop	r9
     e98:	8f 90       	pop	r8
     e9a:	7f 90       	pop	r7
     e9c:	6f 90       	pop	r6
     e9e:	5f 90       	pop	r5
     ea0:	4f 90       	pop	r4
     ea2:	3f 90       	pop	r3
     ea4:	2f 90       	pop	r2
     ea6:	1f 90       	pop	r1
     ea8:	0f 90       	pop	r0
     eaa:	0f be       	out	0x3f, r0	; 63
     eac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     eae:	08 95       	ret

00000eb0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eb0:	0f 92       	push	r0
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	0f 92       	push	r0
     eb8:	1f 92       	push	r1
     eba:	11 24       	eor	r1, r1
     ebc:	2f 92       	push	r2
     ebe:	3f 92       	push	r3
     ec0:	4f 92       	push	r4
     ec2:	5f 92       	push	r5
     ec4:	6f 92       	push	r6
     ec6:	7f 92       	push	r7
     ec8:	8f 92       	push	r8
     eca:	9f 92       	push	r9
     ecc:	af 92       	push	r10
     ece:	bf 92       	push	r11
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	2f 93       	push	r18
     ede:	3f 93       	push	r19
     ee0:	4f 93       	push	r20
     ee2:	5f 93       	push	r21
     ee4:	6f 93       	push	r22
     ee6:	7f 93       	push	r23
     ee8:	8f 93       	push	r24
     eea:	9f 93       	push	r25
     eec:	af 93       	push	r26
     eee:	bf 93       	push	r27
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31
     ef8:	a0 91 46 06 	lds	r26, 0x0646
     efc:	b0 91 47 06 	lds	r27, 0x0647
     f00:	0d b6       	in	r0, 0x3d	; 61
     f02:	0d 92       	st	X+, r0
     f04:	0e b6       	in	r0, 0x3e	; 62
     f06:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f08:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <xTaskIncrementTick>
     f0c:	88 23       	and	r24, r24
     f0e:	11 f0       	breq	.+4      	; 0xf14 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f10:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f14:	a0 91 46 06 	lds	r26, 0x0646
     f18:	b0 91 47 06 	lds	r27, 0x0647
     f1c:	cd 91       	ld	r28, X+
     f1e:	cd bf       	out	0x3d, r28	; 61
     f20:	dd 91       	ld	r29, X+
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	ff 91       	pop	r31
     f26:	ef 91       	pop	r30
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	bf 91       	pop	r27
     f2e:	af 91       	pop	r26
     f30:	9f 91       	pop	r25
     f32:	8f 91       	pop	r24
     f34:	7f 91       	pop	r23
     f36:	6f 91       	pop	r22
     f38:	5f 91       	pop	r21
     f3a:	4f 91       	pop	r20
     f3c:	3f 91       	pop	r19
     f3e:	2f 91       	pop	r18
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	df 90       	pop	r13
     f4a:	cf 90       	pop	r12
     f4c:	bf 90       	pop	r11
     f4e:	af 90       	pop	r10
     f50:	9f 90       	pop	r9
     f52:	8f 90       	pop	r8
     f54:	7f 90       	pop	r7
     f56:	6f 90       	pop	r6
     f58:	5f 90       	pop	r5
     f5a:	4f 90       	pop	r4
     f5c:	3f 90       	pop	r3
     f5e:	2f 90       	pop	r2
     f60:	1f 90       	pop	r1
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f68:	08 95       	ret

00000f6a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f6a:	df 93       	push	r29
     f6c:	cf 93       	push	r28
     f6e:	00 d0       	rcall	.+0      	; 0xf70 <prvSetupTimerInterrupt+0x6>
     f70:	00 d0       	rcall	.+0      	; 0xf72 <prvSetupTimerInterrupt+0x8>
     f72:	00 d0       	rcall	.+0      	; 0xf74 <prvSetupTimerInterrupt+0xa>
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f78:	80 e4       	ldi	r24, 0x40	; 64
     f7a:	9f e1       	ldi	r25, 0x1F	; 31
     f7c:	a0 e0       	ldi	r26, 0x00	; 0
     f7e:	b0 e0       	ldi	r27, 0x00	; 0
     f80:	8b 83       	std	Y+3, r24	; 0x03
     f82:	9c 83       	std	Y+4, r25	; 0x04
     f84:	ad 83       	std	Y+5, r26	; 0x05
     f86:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f88:	8b 81       	ldd	r24, Y+3	; 0x03
     f8a:	9c 81       	ldd	r25, Y+4	; 0x04
     f8c:	ad 81       	ldd	r26, Y+5	; 0x05
     f8e:	be 81       	ldd	r27, Y+6	; 0x06
     f90:	68 94       	set
     f92:	15 f8       	bld	r1, 5
     f94:	b6 95       	lsr	r27
     f96:	a7 95       	ror	r26
     f98:	97 95       	ror	r25
     f9a:	87 95       	ror	r24
     f9c:	16 94       	lsr	r1
     f9e:	d1 f7       	brne	.-12     	; 0xf94 <prvSetupTimerInterrupt+0x2a>
     fa0:	8b 83       	std	Y+3, r24	; 0x03
     fa2:	9c 83       	std	Y+4, r25	; 0x04
     fa4:	ad 83       	std	Y+5, r26	; 0x05
     fa6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	9c 81       	ldd	r25, Y+4	; 0x04
     fac:	ad 81       	ldd	r26, Y+5	; 0x05
     fae:	be 81       	ldd	r27, Y+6	; 0x06
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	a1 09       	sbc	r26, r1
     fb4:	b1 09       	sbc	r27, r1
     fb6:	8b 83       	std	Y+3, r24	; 0x03
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	ad 83       	std	Y+5, r26	; 0x05
     fbc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
     fc0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fc2:	8b 81       	ldd	r24, Y+3	; 0x03
     fc4:	9c 81       	ldd	r25, Y+4	; 0x04
     fc6:	ad 81       	ldd	r26, Y+5	; 0x05
     fc8:	be 81       	ldd	r27, Y+6	; 0x06
     fca:	89 2f       	mov	r24, r25
     fcc:	9a 2f       	mov	r25, r26
     fce:	ab 2f       	mov	r26, r27
     fd0:	bb 27       	eor	r27, r27
     fd2:	8b 83       	std	Y+3, r24	; 0x03
     fd4:	9c 83       	std	Y+4, r25	; 0x04
     fd6:	ad 83       	std	Y+5, r26	; 0x05
     fd8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fda:	8b 81       	ldd	r24, Y+3	; 0x03
     fdc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fde:	eb e4       	ldi	r30, 0x4B	; 75
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	8a 81       	ldd	r24, Y+2	; 0x02
     fe4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fe6:	ea e4       	ldi	r30, 0x4A	; 74
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fee:	8b e0       	ldi	r24, 0x0B	; 11
     ff0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     ff2:	ee e4       	ldi	r30, 0x4E	; 78
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	89 81       	ldd	r24, Y+1	; 0x01
     ff8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     ffa:	e9 e5       	ldi	r30, 0x59	; 89
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	80 81       	ld	r24, Z
    1000:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1002:	89 81       	ldd	r24, Y+1	; 0x01
    1004:	80 61       	ori	r24, 0x10	; 16
    1006:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1008:	e9 e5       	ldi	r30, 0x59	; 89
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	80 83       	st	Z, r24
}
    1010:	26 96       	adiw	r28, 0x06	; 6
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	f8 94       	cli
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	cf 91       	pop	r28
    101e:	df 91       	pop	r29
    1020:	08 95       	ret

00001022 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1022:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1026:	18 95       	reti

00001028 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1028:	df 93       	push	r29
    102a:	cf 93       	push	r28
    102c:	00 d0       	rcall	.+0      	; 0x102e <xQueueGenericReset+0x6>
    102e:	00 d0       	rcall	.+0      	; 0x1030 <xQueueGenericReset+0x8>
    1030:	0f 92       	push	r0
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
    103a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	9c 81       	ldd	r25, Y+4	; 0x04
    1040:	9a 83       	std	Y+2, r25	; 0x02
    1042:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1044:	0f b6       	in	r0, 0x3f	; 63
    1046:	f8 94       	cli
    1048:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    104a:	e9 81       	ldd	r30, Y+1	; 0x01
    104c:	fa 81       	ldd	r31, Y+2	; 0x02
    104e:	40 81       	ld	r20, Z
    1050:	51 81       	ldd	r21, Z+1	; 0x01
    1052:	e9 81       	ldd	r30, Y+1	; 0x01
    1054:	fa 81       	ldd	r31, Y+2	; 0x02
    1056:	83 8d       	ldd	r24, Z+27	; 0x1b
    1058:	28 2f       	mov	r18, r24
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	e9 81       	ldd	r30, Y+1	; 0x01
    105e:	fa 81       	ldd	r31, Y+2	; 0x02
    1060:	84 8d       	ldd	r24, Z+28	; 0x1c
    1062:	88 2f       	mov	r24, r24
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	bc 01       	movw	r22, r24
    1068:	26 9f       	mul	r18, r22
    106a:	c0 01       	movw	r24, r0
    106c:	27 9f       	mul	r18, r23
    106e:	90 0d       	add	r25, r0
    1070:	36 9f       	mul	r19, r22
    1072:	90 0d       	add	r25, r0
    1074:	11 24       	eor	r1, r1
    1076:	84 0f       	add	r24, r20
    1078:	95 1f       	adc	r25, r21
    107a:	e9 81       	ldd	r30, Y+1	; 0x01
    107c:	fa 81       	ldd	r31, Y+2	; 0x02
    107e:	95 83       	std	Z+5, r25	; 0x05
    1080:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1082:	e9 81       	ldd	r30, Y+1	; 0x01
    1084:	fa 81       	ldd	r31, Y+2	; 0x02
    1086:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1088:	e9 81       	ldd	r30, Y+1	; 0x01
    108a:	fa 81       	ldd	r31, Y+2	; 0x02
    108c:	80 81       	ld	r24, Z
    108e:	91 81       	ldd	r25, Z+1	; 0x01
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	93 83       	std	Z+3, r25	; 0x03
    1096:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1098:	e9 81       	ldd	r30, Y+1	; 0x01
    109a:	fa 81       	ldd	r31, Y+2	; 0x02
    109c:	40 81       	ld	r20, Z
    109e:	51 81       	ldd	r21, Z+1	; 0x01
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a6:	88 2f       	mov	r24, r24
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	9c 01       	movw	r18, r24
    10ac:	21 50       	subi	r18, 0x01	; 1
    10ae:	30 40       	sbci	r19, 0x00	; 0
    10b0:	e9 81       	ldd	r30, Y+1	; 0x01
    10b2:	fa 81       	ldd	r31, Y+2	; 0x02
    10b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    10b6:	88 2f       	mov	r24, r24
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	bc 01       	movw	r22, r24
    10bc:	26 9f       	mul	r18, r22
    10be:	c0 01       	movw	r24, r0
    10c0:	27 9f       	mul	r18, r23
    10c2:	90 0d       	add	r25, r0
    10c4:	36 9f       	mul	r19, r22
    10c6:	90 0d       	add	r25, r0
    10c8:	11 24       	eor	r1, r1
    10ca:	84 0f       	add	r24, r20
    10cc:	95 1f       	adc	r25, r21
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	97 83       	std	Z+7, r25	; 0x07
    10d4:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    10de:	e9 81       	ldd	r30, Y+1	; 0x01
    10e0:	fa 81       	ldd	r31, Y+2	; 0x02
    10e2:	8f ef       	ldi	r24, 0xFF	; 255
    10e4:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    10e6:	8d 81       	ldd	r24, Y+5	; 0x05
    10e8:	88 23       	and	r24, r24
    10ea:	79 f4       	brne	.+30     	; 0x110a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	80 85       	ldd	r24, Z+8	; 0x08
    10f2:	88 23       	and	r24, r24
    10f4:	a1 f0       	breq	.+40     	; 0x111e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10f6:	89 81       	ldd	r24, Y+1	; 0x01
    10f8:	9a 81       	ldd	r25, Y+2	; 0x02
    10fa:	08 96       	adiw	r24, 0x08	; 8
    10fc:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1100:	88 23       	and	r24, r24
    1102:	69 f0       	breq	.+26     	; 0x111e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1104:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1108:	0a c0       	rjmp	.+20     	; 0x111e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	08 96       	adiw	r24, 0x08	; 8
    1110:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	41 96       	adiw	r24, 0x11	; 17
    111a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1122:	81 e0       	ldi	r24, 0x01	; 1
}
    1124:	0f 90       	pop	r0
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	0f 90       	pop	r0
    112e:	cf 91       	pop	r28
    1130:	df 91       	pop	r29
    1132:	08 95       	ret

00001134 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	df 93       	push	r29
    113a:	cf 93       	push	r28
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
    1140:	29 97       	sbiw	r28, 0x09	; 9
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	8f 83       	std	Y+7, r24	; 0x07
    114e:	68 87       	std	Y+8, r22	; 0x08
    1150:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1152:	88 85       	ldd	r24, Y+8	; 0x08
    1154:	88 23       	and	r24, r24
    1156:	19 f4       	brne	.+6      	; 0x115e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1158:	1c 82       	std	Y+4, r1	; 0x04
    115a:	1b 82       	std	Y+3, r1	; 0x03
    115c:	10 c0       	rjmp	.+32     	; 0x117e <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    115e:	8f 81       	ldd	r24, Y+7	; 0x07
    1160:	28 2f       	mov	r18, r24
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	88 85       	ldd	r24, Y+8	; 0x08
    1166:	88 2f       	mov	r24, r24
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	ac 01       	movw	r20, r24
    116c:	24 9f       	mul	r18, r20
    116e:	c0 01       	movw	r24, r0
    1170:	25 9f       	mul	r18, r21
    1172:	90 0d       	add	r25, r0
    1174:	34 9f       	mul	r19, r20
    1176:	90 0d       	add	r25, r0
    1178:	11 24       	eor	r1, r1
    117a:	9c 83       	std	Y+4, r25	; 0x04
    117c:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	4f 96       	adiw	r24, 0x1f	; 31
    1184:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    1188:	9e 83       	std	Y+6, r25	; 0x06
    118a:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    118c:	8d 81       	ldd	r24, Y+5	; 0x05
    118e:	9e 81       	ldd	r25, Y+6	; 0x06
    1190:	00 97       	sbiw	r24, 0x00	; 0
    1192:	a1 f0       	breq	.+40     	; 0x11bc <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1194:	8d 81       	ldd	r24, Y+5	; 0x05
    1196:	9e 81       	ldd	r25, Y+6	; 0x06
    1198:	9a 83       	std	Y+2, r25	; 0x02
    119a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	4f 96       	adiw	r24, 0x1f	; 31
    11a2:	9a 83       	std	Y+2, r25	; 0x02
    11a4:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    11a6:	29 81       	ldd	r18, Y+1	; 0x01
    11a8:	3a 81       	ldd	r19, Y+2	; 0x02
    11aa:	ed 81       	ldd	r30, Y+5	; 0x05
    11ac:	fe 81       	ldd	r31, Y+6	; 0x06
    11ae:	8f 81       	ldd	r24, Y+7	; 0x07
    11b0:	68 85       	ldd	r22, Y+8	; 0x08
    11b2:	a9 01       	movw	r20, r18
    11b4:	29 85       	ldd	r18, Y+9	; 0x09
    11b6:	8f 01       	movw	r16, r30
    11b8:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    11bc:	8d 81       	ldd	r24, Y+5	; 0x05
    11be:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    11c0:	29 96       	adiw	r28, 0x09	; 9
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	0f be       	out	0x3f, r0	; 63
    11ca:	cd bf       	out	0x3d, r28	; 61
    11cc:	cf 91       	pop	r28
    11ce:	df 91       	pop	r29
    11d0:	1f 91       	pop	r17
    11d2:	0f 91       	pop	r16
    11d4:	08 95       	ret

000011d6 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	df 93       	push	r29
    11dc:	cf 93       	push	r28
    11de:	cd b7       	in	r28, 0x3d	; 61
    11e0:	de b7       	in	r29, 0x3e	; 62
    11e2:	27 97       	sbiw	r28, 0x07	; 7
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	de bf       	out	0x3e, r29	; 62
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	cd bf       	out	0x3d, r28	; 61
    11ee:	89 83       	std	Y+1, r24	; 0x01
    11f0:	6a 83       	std	Y+2, r22	; 0x02
    11f2:	5c 83       	std	Y+4, r21	; 0x04
    11f4:	4b 83       	std	Y+3, r20	; 0x03
    11f6:	2d 83       	std	Y+5, r18	; 0x05
    11f8:	1f 83       	std	Y+7, r17	; 0x07
    11fa:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	88 23       	and	r24, r24
    1200:	39 f4       	brne	.+14     	; 0x1210 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1202:	8e 81       	ldd	r24, Y+6	; 0x06
    1204:	9f 81       	ldd	r25, Y+7	; 0x07
    1206:	ee 81       	ldd	r30, Y+6	; 0x06
    1208:	ff 81       	ldd	r31, Y+7	; 0x07
    120a:	91 83       	std	Z+1, r25	; 0x01
    120c:	80 83       	st	Z, r24
    120e:	06 c0       	rjmp	.+12     	; 0x121c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	ee 81       	ldd	r30, Y+6	; 0x06
    1216:	ff 81       	ldd	r31, Y+7	; 0x07
    1218:	91 83       	std	Z+1, r25	; 0x01
    121a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    121c:	ee 81       	ldd	r30, Y+6	; 0x06
    121e:	ff 81       	ldd	r31, Y+7	; 0x07
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1224:	ee 81       	ldd	r30, Y+6	; 0x06
    1226:	ff 81       	ldd	r31, Y+7	; 0x07
    1228:	8a 81       	ldd	r24, Y+2	; 0x02
    122a:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    122c:	8e 81       	ldd	r24, Y+6	; 0x06
    122e:	9f 81       	ldd	r25, Y+7	; 0x07
    1230:	61 e0       	ldi	r22, 0x01	; 1
    1232:	0e 94 14 08 	call	0x1028	; 0x1028 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1236:	27 96       	adiw	r28, 0x07	; 7
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	08 95       	ret

0000124c <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    124c:	df 93       	push	r29
    124e:	cf 93       	push	r28
    1250:	00 d0       	rcall	.+0      	; 0x1252 <prvInitialiseMutex+0x6>
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	9a 83       	std	Y+2, r25	; 0x02
    1258:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    125a:	89 81       	ldd	r24, Y+1	; 0x01
    125c:	9a 81       	ldd	r25, Y+2	; 0x02
    125e:	00 97       	sbiw	r24, 0x00	; 0
    1260:	a1 f0       	breq	.+40     	; 0x128a <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    1262:	e9 81       	ldd	r30, Y+1	; 0x01
    1264:	fa 81       	ldd	r31, Y+2	; 0x02
    1266:	15 82       	std	Z+5, r1	; 0x05
    1268:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    126a:	e9 81       	ldd	r30, Y+1	; 0x01
    126c:	fa 81       	ldd	r31, Y+2	; 0x02
    126e:	11 82       	std	Z+1, r1	; 0x01
    1270:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1278:	89 81       	ldd	r24, Y+1	; 0x01
    127a:	9a 81       	ldd	r25, Y+2	; 0x02
    127c:	60 e0       	ldi	r22, 0x00	; 0
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	40 e0       	ldi	r20, 0x00	; 0
    1282:	50 e0       	ldi	r21, 0x00	; 0
    1284:	20 e0       	ldi	r18, 0x00	; 0
    1286:	0e 94 0b 0a 	call	0x1416	; 0x1416 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    128a:	0f 90       	pop	r0
    128c:	0f 90       	pop	r0
    128e:	cf 91       	pop	r28
    1290:	df 91       	pop	r29
    1292:	08 95       	ret

00001294 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1294:	df 93       	push	r29
    1296:	cf 93       	push	r28
    1298:	00 d0       	rcall	.+0      	; 0x129a <xQueueCreateMutex+0x6>
    129a:	00 d0       	rcall	.+0      	; 0x129c <xQueueCreateMutex+0x8>
    129c:	0f 92       	push	r0
    129e:	cd b7       	in	r28, 0x3d	; 61
    12a0:	de b7       	in	r29, 0x3e	; 62
    12a2:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	8a 83       	std	Y+2, r24	; 0x02
    12a8:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    12aa:	8a 81       	ldd	r24, Y+2	; 0x02
    12ac:	69 81       	ldd	r22, Y+1	; 0x01
    12ae:	4d 81       	ldd	r20, Y+5	; 0x05
    12b0:	0e 94 9a 08 	call	0x1134	; 0x1134 <xQueueGenericCreate>
    12b4:	9c 83       	std	Y+4, r25	; 0x04
    12b6:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    12b8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ba:	9c 81       	ldd	r25, Y+4	; 0x04
    12bc:	0e 94 26 09 	call	0x124c	; 0x124c <prvInitialiseMutex>

		return xNewQueue;
    12c0:	8b 81       	ldd	r24, Y+3	; 0x03
    12c2:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    12c4:	0f 90       	pop	r0
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	0f 90       	pop	r0
    12cc:	0f 90       	pop	r0
    12ce:	cf 91       	pop	r28
    12d0:	df 91       	pop	r29
    12d2:	08 95       	ret

000012d4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    12d4:	0f 93       	push	r16
    12d6:	1f 93       	push	r17
    12d8:	df 93       	push	r29
    12da:	cf 93       	push	r28
    12dc:	00 d0       	rcall	.+0      	; 0x12de <xQueueGiveMutexRecursive+0xa>
    12de:	00 d0       	rcall	.+0      	; 0x12e0 <xQueueGiveMutexRecursive+0xc>
    12e0:	0f 92       	push	r0
    12e2:	cd b7       	in	r28, 0x3d	; 61
    12e4:	de b7       	in	r29, 0x3e	; 62
    12e6:	9d 83       	std	Y+5, r25	; 0x05
    12e8:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    12ea:	8c 81       	ldd	r24, Y+4	; 0x04
    12ec:	9d 81       	ldd	r25, Y+5	; 0x05
    12ee:	9a 83       	std	Y+2, r25	; 0x02
    12f0:	89 83       	std	Y+1, r24	; 0x01
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    12f2:	e9 81       	ldd	r30, Y+1	; 0x01
    12f4:	fa 81       	ldd	r31, Y+2	; 0x02
    12f6:	04 81       	ldd	r16, Z+4	; 0x04
    12f8:	15 81       	ldd	r17, Z+5	; 0x05
    12fa:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <xTaskGetCurrentTaskHandle>
    12fe:	08 17       	cp	r16, r24
    1300:	19 07       	cpc	r17, r25
    1302:	c1 f4       	brne	.+48     	; 0x1334 <xQueueGiveMutexRecursive+0x60>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    1304:	e9 81       	ldd	r30, Y+1	; 0x01
    1306:	fa 81       	ldd	r31, Y+2	; 0x02
    1308:	86 81       	ldd	r24, Z+6	; 0x06
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	e9 81       	ldd	r30, Y+1	; 0x01
    130e:	fa 81       	ldd	r31, Y+2	; 0x02
    1310:	86 83       	std	Z+6, r24	; 0x06

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    1312:	e9 81       	ldd	r30, Y+1	; 0x01
    1314:	fa 81       	ldd	r31, Y+2	; 0x02
    1316:	86 81       	ldd	r24, Z+6	; 0x06
    1318:	88 23       	and	r24, r24
    131a:	49 f4       	brne	.+18     	; 0x132e <xQueueGiveMutexRecursive+0x5a>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    131c:	89 81       	ldd	r24, Y+1	; 0x01
    131e:	9a 81       	ldd	r25, Y+2	; 0x02
    1320:	60 e0       	ldi	r22, 0x00	; 0
    1322:	70 e0       	ldi	r23, 0x00	; 0
    1324:	40 e0       	ldi	r20, 0x00	; 0
    1326:	50 e0       	ldi	r21, 0x00	; 0
    1328:	20 e0       	ldi	r18, 0x00	; 0
    132a:	0e 94 0b 0a 	call	0x1416	; 0x1416 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	8b 83       	std	Y+3, r24	; 0x03
    1332:	01 c0       	rjmp	.+2      	; 0x1336 <xQueueGiveMutexRecursive+0x62>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    1334:	1b 82       	std	Y+3, r1	; 0x03

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    1336:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    1338:	0f 90       	pop	r0
    133a:	0f 90       	pop	r0
    133c:	0f 90       	pop	r0
    133e:	0f 90       	pop	r0
    1340:	0f 90       	pop	r0
    1342:	cf 91       	pop	r28
    1344:	df 91       	pop	r29
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	08 95       	ret

0000134c <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    134c:	0f 93       	push	r16
    134e:	1f 93       	push	r17
    1350:	df 93       	push	r29
    1352:	cf 93       	push	r28
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	27 97       	sbiw	r28, 0x07	; 7
    135a:	0f b6       	in	r0, 0x3f	; 63
    135c:	f8 94       	cli
    135e:	de bf       	out	0x3e, r29	; 62
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	cd bf       	out	0x3d, r28	; 61
    1364:	9d 83       	std	Y+5, r25	; 0x05
    1366:	8c 83       	std	Y+4, r24	; 0x04
    1368:	7f 83       	std	Y+7, r23	; 0x07
    136a:	6e 83       	std	Y+6, r22	; 0x06
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    136c:	8c 81       	ldd	r24, Y+4	; 0x04
    136e:	9d 81       	ldd	r25, Y+5	; 0x05
    1370:	9a 83       	std	Y+2, r25	; 0x02
    1372:	89 83       	std	Y+1, r24	; 0x01
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    1374:	e9 81       	ldd	r30, Y+1	; 0x01
    1376:	fa 81       	ldd	r31, Y+2	; 0x02
    1378:	04 81       	ldd	r16, Z+4	; 0x04
    137a:	15 81       	ldd	r17, Z+5	; 0x05
    137c:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <xTaskGetCurrentTaskHandle>
    1380:	08 17       	cp	r16, r24
    1382:	19 07       	cpc	r17, r25
    1384:	51 f4       	brne	.+20     	; 0x139a <xQueueTakeMutexRecursive+0x4e>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    1386:	e9 81       	ldd	r30, Y+1	; 0x01
    1388:	fa 81       	ldd	r31, Y+2	; 0x02
    138a:	86 81       	ldd	r24, Z+6	; 0x06
    138c:	8f 5f       	subi	r24, 0xFF	; 255
    138e:	e9 81       	ldd	r30, Y+1	; 0x01
    1390:	fa 81       	ldd	r31, Y+2	; 0x02
    1392:	86 83       	std	Z+6, r24	; 0x06
			xReturn = pdPASS;
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	8b 83       	std	Y+3, r24	; 0x03
    1398:	12 c0       	rjmp	.+36     	; 0x13be <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    139a:	89 81       	ldd	r24, Y+1	; 0x01
    139c:	9a 81       	ldd	r25, Y+2	; 0x02
    139e:	2e 81       	ldd	r18, Y+6	; 0x06
    13a0:	3f 81       	ldd	r19, Y+7	; 0x07
    13a2:	b9 01       	movw	r22, r18
    13a4:	0e 94 0b 0c 	call	0x1816	; 0x1816 <xQueueSemaphoreTake>
    13a8:	8b 83       	std	Y+3, r24	; 0x03

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	88 23       	and	r24, r24
    13ae:	39 f0       	breq	.+14     	; 0x13be <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	fa 81       	ldd	r31, Y+2	; 0x02
    13b4:	86 81       	ldd	r24, Z+6	; 0x06
    13b6:	8f 5f       	subi	r24, 0xFF	; 255
    13b8:	e9 81       	ldd	r30, Y+1	; 0x01
    13ba:	fa 81       	ldd	r31, Y+2	; 0x02
    13bc:	86 83       	std	Z+6, r24	; 0x06
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    13c0:	27 96       	adiw	r28, 0x07	; 7
    13c2:	0f b6       	in	r0, 0x3f	; 63
    13c4:	f8 94       	cli
    13c6:	de bf       	out	0x3e, r29	; 62
    13c8:	0f be       	out	0x3f, r0	; 63
    13ca:	cd bf       	out	0x3d, r28	; 61
    13cc:	cf 91       	pop	r28
    13ce:	df 91       	pop	r29
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	08 95       	ret

000013d6 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    13d6:	df 93       	push	r29
    13d8:	cf 93       	push	r28
    13da:	00 d0       	rcall	.+0      	; 0x13dc <xQueueCreateCountingSemaphore+0x6>
    13dc:	00 d0       	rcall	.+0      	; 0x13de <xQueueCreateCountingSemaphore+0x8>
    13de:	cd b7       	in	r28, 0x3d	; 61
    13e0:	de b7       	in	r29, 0x3e	; 62
    13e2:	8b 83       	std	Y+3, r24	; 0x03
    13e4:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    13e6:	8b 81       	ldd	r24, Y+3	; 0x03
    13e8:	60 e0       	ldi	r22, 0x00	; 0
    13ea:	42 e0       	ldi	r20, 0x02	; 2
    13ec:	0e 94 9a 08 	call	0x1134	; 0x1134 <xQueueGenericCreate>
    13f0:	9a 83       	std	Y+2, r25	; 0x02
    13f2:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	9a 81       	ldd	r25, Y+2	; 0x02
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	21 f0       	breq	.+8      	; 0x1404 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    13fc:	e9 81       	ldd	r30, Y+1	; 0x01
    13fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1400:	8c 81       	ldd	r24, Y+4	; 0x04
    1402:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    1404:	89 81       	ldd	r24, Y+1	; 0x01
    1406:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	0f 90       	pop	r0
    140e:	0f 90       	pop	r0
    1410:	cf 91       	pop	r28
    1412:	df 91       	pop	r29
    1414:	08 95       	ret

00001416 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1416:	df 93       	push	r29
    1418:	cf 93       	push	r28
    141a:	cd b7       	in	r28, 0x3d	; 61
    141c:	de b7       	in	r29, 0x3e	; 62
    141e:	2f 97       	sbiw	r28, 0x0f	; 15
    1420:	0f b6       	in	r0, 0x3f	; 63
    1422:	f8 94       	cli
    1424:	de bf       	out	0x3e, r29	; 62
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	cd bf       	out	0x3d, r28	; 61
    142a:	99 87       	std	Y+9, r25	; 0x09
    142c:	88 87       	std	Y+8, r24	; 0x08
    142e:	7b 87       	std	Y+11, r23	; 0x0b
    1430:	6a 87       	std	Y+10, r22	; 0x0a
    1432:	5d 87       	std	Y+13, r21	; 0x0d
    1434:	4c 87       	std	Y+12, r20	; 0x0c
    1436:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1438:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    143a:	88 85       	ldd	r24, Y+8	; 0x08
    143c:	99 85       	ldd	r25, Y+9	; 0x09
    143e:	9a 83       	std	Y+2, r25	; 0x02
    1440:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1448:	e9 81       	ldd	r30, Y+1	; 0x01
    144a:	fa 81       	ldd	r31, Y+2	; 0x02
    144c:	92 8d       	ldd	r25, Z+26	; 0x1a
    144e:	e9 81       	ldd	r30, Y+1	; 0x01
    1450:	fa 81       	ldd	r31, Y+2	; 0x02
    1452:	83 8d       	ldd	r24, Z+27	; 0x1b
    1454:	98 17       	cp	r25, r24
    1456:	18 f0       	brcs	.+6      	; 0x145e <xQueueGenericSend+0x48>
    1458:	8e 85       	ldd	r24, Y+14	; 0x0e
    145a:	82 30       	cpi	r24, 0x02	; 2
    145c:	11 f5       	brne	.+68     	; 0x14a2 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    145e:	89 81       	ldd	r24, Y+1	; 0x01
    1460:	9a 81       	ldd	r25, Y+2	; 0x02
    1462:	2a 85       	ldd	r18, Y+10	; 0x0a
    1464:	3b 85       	ldd	r19, Y+11	; 0x0b
    1466:	b9 01       	movw	r22, r18
    1468:	4e 85       	ldd	r20, Y+14	; 0x0e
    146a:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <prvCopyDataToQueue>
    146e:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1470:	e9 81       	ldd	r30, Y+1	; 0x01
    1472:	fa 81       	ldd	r31, Y+2	; 0x02
    1474:	81 89       	ldd	r24, Z+17	; 0x11
    1476:	88 23       	and	r24, r24
    1478:	51 f0       	breq	.+20     	; 0x148e <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    147a:	89 81       	ldd	r24, Y+1	; 0x01
    147c:	9a 81       	ldd	r25, Y+2	; 0x02
    147e:	41 96       	adiw	r24, 0x11	; 17
    1480:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1484:	88 23       	and	r24, r24
    1486:	41 f0       	breq	.+16     	; 0x1498 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1488:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    148c:	05 c0       	rjmp	.+10     	; 0x1498 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	88 23       	and	r24, r24
    1492:	11 f0       	breq	.+4      	; 0x1498 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1494:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    149c:	81 e0       	ldi	r24, 0x01	; 1
    149e:	8f 87       	std	Y+15, r24	; 0x0f
    14a0:	5c c0       	rjmp	.+184    	; 0x155a <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    14a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    14a6:	00 97       	sbiw	r24, 0x00	; 0
    14a8:	21 f4       	brne	.+8      	; 0x14b2 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14aa:	0f 90       	pop	r0
    14ac:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    14ae:	1f 86       	std	Y+15, r1	; 0x0f
    14b0:	54 c0       	rjmp	.+168    	; 0x155a <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    14b2:	8c 81       	ldd	r24, Y+4	; 0x04
    14b4:	88 23       	and	r24, r24
    14b6:	31 f4       	brne	.+12     	; 0x14c4 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    14b8:	ce 01       	movw	r24, r28
    14ba:	05 96       	adiw	r24, 0x05	; 5
    14bc:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14c4:	0f 90       	pop	r0
    14c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14c8:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14cc:	0f b6       	in	r0, 0x3f	; 63
    14ce:	f8 94       	cli
    14d0:	0f 92       	push	r0
    14d2:	e9 81       	ldd	r30, Y+1	; 0x01
    14d4:	fa 81       	ldd	r31, Y+2	; 0x02
    14d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14d8:	8f 3f       	cpi	r24, 0xFF	; 255
    14da:	19 f4       	brne	.+6      	; 0x14e2 <xQueueGenericSend+0xcc>
    14dc:	e9 81       	ldd	r30, Y+1	; 0x01
    14de:	fa 81       	ldd	r31, Y+2	; 0x02
    14e0:	15 8e       	std	Z+29, r1	; 0x1d
    14e2:	e9 81       	ldd	r30, Y+1	; 0x01
    14e4:	fa 81       	ldd	r31, Y+2	; 0x02
    14e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    14e8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ea:	19 f4       	brne	.+6      	; 0x14f2 <xQueueGenericSend+0xdc>
    14ec:	e9 81       	ldd	r30, Y+1	; 0x01
    14ee:	fa 81       	ldd	r31, Y+2	; 0x02
    14f0:	16 8e       	std	Z+30, r1	; 0x1e
    14f2:	0f 90       	pop	r0
    14f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14f6:	ce 01       	movw	r24, r28
    14f8:	05 96       	adiw	r24, 0x05	; 5
    14fa:	9e 01       	movw	r18, r28
    14fc:	24 5f       	subi	r18, 0xF4	; 244
    14fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1500:	b9 01       	movw	r22, r18
    1502:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <xTaskCheckForTimeOut>
    1506:	88 23       	and	r24, r24
    1508:	09 f5       	brne	.+66     	; 0x154c <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    150a:	89 81       	ldd	r24, Y+1	; 0x01
    150c:	9a 81       	ldd	r25, Y+2	; 0x02
    150e:	0e 94 3f 10 	call	0x207e	; 0x207e <prvIsQueueFull>
    1512:	88 23       	and	r24, r24
    1514:	a1 f0       	breq	.+40     	; 0x153e <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1516:	89 81       	ldd	r24, Y+1	; 0x01
    1518:	9a 81       	ldd	r25, Y+2	; 0x02
    151a:	08 96       	adiw	r24, 0x08	; 8
    151c:	2c 85       	ldd	r18, Y+12	; 0x0c
    151e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1520:	b9 01       	movw	r22, r18
    1522:	0e 94 55 1e 	call	0x3caa	; 0x3caa <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1526:	89 81       	ldd	r24, Y+1	; 0x01
    1528:	9a 81       	ldd	r25, Y+2	; 0x02
    152a:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    152e:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    1532:	88 23       	and	r24, r24
    1534:	09 f0       	breq	.+2      	; 0x1538 <xQueueGenericSend+0x122>
    1536:	85 cf       	rjmp	.-246    	; 0x1442 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1538:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    153c:	82 cf       	rjmp	.-252    	; 0x1442 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	9a 81       	ldd	r25, Y+2	; 0x02
    1542:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1546:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    154a:	7b cf       	rjmp	.-266    	; 0x1442 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1554:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1558:	1f 86       	std	Y+15, r1	; 0x0f
    155a:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    155c:	2f 96       	adiw	r28, 0x0f	; 15
    155e:	0f b6       	in	r0, 0x3f	; 63
    1560:	f8 94       	cli
    1562:	de bf       	out	0x3e, r29	; 62
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	cd bf       	out	0x3d, r28	; 61
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	08 95       	ret

0000156e <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    156e:	df 93       	push	r29
    1570:	cf 93       	push	r28
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
    1576:	2c 97       	sbiw	r28, 0x0c	; 12
    1578:	0f b6       	in	r0, 0x3f	; 63
    157a:	f8 94       	cli
    157c:	de bf       	out	0x3e, r29	; 62
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	cd bf       	out	0x3d, r28	; 61
    1582:	9f 83       	std	Y+7, r25	; 0x07
    1584:	8e 83       	std	Y+6, r24	; 0x06
    1586:	79 87       	std	Y+9, r23	; 0x09
    1588:	68 87       	std	Y+8, r22	; 0x08
    158a:	5b 87       	std	Y+11, r21	; 0x0b
    158c:	4a 87       	std	Y+10, r20	; 0x0a
    158e:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1590:	8e 81       	ldd	r24, Y+6	; 0x06
    1592:	9f 81       	ldd	r25, Y+7	; 0x07
    1594:	9b 83       	std	Y+3, r25	; 0x03
    1596:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1598:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    159a:	ea 81       	ldd	r30, Y+2	; 0x02
    159c:	fb 81       	ldd	r31, Y+3	; 0x03
    159e:	92 8d       	ldd	r25, Z+26	; 0x1a
    15a0:	ea 81       	ldd	r30, Y+2	; 0x02
    15a2:	fb 81       	ldd	r31, Y+3	; 0x03
    15a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    15a6:	98 17       	cp	r25, r24
    15a8:	18 f0       	brcs	.+6      	; 0x15b0 <xQueueGenericSendFromISR+0x42>
    15aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    15ac:	82 30       	cpi	r24, 0x02	; 2
    15ae:	61 f5       	brne	.+88     	; 0x1608 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15b0:	ea 81       	ldd	r30, Y+2	; 0x02
    15b2:	fb 81       	ldd	r31, Y+3	; 0x03
    15b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    15b6:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15b8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ba:	9b 81       	ldd	r25, Y+3	; 0x03
    15bc:	28 85       	ldd	r18, Y+8	; 0x08
    15be:	39 85       	ldd	r19, Y+9	; 0x09
    15c0:	b9 01       	movw	r22, r18
    15c2:	4c 85       	ldd	r20, Y+12	; 0x0c
    15c4:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15c8:	89 81       	ldd	r24, Y+1	; 0x01
    15ca:	8f 3f       	cpi	r24, 0xFF	; 255
    15cc:	a9 f4       	brne	.+42     	; 0x15f8 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15ce:	ea 81       	ldd	r30, Y+2	; 0x02
    15d0:	fb 81       	ldd	r31, Y+3	; 0x03
    15d2:	81 89       	ldd	r24, Z+17	; 0x11
    15d4:	88 23       	and	r24, r24
    15d6:	a9 f0       	breq	.+42     	; 0x1602 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15d8:	8a 81       	ldd	r24, Y+2	; 0x02
    15da:	9b 81       	ldd	r25, Y+3	; 0x03
    15dc:	41 96       	adiw	r24, 0x11	; 17
    15de:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    15e2:	88 23       	and	r24, r24
    15e4:	71 f0       	breq	.+28     	; 0x1602 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    15e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    15ea:	00 97       	sbiw	r24, 0x00	; 0
    15ec:	51 f0       	breq	.+20     	; 0x1602 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    15f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    15f2:	81 e0       	ldi	r24, 0x01	; 1
    15f4:	80 83       	st	Z, r24
    15f6:	05 c0       	rjmp	.+10     	; 0x1602 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15f8:	89 81       	ldd	r24, Y+1	; 0x01
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	ea 81       	ldd	r30, Y+2	; 0x02
    15fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1600:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	8d 83       	std	Y+5, r24	; 0x05
    1606:	01 c0       	rjmp	.+2      	; 0x160a <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1608:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    160a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    160c:	2c 96       	adiw	r28, 0x0c	; 12
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	de bf       	out	0x3e, r29	; 62
    1614:	0f be       	out	0x3f, r0	; 63
    1616:	cd bf       	out	0x3d, r28	; 61
    1618:	cf 91       	pop	r28
    161a:	df 91       	pop	r29
    161c:	08 95       	ret

0000161e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    161e:	df 93       	push	r29
    1620:	cf 93       	push	r28
    1622:	cd b7       	in	r28, 0x3d	; 61
    1624:	de b7       	in	r29, 0x3e	; 62
    1626:	2a 97       	sbiw	r28, 0x0a	; 10
    1628:	0f b6       	in	r0, 0x3f	; 63
    162a:	f8 94       	cli
    162c:	de bf       	out	0x3e, r29	; 62
    162e:	0f be       	out	0x3f, r0	; 63
    1630:	cd bf       	out	0x3d, r28	; 61
    1632:	98 87       	std	Y+8, r25	; 0x08
    1634:	8f 83       	std	Y+7, r24	; 0x07
    1636:	7a 87       	std	Y+10, r23	; 0x0a
    1638:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    163a:	8f 81       	ldd	r24, Y+7	; 0x07
    163c:	98 85       	ldd	r25, Y+8	; 0x08
    163e:	9c 83       	std	Y+4, r25	; 0x04
    1640:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1642:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1644:	eb 81       	ldd	r30, Y+3	; 0x03
    1646:	fc 81       	ldd	r31, Y+4	; 0x04
    1648:	82 8d       	ldd	r24, Z+26	; 0x1a
    164a:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    164c:	eb 81       	ldd	r30, Y+3	; 0x03
    164e:	fc 81       	ldd	r31, Y+4	; 0x04
    1650:	93 8d       	ldd	r25, Z+27	; 0x1b
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	89 17       	cp	r24, r25
    1656:	48 f5       	brcc	.+82     	; 0x16aa <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1658:	eb 81       	ldd	r30, Y+3	; 0x03
    165a:	fc 81       	ldd	r31, Y+4	; 0x04
    165c:	86 8d       	ldd	r24, Z+30	; 0x1e
    165e:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1660:	8a 81       	ldd	r24, Y+2	; 0x02
    1662:	8f 5f       	subi	r24, 0xFF	; 255
    1664:	eb 81       	ldd	r30, Y+3	; 0x03
    1666:	fc 81       	ldd	r31, Y+4	; 0x04
    1668:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    166a:	89 81       	ldd	r24, Y+1	; 0x01
    166c:	8f 3f       	cpi	r24, 0xFF	; 255
    166e:	a9 f4       	brne	.+42     	; 0x169a <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1670:	eb 81       	ldd	r30, Y+3	; 0x03
    1672:	fc 81       	ldd	r31, Y+4	; 0x04
    1674:	81 89       	ldd	r24, Z+17	; 0x11
    1676:	88 23       	and	r24, r24
    1678:	a9 f0       	breq	.+42     	; 0x16a4 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    167a:	8b 81       	ldd	r24, Y+3	; 0x03
    167c:	9c 81       	ldd	r25, Y+4	; 0x04
    167e:	41 96       	adiw	r24, 0x11	; 17
    1680:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1684:	88 23       	and	r24, r24
    1686:	71 f0       	breq	.+28     	; 0x16a4 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1688:	89 85       	ldd	r24, Y+9	; 0x09
    168a:	9a 85       	ldd	r25, Y+10	; 0x0a
    168c:	00 97       	sbiw	r24, 0x00	; 0
    168e:	51 f0       	breq	.+20     	; 0x16a4 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1690:	e9 85       	ldd	r30, Y+9	; 0x09
    1692:	fa 85       	ldd	r31, Y+10	; 0x0a
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	80 83       	st	Z, r24
    1698:	05 c0       	rjmp	.+10     	; 0x16a4 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    169a:	89 81       	ldd	r24, Y+1	; 0x01
    169c:	8f 5f       	subi	r24, 0xFF	; 255
    169e:	eb 81       	ldd	r30, Y+3	; 0x03
    16a0:	fc 81       	ldd	r31, Y+4	; 0x04
    16a2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	8e 83       	std	Y+6, r24	; 0x06
    16a8:	01 c0       	rjmp	.+2      	; 0x16ac <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    16aa:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    16ac:	8e 81       	ldd	r24, Y+6	; 0x06
}
    16ae:	2a 96       	adiw	r28, 0x0a	; 10
    16b0:	0f b6       	in	r0, 0x3f	; 63
    16b2:	f8 94       	cli
    16b4:	de bf       	out	0x3e, r29	; 62
    16b6:	0f be       	out	0x3f, r0	; 63
    16b8:	cd bf       	out	0x3d, r28	; 61
    16ba:	cf 91       	pop	r28
    16bc:	df 91       	pop	r29
    16be:	08 95       	ret

000016c0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    16c0:	df 93       	push	r29
    16c2:	cf 93       	push	r28
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	2e 97       	sbiw	r28, 0x0e	; 14
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	99 87       	std	Y+9, r25	; 0x09
    16d6:	88 87       	std	Y+8, r24	; 0x08
    16d8:	7b 87       	std	Y+11, r23	; 0x0b
    16da:	6a 87       	std	Y+10, r22	; 0x0a
    16dc:	5d 87       	std	Y+13, r21	; 0x0d
    16de:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    16e0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    16e2:	88 85       	ldd	r24, Y+8	; 0x08
    16e4:	99 85       	ldd	r25, Y+9	; 0x09
    16e6:	9b 83       	std	Y+3, r25	; 0x03
    16e8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16f0:	ea 81       	ldd	r30, Y+2	; 0x02
    16f2:	fb 81       	ldd	r31, Y+3	; 0x03
    16f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    16f6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16f8:	89 81       	ldd	r24, Y+1	; 0x01
    16fa:	88 23       	and	r24, r24
    16fc:	f9 f0       	breq	.+62     	; 0x173c <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    16fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1700:	9b 81       	ldd	r25, Y+3	; 0x03
    1702:	2a 85       	ldd	r18, Y+10	; 0x0a
    1704:	3b 85       	ldd	r19, Y+11	; 0x0b
    1706:	b9 01       	movw	r22, r18
    1708:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    170c:	89 81       	ldd	r24, Y+1	; 0x01
    170e:	81 50       	subi	r24, 0x01	; 1
    1710:	ea 81       	ldd	r30, Y+2	; 0x02
    1712:	fb 81       	ldd	r31, Y+3	; 0x03
    1714:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1716:	ea 81       	ldd	r30, Y+2	; 0x02
    1718:	fb 81       	ldd	r31, Y+3	; 0x03
    171a:	80 85       	ldd	r24, Z+8	; 0x08
    171c:	88 23       	and	r24, r24
    171e:	49 f0       	breq	.+18     	; 0x1732 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1720:	8a 81       	ldd	r24, Y+2	; 0x02
    1722:	9b 81       	ldd	r25, Y+3	; 0x03
    1724:	08 96       	adiw	r24, 0x08	; 8
    1726:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    172a:	88 23       	and	r24, r24
    172c:	11 f0       	breq	.+4      	; 0x1732 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    172e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1732:	0f 90       	pop	r0
    1734:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	8e 87       	std	Y+14, r24	; 0x0e
    173a:	63 c0       	rjmp	.+198    	; 0x1802 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    173c:	8c 85       	ldd	r24, Y+12	; 0x0c
    173e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1740:	00 97       	sbiw	r24, 0x00	; 0
    1742:	21 f4       	brne	.+8      	; 0x174c <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1744:	0f 90       	pop	r0
    1746:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1748:	1e 86       	std	Y+14, r1	; 0x0e
    174a:	5b c0       	rjmp	.+182    	; 0x1802 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    174c:	8c 81       	ldd	r24, Y+4	; 0x04
    174e:	88 23       	and	r24, r24
    1750:	31 f4       	brne	.+12     	; 0x175e <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1752:	ce 01       	movw	r24, r28
    1754:	05 96       	adiw	r24, 0x05	; 5
    1756:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    175e:	0f 90       	pop	r0
    1760:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1762:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	0f 92       	push	r0
    176c:	ea 81       	ldd	r30, Y+2	; 0x02
    176e:	fb 81       	ldd	r31, Y+3	; 0x03
    1770:	85 8d       	ldd	r24, Z+29	; 0x1d
    1772:	8f 3f       	cpi	r24, 0xFF	; 255
    1774:	19 f4       	brne	.+6      	; 0x177c <xQueueReceive+0xbc>
    1776:	ea 81       	ldd	r30, Y+2	; 0x02
    1778:	fb 81       	ldd	r31, Y+3	; 0x03
    177a:	15 8e       	std	Z+29, r1	; 0x1d
    177c:	ea 81       	ldd	r30, Y+2	; 0x02
    177e:	fb 81       	ldd	r31, Y+3	; 0x03
    1780:	86 8d       	ldd	r24, Z+30	; 0x1e
    1782:	8f 3f       	cpi	r24, 0xFF	; 255
    1784:	19 f4       	brne	.+6      	; 0x178c <xQueueReceive+0xcc>
    1786:	ea 81       	ldd	r30, Y+2	; 0x02
    1788:	fb 81       	ldd	r31, Y+3	; 0x03
    178a:	16 8e       	std	Z+30, r1	; 0x1e
    178c:	0f 90       	pop	r0
    178e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1790:	ce 01       	movw	r24, r28
    1792:	05 96       	adiw	r24, 0x05	; 5
    1794:	9e 01       	movw	r18, r28
    1796:	24 5f       	subi	r18, 0xF4	; 244
    1798:	3f 4f       	sbci	r19, 0xFF	; 255
    179a:	b9 01       	movw	r22, r18
    179c:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <xTaskCheckForTimeOut>
    17a0:	88 23       	and	r24, r24
    17a2:	09 f5       	brne	.+66     	; 0x17e6 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17a4:	8a 81       	ldd	r24, Y+2	; 0x02
    17a6:	9b 81       	ldd	r25, Y+3	; 0x03
    17a8:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    17ac:	88 23       	and	r24, r24
    17ae:	a1 f0       	breq	.+40     	; 0x17d8 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17b0:	8a 81       	ldd	r24, Y+2	; 0x02
    17b2:	9b 81       	ldd	r25, Y+3	; 0x03
    17b4:	41 96       	adiw	r24, 0x11	; 17
    17b6:	2c 85       	ldd	r18, Y+12	; 0x0c
    17b8:	3d 85       	ldd	r19, Y+13	; 0x0d
    17ba:	b9 01       	movw	r22, r18
    17bc:	0e 94 55 1e 	call	0x3caa	; 0x3caa <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17c0:	8a 81       	ldd	r24, Y+2	; 0x02
    17c2:	9b 81       	ldd	r25, Y+3	; 0x03
    17c4:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17c8:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    17cc:	88 23       	and	r24, r24
    17ce:	09 f0       	breq	.+2      	; 0x17d2 <xQueueReceive+0x112>
    17d0:	8c cf       	rjmp	.-232    	; 0x16ea <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    17d2:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    17d6:	89 cf       	rjmp	.-238    	; 0x16ea <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    17d8:	8a 81       	ldd	r24, Y+2	; 0x02
    17da:	9b 81       	ldd	r25, Y+3	; 0x03
    17dc:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17e0:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    17e4:	82 cf       	rjmp	.-252    	; 0x16ea <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    17e6:	8a 81       	ldd	r24, Y+2	; 0x02
    17e8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ea:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17ee:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17f2:	8a 81       	ldd	r24, Y+2	; 0x02
    17f4:	9b 81       	ldd	r25, Y+3	; 0x03
    17f6:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    17fa:	88 23       	and	r24, r24
    17fc:	09 f4       	brne	.+2      	; 0x1800 <xQueueReceive+0x140>
    17fe:	75 cf       	rjmp	.-278    	; 0x16ea <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1800:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1802:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1804:	2e 96       	adiw	r28, 0x0e	; 14
    1806:	0f b6       	in	r0, 0x3f	; 63
    1808:	f8 94       	cli
    180a:	de bf       	out	0x3e, r29	; 62
    180c:	0f be       	out	0x3f, r0	; 63
    180e:	cd bf       	out	0x3d, r28	; 61
    1810:	cf 91       	pop	r28
    1812:	df 91       	pop	r29
    1814:	08 95       	ret

00001816 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1816:	df 93       	push	r29
    1818:	cf 93       	push	r28
    181a:	cd b7       	in	r28, 0x3d	; 61
    181c:	de b7       	in	r29, 0x3e	; 62
    181e:	2e 97       	sbiw	r28, 0x0e	; 14
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	de bf       	out	0x3e, r29	; 62
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	cd bf       	out	0x3d, r28	; 61
    182a:	9b 87       	std	Y+11, r25	; 0x0b
    182c:	8a 87       	std	Y+10, r24	; 0x0a
    182e:	7d 87       	std	Y+13, r23	; 0x0d
    1830:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1832:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1834:	8a 85       	ldd	r24, Y+10	; 0x0a
    1836:	9b 85       	ldd	r25, Y+11	; 0x0b
    1838:	9d 83       	std	Y+5, r25	; 0x05
    183a:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    183c:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    183e:	0f b6       	in	r0, 0x3f	; 63
    1840:	f8 94       	cli
    1842:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1844:	ec 81       	ldd	r30, Y+4	; 0x04
    1846:	fd 81       	ldd	r31, Y+5	; 0x05
    1848:	82 8d       	ldd	r24, Z+26	; 0x1a
    184a:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    184c:	8a 81       	ldd	r24, Y+2	; 0x02
    184e:	88 23       	and	r24, r24
    1850:	21 f1       	breq	.+72     	; 0x189a <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1852:	8a 81       	ldd	r24, Y+2	; 0x02
    1854:	81 50       	subi	r24, 0x01	; 1
    1856:	ec 81       	ldd	r30, Y+4	; 0x04
    1858:	fd 81       	ldd	r31, Y+5	; 0x05
    185a:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    185c:	ec 81       	ldd	r30, Y+4	; 0x04
    185e:	fd 81       	ldd	r31, Y+5	; 0x05
    1860:	80 81       	ld	r24, Z
    1862:	91 81       	ldd	r25, Z+1	; 0x01
    1864:	00 97       	sbiw	r24, 0x00	; 0
    1866:	31 f4       	brne	.+12     	; 0x1874 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    1868:	0e 94 b6 22 	call	0x456c	; 0x456c <pvTaskIncrementMutexHeldCount>
    186c:	ec 81       	ldd	r30, Y+4	; 0x04
    186e:	fd 81       	ldd	r31, Y+5	; 0x05
    1870:	95 83       	std	Z+5, r25	; 0x05
    1872:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1874:	ec 81       	ldd	r30, Y+4	; 0x04
    1876:	fd 81       	ldd	r31, Y+5	; 0x05
    1878:	80 85       	ldd	r24, Z+8	; 0x08
    187a:	88 23       	and	r24, r24
    187c:	49 f0       	breq	.+18     	; 0x1890 <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    187e:	8c 81       	ldd	r24, Y+4	; 0x04
    1880:	9d 81       	ldd	r25, Y+5	; 0x05
    1882:	08 96       	adiw	r24, 0x08	; 8
    1884:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1888:	88 23       	and	r24, r24
    188a:	11 f0       	breq	.+4      	; 0x1890 <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    188c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1890:	0f 90       	pop	r0
    1892:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	8e 87       	std	Y+14, r24	; 0x0e
    1898:	89 c0       	rjmp	.+274    	; 0x19ac <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    189a:	8c 85       	ldd	r24, Y+12	; 0x0c
    189c:	9d 85       	ldd	r25, Y+13	; 0x0d
    189e:	00 97       	sbiw	r24, 0x00	; 0
    18a0:	21 f4       	brne	.+8      	; 0x18aa <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    18a2:	0f 90       	pop	r0
    18a4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    18a6:	1e 86       	std	Y+14, r1	; 0x0e
    18a8:	81 c0       	rjmp	.+258    	; 0x19ac <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    18aa:	8e 81       	ldd	r24, Y+6	; 0x06
    18ac:	88 23       	and	r24, r24
    18ae:	31 f4       	brne	.+12     	; 0x18bc <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    18b0:	ce 01       	movw	r24, r28
    18b2:	07 96       	adiw	r24, 0x07	; 7
    18b4:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    18c0:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18c4:	0f b6       	in	r0, 0x3f	; 63
    18c6:	f8 94       	cli
    18c8:	0f 92       	push	r0
    18ca:	ec 81       	ldd	r30, Y+4	; 0x04
    18cc:	fd 81       	ldd	r31, Y+5	; 0x05
    18ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    18d0:	8f 3f       	cpi	r24, 0xFF	; 255
    18d2:	19 f4       	brne	.+6      	; 0x18da <xQueueSemaphoreTake+0xc4>
    18d4:	ec 81       	ldd	r30, Y+4	; 0x04
    18d6:	fd 81       	ldd	r31, Y+5	; 0x05
    18d8:	15 8e       	std	Z+29, r1	; 0x1d
    18da:	ec 81       	ldd	r30, Y+4	; 0x04
    18dc:	fd 81       	ldd	r31, Y+5	; 0x05
    18de:	86 8d       	ldd	r24, Z+30	; 0x1e
    18e0:	8f 3f       	cpi	r24, 0xFF	; 255
    18e2:	19 f4       	brne	.+6      	; 0x18ea <xQueueSemaphoreTake+0xd4>
    18e4:	ec 81       	ldd	r30, Y+4	; 0x04
    18e6:	fd 81       	ldd	r31, Y+5	; 0x05
    18e8:	16 8e       	std	Z+30, r1	; 0x1e
    18ea:	0f 90       	pop	r0
    18ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18ee:	ce 01       	movw	r24, r28
    18f0:	07 96       	adiw	r24, 0x07	; 7
    18f2:	9e 01       	movw	r18, r28
    18f4:	24 5f       	subi	r18, 0xF4	; 244
    18f6:	3f 4f       	sbci	r19, 0xFF	; 255
    18f8:	b9 01       	movw	r22, r18
    18fa:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <xTaskCheckForTimeOut>
    18fe:	88 23       	and	r24, r24
    1900:	99 f5       	brne	.+102    	; 0x1968 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1902:	8c 81       	ldd	r24, Y+4	; 0x04
    1904:	9d 81       	ldd	r25, Y+5	; 0x05
    1906:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    190a:	88 23       	and	r24, r24
    190c:	31 f1       	breq	.+76     	; 0x195a <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    190e:	ec 81       	ldd	r30, Y+4	; 0x04
    1910:	fd 81       	ldd	r31, Y+5	; 0x05
    1912:	80 81       	ld	r24, Z
    1914:	91 81       	ldd	r25, Z+1	; 0x01
    1916:	00 97       	sbiw	r24, 0x00	; 0
    1918:	61 f4       	brne	.+24     	; 0x1932 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1920:	ec 81       	ldd	r30, Y+4	; 0x04
    1922:	fd 81       	ldd	r31, Y+5	; 0x05
    1924:	84 81       	ldd	r24, Z+4	; 0x04
    1926:	95 81       	ldd	r25, Z+5	; 0x05
    1928:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskPriorityInherit>
    192c:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    192e:	0f 90       	pop	r0
    1930:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1932:	8c 81       	ldd	r24, Y+4	; 0x04
    1934:	9d 81       	ldd	r25, Y+5	; 0x05
    1936:	41 96       	adiw	r24, 0x11	; 17
    1938:	2c 85       	ldd	r18, Y+12	; 0x0c
    193a:	3d 85       	ldd	r19, Y+13	; 0x0d
    193c:	b9 01       	movw	r22, r18
    193e:	0e 94 55 1e 	call	0x3caa	; 0x3caa <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1942:	8c 81       	ldd	r24, Y+4	; 0x04
    1944:	9d 81       	ldd	r25, Y+5	; 0x05
    1946:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    194a:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    194e:	88 23       	and	r24, r24
    1950:	09 f0       	breq	.+2      	; 0x1954 <xQueueSemaphoreTake+0x13e>
    1952:	75 cf       	rjmp	.-278    	; 0x183e <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    1954:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1958:	72 cf       	rjmp	.-284    	; 0x183e <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    195a:	8c 81       	ldd	r24, Y+4	; 0x04
    195c:	9d 81       	ldd	r25, Y+5	; 0x05
    195e:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1962:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    1966:	6b cf       	rjmp	.-298    	; 0x183e <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1968:	8c 81       	ldd	r24, Y+4	; 0x04
    196a:	9d 81       	ldd	r25, Y+5	; 0x05
    196c:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1970:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1974:	8c 81       	ldd	r24, Y+4	; 0x04
    1976:	9d 81       	ldd	r25, Y+5	; 0x05
    1978:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    197c:	88 23       	and	r24, r24
    197e:	09 f4       	brne	.+2      	; 0x1982 <xQueueSemaphoreTake+0x16c>
    1980:	5e cf       	rjmp	.-324    	; 0x183e <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	88 23       	and	r24, r24
    1986:	89 f0       	breq	.+34     	; 0x19aa <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    198e:	8c 81       	ldd	r24, Y+4	; 0x04
    1990:	9d 81       	ldd	r25, Y+5	; 0x05
    1992:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <prvGetDisinheritPriorityAfterTimeout>
    1996:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1998:	ec 81       	ldd	r30, Y+4	; 0x04
    199a:	fd 81       	ldd	r31, Y+5	; 0x05
    199c:	84 81       	ldd	r24, Z+4	; 0x04
    199e:	95 81       	ldd	r25, Z+5	; 0x05
    19a0:	69 81       	ldd	r22, Y+1	; 0x01
    19a2:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    19a6:	0f 90       	pop	r0
    19a8:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19aa:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    19ac:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    19ae:	2e 96       	adiw	r28, 0x0e	; 14
    19b0:	0f b6       	in	r0, 0x3f	; 63
    19b2:	f8 94       	cli
    19b4:	de bf       	out	0x3e, r29	; 62
    19b6:	0f be       	out	0x3f, r0	; 63
    19b8:	cd bf       	out	0x3d, r28	; 61
    19ba:	cf 91       	pop	r28
    19bc:	df 91       	pop	r29
    19be:	08 95       	ret

000019c0 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    19c0:	df 93       	push	r29
    19c2:	cf 93       	push	r28
    19c4:	cd b7       	in	r28, 0x3d	; 61
    19c6:	de b7       	in	r29, 0x3e	; 62
    19c8:	60 97       	sbiw	r28, 0x10	; 16
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	de bf       	out	0x3e, r29	; 62
    19d0:	0f be       	out	0x3f, r0	; 63
    19d2:	cd bf       	out	0x3d, r28	; 61
    19d4:	9b 87       	std	Y+11, r25	; 0x0b
    19d6:	8a 87       	std	Y+10, r24	; 0x0a
    19d8:	7d 87       	std	Y+13, r23	; 0x0d
    19da:	6c 87       	std	Y+12, r22	; 0x0c
    19dc:	5f 87       	std	Y+15, r21	; 0x0f
    19de:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    19e0:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    19e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    19e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    19e6:	9b 83       	std	Y+3, r25	; 0x03
    19e8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	f8 94       	cli
    19ee:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19f0:	ea 81       	ldd	r30, Y+2	; 0x02
    19f2:	fb 81       	ldd	r31, Y+3	; 0x03
    19f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    19f6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	88 23       	and	r24, r24
    19fc:	31 f1       	breq	.+76     	; 0x1a4a <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1a00:	fb 81       	ldd	r31, Y+3	; 0x03
    1a02:	86 81       	ldd	r24, Z+6	; 0x06
    1a04:	97 81       	ldd	r25, Z+7	; 0x07
    1a06:	9d 83       	std	Y+5, r25	; 0x05
    1a08:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a0e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1a10:	3d 85       	ldd	r19, Y+13	; 0x0d
    1a12:	b9 01       	movw	r22, r18
    1a14:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a18:	ea 81       	ldd	r30, Y+2	; 0x02
    1a1a:	fb 81       	ldd	r31, Y+3	; 0x03
    1a1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a20:	97 83       	std	Z+7, r25	; 0x07
    1a22:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a24:	ea 81       	ldd	r30, Y+2	; 0x02
    1a26:	fb 81       	ldd	r31, Y+3	; 0x03
    1a28:	81 89       	ldd	r24, Z+17	; 0x11
    1a2a:	88 23       	and	r24, r24
    1a2c:	49 f0       	breq	.+18     	; 0x1a40 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a30:	9b 81       	ldd	r25, Y+3	; 0x03
    1a32:	41 96       	adiw	r24, 0x11	; 17
    1a34:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1a38:	88 23       	and	r24, r24
    1a3a:	11 f0       	breq	.+4      	; 0x1a40 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1a3c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1a40:	0f 90       	pop	r0
    1a42:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	88 8b       	std	Y+16, r24	; 0x10
    1a48:	63 c0       	rjmp	.+198    	; 0x1b10 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a4a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a4c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	21 f4       	brne	.+8      	; 0x1a5a <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a56:	18 8a       	std	Y+16, r1	; 0x10
    1a58:	5b c0       	rjmp	.+182    	; 0x1b10 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a5a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a5c:	88 23       	and	r24, r24
    1a5e:	31 f4       	brne	.+12     	; 0x1a6c <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a60:	ce 01       	movw	r24, r28
    1a62:	07 96       	adiw	r24, 0x07	; 7
    1a64:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a6c:	0f 90       	pop	r0
    1a6e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a70:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	f8 94       	cli
    1a78:	0f 92       	push	r0
    1a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1a7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a80:	8f 3f       	cpi	r24, 0xFF	; 255
    1a82:	19 f4       	brne	.+6      	; 0x1a8a <xQueuePeek+0xca>
    1a84:	ea 81       	ldd	r30, Y+2	; 0x02
    1a86:	fb 81       	ldd	r31, Y+3	; 0x03
    1a88:	15 8e       	std	Z+29, r1	; 0x1d
    1a8a:	ea 81       	ldd	r30, Y+2	; 0x02
    1a8c:	fb 81       	ldd	r31, Y+3	; 0x03
    1a8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a90:	8f 3f       	cpi	r24, 0xFF	; 255
    1a92:	19 f4       	brne	.+6      	; 0x1a9a <xQueuePeek+0xda>
    1a94:	ea 81       	ldd	r30, Y+2	; 0x02
    1a96:	fb 81       	ldd	r31, Y+3	; 0x03
    1a98:	16 8e       	std	Z+30, r1	; 0x1e
    1a9a:	0f 90       	pop	r0
    1a9c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a9e:	ce 01       	movw	r24, r28
    1aa0:	07 96       	adiw	r24, 0x07	; 7
    1aa2:	9e 01       	movw	r18, r28
    1aa4:	22 5f       	subi	r18, 0xF2	; 242
    1aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa8:	b9 01       	movw	r22, r18
    1aaa:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <xTaskCheckForTimeOut>
    1aae:	88 23       	and	r24, r24
    1ab0:	09 f5       	brne	.+66     	; 0x1af4 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab6:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    1aba:	88 23       	and	r24, r24
    1abc:	a1 f0       	breq	.+40     	; 0x1ae6 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1abe:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ac2:	41 96       	adiw	r24, 0x11	; 17
    1ac4:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ac6:	3f 85       	ldd	r19, Y+15	; 0x0f
    1ac8:	b9 01       	movw	r22, r18
    1aca:	0e 94 55 1e 	call	0x3caa	; 0x3caa <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ace:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad2:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ad6:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    1ada:	88 23       	and	r24, r24
    1adc:	09 f0       	breq	.+2      	; 0x1ae0 <xQueuePeek+0x120>
    1ade:	85 cf       	rjmp	.-246    	; 0x19ea <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    1ae0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1ae4:	82 cf       	rjmp	.-252    	; 0x19ea <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aea:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1aee:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    1af2:	7b cf       	rjmp	.-266    	; 0x19ea <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1af4:	8a 81       	ldd	r24, Y+2	; 0x02
    1af6:	9b 81       	ldd	r25, Y+3	; 0x03
    1af8:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1afc:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b00:	8a 81       	ldd	r24, Y+2	; 0x02
    1b02:	9b 81       	ldd	r25, Y+3	; 0x03
    1b04:	0e 94 03 10 	call	0x2006	; 0x2006 <prvIsQueueEmpty>
    1b08:	88 23       	and	r24, r24
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <xQueuePeek+0x14e>
    1b0c:	6e cf       	rjmp	.-292    	; 0x19ea <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1b0e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1b10:	88 89       	ldd	r24, Y+16	; 0x10
}
    1b12:	60 96       	adiw	r28, 0x10	; 16
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	cf 91       	pop	r28
    1b20:	df 91       	pop	r29
    1b22:	08 95       	ret

00001b24 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1b24:	df 93       	push	r29
    1b26:	cf 93       	push	r28
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	2c 97       	sbiw	r28, 0x0c	; 12
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	de bf       	out	0x3e, r29	; 62
    1b34:	0f be       	out	0x3f, r0	; 63
    1b36:	cd bf       	out	0x3d, r28	; 61
    1b38:	98 87       	std	Y+8, r25	; 0x08
    1b3a:	8f 83       	std	Y+7, r24	; 0x07
    1b3c:	7a 87       	std	Y+10, r23	; 0x0a
    1b3e:	69 87       	std	Y+9, r22	; 0x09
    1b40:	5c 87       	std	Y+12, r21	; 0x0c
    1b42:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1b44:	8f 81       	ldd	r24, Y+7	; 0x07
    1b46:	98 85       	ldd	r25, Y+8	; 0x08
    1b48:	9c 83       	std	Y+4, r25	; 0x04
    1b4a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b4c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b50:	fc 81       	ldd	r31, Y+4	; 0x04
    1b52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b54:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b56:	8a 81       	ldd	r24, Y+2	; 0x02
    1b58:	88 23       	and	r24, r24
    1b5a:	81 f1       	breq	.+96     	; 0x1bbc <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b60:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b62:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	9c 81       	ldd	r25, Y+4	; 0x04
    1b68:	29 85       	ldd	r18, Y+9	; 0x09
    1b6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b6c:	b9 01       	movw	r22, r18
    1b6e:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1b72:	8a 81       	ldd	r24, Y+2	; 0x02
    1b74:	81 50       	subi	r24, 0x01	; 1
    1b76:	eb 81       	ldd	r30, Y+3	; 0x03
    1b78:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b80:	a9 f4       	brne	.+42     	; 0x1bac <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b82:	eb 81       	ldd	r30, Y+3	; 0x03
    1b84:	fc 81       	ldd	r31, Y+4	; 0x04
    1b86:	80 85       	ldd	r24, Z+8	; 0x08
    1b88:	88 23       	and	r24, r24
    1b8a:	a9 f0       	breq	.+42     	; 0x1bb6 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b90:	08 96       	adiw	r24, 0x08	; 8
    1b92:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1b96:	88 23       	and	r24, r24
    1b98:	71 f0       	breq	.+28     	; 0x1bb6 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1b9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b9e:	00 97       	sbiw	r24, 0x00	; 0
    1ba0:	51 f0       	breq	.+20     	; 0x1bb6 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1ba2:	eb 85       	ldd	r30, Y+11	; 0x0b
    1ba4:	fc 85       	ldd	r31, Y+12	; 0x0c
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	80 83       	st	Z, r24
    1baa:	05 c0       	rjmp	.+10     	; 0x1bb6 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1bac:	89 81       	ldd	r24, Y+1	; 0x01
    1bae:	8f 5f       	subi	r24, 0xFF	; 255
    1bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	8e 83       	std	Y+6, r24	; 0x06
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1bbc:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1bbe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1bc0:	2c 96       	adiw	r28, 0x0c	; 12
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	cf 91       	pop	r28
    1bce:	df 91       	pop	r29
    1bd0:	08 95       	ret

00001bd2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1bd2:	df 93       	push	r29
    1bd4:	cf 93       	push	r28
    1bd6:	cd b7       	in	r28, 0x3d	; 61
    1bd8:	de b7       	in	r29, 0x3e	; 62
    1bda:	2a 97       	sbiw	r28, 0x0a	; 10
    1bdc:	0f b6       	in	r0, 0x3f	; 63
    1bde:	f8 94       	cli
    1be0:	de bf       	out	0x3e, r29	; 62
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	cd bf       	out	0x3d, r28	; 61
    1be6:	98 87       	std	Y+8, r25	; 0x08
    1be8:	8f 83       	std	Y+7, r24	; 0x07
    1bea:	7a 87       	std	Y+10, r23	; 0x0a
    1bec:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1bee:	8f 81       	ldd	r24, Y+7	; 0x07
    1bf0:	98 85       	ldd	r25, Y+8	; 0x08
    1bf2:	9a 83       	std	Y+2, r25	; 0x02
    1bf4:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1bf6:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bfe:	88 23       	and	r24, r24
    1c00:	b1 f0       	breq	.+44     	; 0x1c2e <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1c02:	e9 81       	ldd	r30, Y+1	; 0x01
    1c04:	fa 81       	ldd	r31, Y+2	; 0x02
    1c06:	86 81       	ldd	r24, Z+6	; 0x06
    1c08:	97 81       	ldd	r25, Z+7	; 0x07
    1c0a:	9c 83       	std	Y+4, r25	; 0x04
    1c0c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c0e:	89 81       	ldd	r24, Y+1	; 0x01
    1c10:	9a 81       	ldd	r25, Y+2	; 0x02
    1c12:	29 85       	ldd	r18, Y+9	; 0x09
    1c14:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c16:	b9 01       	movw	r22, r18
    1c18:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	97 83       	std	Z+7, r25	; 0x07
    1c26:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	8e 83       	std	Y+6, r24	; 0x06
    1c2c:	01 c0       	rjmp	.+2      	; 0x1c30 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1c2e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c30:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1c32:	2a 96       	adiw	r28, 0x0a	; 10
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	de bf       	out	0x3e, r29	; 62
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	cf 91       	pop	r28
    1c40:	df 91       	pop	r29
    1c42:	08 95       	ret

00001c44 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1c44:	df 93       	push	r29
    1c46:	cf 93       	push	r28
    1c48:	00 d0       	rcall	.+0      	; 0x1c4a <uxQueueMessagesWaiting+0x6>
    1c4a:	0f 92       	push	r0
    1c4c:	cd b7       	in	r28, 0x3d	; 61
    1c4e:	de b7       	in	r29, 0x3e	; 62
    1c50:	9b 83       	std	Y+3, r25	; 0x03
    1c52:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1c54:	0f b6       	in	r0, 0x3f	; 63
    1c56:	f8 94       	cli
    1c58:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c60:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1c62:	0f 90       	pop	r0
    1c64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1c66:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1c68:	0f 90       	pop	r0
    1c6a:	0f 90       	pop	r0
    1c6c:	0f 90       	pop	r0
    1c6e:	cf 91       	pop	r28
    1c70:	df 91       	pop	r29
    1c72:	08 95       	ret

00001c74 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1c74:	df 93       	push	r29
    1c76:	cf 93       	push	r28
    1c78:	00 d0       	rcall	.+0      	; 0x1c7a <uxQueueSpacesAvailable+0x6>
    1c7a:	00 d0       	rcall	.+0      	; 0x1c7c <uxQueueSpacesAvailable+0x8>
    1c7c:	0f 92       	push	r0
    1c7e:	cd b7       	in	r28, 0x3d	; 61
    1c80:	de b7       	in	r29, 0x3e	; 62
    1c82:	9d 83       	std	Y+5, r25	; 0x05
    1c84:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1c86:	8c 81       	ldd	r24, Y+4	; 0x04
    1c88:	9d 81       	ldd	r25, Y+5	; 0x05
    1c8a:	9a 83       	std	Y+2, r25	; 0x02
    1c8c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1c8e:	0f b6       	in	r0, 0x3f	; 63
    1c90:	f8 94       	cli
    1c92:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1c94:	e9 81       	ldd	r30, Y+1	; 0x01
    1c96:	fa 81       	ldd	r31, Y+2	; 0x02
    1c98:	93 8d       	ldd	r25, Z+27	; 0x1b
    1c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ca0:	29 2f       	mov	r18, r25
    1ca2:	28 1b       	sub	r18, r24
    1ca4:	82 2f       	mov	r24, r18
    1ca6:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1cac:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cae:	0f 90       	pop	r0
    1cb0:	0f 90       	pop	r0
    1cb2:	0f 90       	pop	r0
    1cb4:	0f 90       	pop	r0
    1cb6:	0f 90       	pop	r0
    1cb8:	cf 91       	pop	r28
    1cba:	df 91       	pop	r29
    1cbc:	08 95       	ret

00001cbe <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1cbe:	df 93       	push	r29
    1cc0:	cf 93       	push	r28
    1cc2:	00 d0       	rcall	.+0      	; 0x1cc4 <uxQueueMessagesWaitingFromISR+0x6>
    1cc4:	00 d0       	rcall	.+0      	; 0x1cc6 <uxQueueMessagesWaitingFromISR+0x8>
    1cc6:	0f 92       	push	r0
    1cc8:	cd b7       	in	r28, 0x3d	; 61
    1cca:	de b7       	in	r29, 0x3e	; 62
    1ccc:	9d 83       	std	Y+5, r25	; 0x05
    1cce:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1cd0:	8c 81       	ldd	r24, Y+4	; 0x04
    1cd2:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd4:	9a 83       	std	Y+2, r25	; 0x02
    1cd6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1cda:	fa 81       	ldd	r31, Y+2	; 0x02
    1cdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cde:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1ce0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ce2:	0f 90       	pop	r0
    1ce4:	0f 90       	pop	r0
    1ce6:	0f 90       	pop	r0
    1ce8:	0f 90       	pop	r0
    1cea:	0f 90       	pop	r0
    1cec:	cf 91       	pop	r28
    1cee:	df 91       	pop	r29
    1cf0:	08 95       	ret

00001cf2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1cf2:	df 93       	push	r29
    1cf4:	cf 93       	push	r28
    1cf6:	00 d0       	rcall	.+0      	; 0x1cf8 <vQueueDelete+0x6>
    1cf8:	00 d0       	rcall	.+0      	; 0x1cfa <vQueueDelete+0x8>
    1cfa:	cd b7       	in	r28, 0x3d	; 61
    1cfc:	de b7       	in	r29, 0x3e	; 62
    1cfe:	9c 83       	std	Y+4, r25	; 0x04
    1d00:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1d02:	8b 81       	ldd	r24, Y+3	; 0x03
    1d04:	9c 81       	ldd	r25, Y+4	; 0x04
    1d06:	9a 83       	std	Y+2, r25	; 0x02
    1d08:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1d0a:	89 81       	ldd	r24, Y+1	; 0x01
    1d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d0e:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1d12:	0f 90       	pop	r0
    1d14:	0f 90       	pop	r0
    1d16:	0f 90       	pop	r0
    1d18:	0f 90       	pop	r0
    1d1a:	cf 91       	pop	r28
    1d1c:	df 91       	pop	r29
    1d1e:	08 95       	ret

00001d20 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    1d20:	df 93       	push	r29
    1d22:	cf 93       	push	r28
    1d24:	00 d0       	rcall	.+0      	; 0x1d26 <prvGetDisinheritPriorityAfterTimeout+0x6>
    1d26:	0f 92       	push	r0
    1d28:	cd b7       	in	r28, 0x3d	; 61
    1d2a:	de b7       	in	r29, 0x3e	; 62
    1d2c:	9b 83       	std	Y+3, r25	; 0x03
    1d2e:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    1d30:	ea 81       	ldd	r30, Y+2	; 0x02
    1d32:	fb 81       	ldd	r31, Y+3	; 0x03
    1d34:	81 89       	ldd	r24, Z+17	; 0x11
    1d36:	88 23       	and	r24, r24
    1d38:	61 f0       	breq	.+24     	; 0x1d52 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    1d3a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d3c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d3e:	06 88       	ldd	r0, Z+22	; 0x16
    1d40:	f7 89       	ldd	r31, Z+23	; 0x17
    1d42:	e0 2d       	mov	r30, r0
    1d44:	80 81       	ld	r24, Z
    1d46:	91 81       	ldd	r25, Z+1	; 0x01
    1d48:	98 2f       	mov	r25, r24
    1d4a:	84 e0       	ldi	r24, 0x04	; 4
    1d4c:	89 1b       	sub	r24, r25
    1d4e:	89 83       	std	Y+1, r24	; 0x01
    1d50:	01 c0       	rjmp	.+2      	; 0x1d54 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1d52:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1d56:	0f 90       	pop	r0
    1d58:	0f 90       	pop	r0
    1d5a:	0f 90       	pop	r0
    1d5c:	cf 91       	pop	r28
    1d5e:	df 91       	pop	r29
    1d60:	08 95       	ret

00001d62 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1d62:	df 93       	push	r29
    1d64:	cf 93       	push	r28
    1d66:	cd b7       	in	r28, 0x3d	; 61
    1d68:	de b7       	in	r29, 0x3e	; 62
    1d6a:	27 97       	sbiw	r28, 0x07	; 7
    1d6c:	0f b6       	in	r0, 0x3f	; 63
    1d6e:	f8 94       	cli
    1d70:	de bf       	out	0x3e, r29	; 62
    1d72:	0f be       	out	0x3f, r0	; 63
    1d74:	cd bf       	out	0x3d, r28	; 61
    1d76:	9c 83       	std	Y+4, r25	; 0x04
    1d78:	8b 83       	std	Y+3, r24	; 0x03
    1d7a:	7e 83       	std	Y+6, r23	; 0x06
    1d7c:	6d 83       	std	Y+5, r22	; 0x05
    1d7e:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1d80:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1d82:	eb 81       	ldd	r30, Y+3	; 0x03
    1d84:	fc 81       	ldd	r31, Y+4	; 0x04
    1d86:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d88:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1d8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d90:	88 23       	and	r24, r24
    1d92:	99 f4       	brne	.+38     	; 0x1dba <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1d94:	eb 81       	ldd	r30, Y+3	; 0x03
    1d96:	fc 81       	ldd	r31, Y+4	; 0x04
    1d98:	80 81       	ld	r24, Z
    1d9a:	91 81       	ldd	r25, Z+1	; 0x01
    1d9c:	00 97       	sbiw	r24, 0x00	; 0
    1d9e:	09 f0       	breq	.+2      	; 0x1da2 <prvCopyDataToQueue+0x40>
    1da0:	89 c0       	rjmp	.+274    	; 0x1eb4 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    1da2:	eb 81       	ldd	r30, Y+3	; 0x03
    1da4:	fc 81       	ldd	r31, Y+4	; 0x04
    1da6:	84 81       	ldd	r24, Z+4	; 0x04
    1da8:	95 81       	ldd	r25, Z+5	; 0x05
    1daa:	0e 94 88 21 	call	0x4310	; 0x4310 <xTaskPriorityDisinherit>
    1dae:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1db0:	eb 81       	ldd	r30, Y+3	; 0x03
    1db2:	fc 81       	ldd	r31, Y+4	; 0x04
    1db4:	15 82       	std	Z+5, r1	; 0x05
    1db6:	14 82       	std	Z+4, r1	; 0x04
    1db8:	7d c0       	rjmp	.+250    	; 0x1eb4 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1dba:	8f 81       	ldd	r24, Y+7	; 0x07
    1dbc:	88 23       	and	r24, r24
    1dbe:	99 f5       	brne	.+102    	; 0x1e26 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc4:	62 81       	ldd	r22, Z+2	; 0x02
    1dc6:	73 81       	ldd	r23, Z+3	; 0x03
    1dc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dca:	fc 81       	ldd	r31, Y+4	; 0x04
    1dcc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1dce:	48 2f       	mov	r20, r24
    1dd0:	50 e0       	ldi	r21, 0x00	; 0
    1dd2:	2d 81       	ldd	r18, Y+5	; 0x05
    1dd4:	3e 81       	ldd	r19, Y+6	; 0x06
    1dd6:	cb 01       	movw	r24, r22
    1dd8:	b9 01       	movw	r22, r18
    1dda:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1dde:	eb 81       	ldd	r30, Y+3	; 0x03
    1de0:	fc 81       	ldd	r31, Y+4	; 0x04
    1de2:	22 81       	ldd	r18, Z+2	; 0x02
    1de4:	33 81       	ldd	r19, Z+3	; 0x03
    1de6:	eb 81       	ldd	r30, Y+3	; 0x03
    1de8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dea:	84 8d       	ldd	r24, Z+28	; 0x1c
    1dec:	88 2f       	mov	r24, r24
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	82 0f       	add	r24, r18
    1df2:	93 1f       	adc	r25, r19
    1df4:	eb 81       	ldd	r30, Y+3	; 0x03
    1df6:	fc 81       	ldd	r31, Y+4	; 0x04
    1df8:	93 83       	std	Z+3, r25	; 0x03
    1dfa:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1dfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1e00:	22 81       	ldd	r18, Z+2	; 0x02
    1e02:	33 81       	ldd	r19, Z+3	; 0x03
    1e04:	eb 81       	ldd	r30, Y+3	; 0x03
    1e06:	fc 81       	ldd	r31, Y+4	; 0x04
    1e08:	84 81       	ldd	r24, Z+4	; 0x04
    1e0a:	95 81       	ldd	r25, Z+5	; 0x05
    1e0c:	28 17       	cp	r18, r24
    1e0e:	39 07       	cpc	r19, r25
    1e10:	08 f4       	brcc	.+2      	; 0x1e14 <prvCopyDataToQueue+0xb2>
    1e12:	50 c0       	rjmp	.+160    	; 0x1eb4 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1e14:	eb 81       	ldd	r30, Y+3	; 0x03
    1e16:	fc 81       	ldd	r31, Y+4	; 0x04
    1e18:	80 81       	ld	r24, Z
    1e1a:	91 81       	ldd	r25, Z+1	; 0x01
    1e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e20:	93 83       	std	Z+3, r25	; 0x03
    1e22:	82 83       	std	Z+2, r24	; 0x02
    1e24:	47 c0       	rjmp	.+142    	; 0x1eb4 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1e26:	eb 81       	ldd	r30, Y+3	; 0x03
    1e28:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2a:	66 81       	ldd	r22, Z+6	; 0x06
    1e2c:	77 81       	ldd	r23, Z+7	; 0x07
    1e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e30:	fc 81       	ldd	r31, Y+4	; 0x04
    1e32:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e34:	48 2f       	mov	r20, r24
    1e36:	50 e0       	ldi	r21, 0x00	; 0
    1e38:	2d 81       	ldd	r18, Y+5	; 0x05
    1e3a:	3e 81       	ldd	r19, Y+6	; 0x06
    1e3c:	cb 01       	movw	r24, r22
    1e3e:	b9 01       	movw	r22, r18
    1e40:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1e44:	eb 81       	ldd	r30, Y+3	; 0x03
    1e46:	fc 81       	ldd	r31, Y+4	; 0x04
    1e48:	26 81       	ldd	r18, Z+6	; 0x06
    1e4a:	37 81       	ldd	r19, Z+7	; 0x07
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e52:	88 2f       	mov	r24, r24
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	90 95       	com	r25
    1e58:	81 95       	neg	r24
    1e5a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e5c:	82 0f       	add	r24, r18
    1e5e:	93 1f       	adc	r25, r19
    1e60:	eb 81       	ldd	r30, Y+3	; 0x03
    1e62:	fc 81       	ldd	r31, Y+4	; 0x04
    1e64:	97 83       	std	Z+7, r25	; 0x07
    1e66:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1e68:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e6c:	26 81       	ldd	r18, Z+6	; 0x06
    1e6e:	37 81       	ldd	r19, Z+7	; 0x07
    1e70:	eb 81       	ldd	r30, Y+3	; 0x03
    1e72:	fc 81       	ldd	r31, Y+4	; 0x04
    1e74:	80 81       	ld	r24, Z
    1e76:	91 81       	ldd	r25, Z+1	; 0x01
    1e78:	28 17       	cp	r18, r24
    1e7a:	39 07       	cpc	r19, r25
    1e7c:	90 f4       	brcc	.+36     	; 0x1ea2 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1e7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e80:	fc 81       	ldd	r31, Y+4	; 0x04
    1e82:	24 81       	ldd	r18, Z+4	; 0x04
    1e84:	35 81       	ldd	r19, Z+5	; 0x05
    1e86:	eb 81       	ldd	r30, Y+3	; 0x03
    1e88:	fc 81       	ldd	r31, Y+4	; 0x04
    1e8a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e8c:	88 2f       	mov	r24, r24
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	90 95       	com	r25
    1e92:	81 95       	neg	r24
    1e94:	9f 4f       	sbci	r25, 0xFF	; 255
    1e96:	82 0f       	add	r24, r18
    1e98:	93 1f       	adc	r25, r19
    1e9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9e:	97 83       	std	Z+7, r25	; 0x07
    1ea0:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1ea2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea4:	82 30       	cpi	r24, 0x02	; 2
    1ea6:	31 f4       	brne	.+12     	; 0x1eb4 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	88 23       	and	r24, r24
    1eac:	19 f0       	breq	.+6      	; 0x1eb4 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1eae:	89 81       	ldd	r24, Y+1	; 0x01
    1eb0:	81 50       	subi	r24, 0x01	; 1
    1eb2:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1eb4:	89 81       	ldd	r24, Y+1	; 0x01
    1eb6:	8f 5f       	subi	r24, 0xFF	; 255
    1eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eba:	fc 81       	ldd	r31, Y+4	; 0x04
    1ebc:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1ebe:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ec0:	27 96       	adiw	r28, 0x07	; 7
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	cf 91       	pop	r28
    1ece:	df 91       	pop	r29
    1ed0:	08 95       	ret

00001ed2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1ed2:	df 93       	push	r29
    1ed4:	cf 93       	push	r28
    1ed6:	00 d0       	rcall	.+0      	; 0x1ed8 <prvCopyDataFromQueue+0x6>
    1ed8:	00 d0       	rcall	.+0      	; 0x1eda <prvCopyDataFromQueue+0x8>
    1eda:	cd b7       	in	r28, 0x3d	; 61
    1edc:	de b7       	in	r29, 0x3e	; 62
    1ede:	9a 83       	std	Y+2, r25	; 0x02
    1ee0:	89 83       	std	Y+1, r24	; 0x01
    1ee2:	7c 83       	std	Y+4, r23	; 0x04
    1ee4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eea:	84 8d       	ldd	r24, Z+28	; 0x1c
    1eec:	88 23       	and	r24, r24
    1eee:	89 f1       	breq	.+98     	; 0x1f52 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ef4:	26 81       	ldd	r18, Z+6	; 0x06
    1ef6:	37 81       	ldd	r19, Z+7	; 0x07
    1ef8:	e9 81       	ldd	r30, Y+1	; 0x01
    1efa:	fa 81       	ldd	r31, Y+2	; 0x02
    1efc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1efe:	88 2f       	mov	r24, r24
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	82 0f       	add	r24, r18
    1f04:	93 1f       	adc	r25, r19
    1f06:	e9 81       	ldd	r30, Y+1	; 0x01
    1f08:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0a:	97 83       	std	Z+7, r25	; 0x07
    1f0c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f10:	fa 81       	ldd	r31, Y+2	; 0x02
    1f12:	26 81       	ldd	r18, Z+6	; 0x06
    1f14:	37 81       	ldd	r19, Z+7	; 0x07
    1f16:	e9 81       	ldd	r30, Y+1	; 0x01
    1f18:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1a:	84 81       	ldd	r24, Z+4	; 0x04
    1f1c:	95 81       	ldd	r25, Z+5	; 0x05
    1f1e:	28 17       	cp	r18, r24
    1f20:	39 07       	cpc	r19, r25
    1f22:	40 f0       	brcs	.+16     	; 0x1f34 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1f24:	e9 81       	ldd	r30, Y+1	; 0x01
    1f26:	fa 81       	ldd	r31, Y+2	; 0x02
    1f28:	80 81       	ld	r24, Z
    1f2a:	91 81       	ldd	r25, Z+1	; 0x01
    1f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f30:	97 83       	std	Z+7, r25	; 0x07
    1f32:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	46 81       	ldd	r20, Z+6	; 0x06
    1f3a:	57 81       	ldd	r21, Z+7	; 0x07
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f42:	28 2f       	mov	r18, r24
    1f44:	30 e0       	ldi	r19, 0x00	; 0
    1f46:	8b 81       	ldd	r24, Y+3	; 0x03
    1f48:	9c 81       	ldd	r25, Y+4	; 0x04
    1f4a:	ba 01       	movw	r22, r20
    1f4c:	a9 01       	movw	r20, r18
    1f4e:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>
	}
}
    1f52:	0f 90       	pop	r0
    1f54:	0f 90       	pop	r0
    1f56:	0f 90       	pop	r0
    1f58:	0f 90       	pop	r0
    1f5a:	cf 91       	pop	r28
    1f5c:	df 91       	pop	r29
    1f5e:	08 95       	ret

00001f60 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1f60:	df 93       	push	r29
    1f62:	cf 93       	push	r28
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <prvUnlockQueue+0x6>
    1f66:	00 d0       	rcall	.+0      	; 0x1f68 <prvUnlockQueue+0x8>
    1f68:	cd b7       	in	r28, 0x3d	; 61
    1f6a:	de b7       	in	r29, 0x3e	; 62
    1f6c:	9c 83       	std	Y+4, r25	; 0x04
    1f6e:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1f70:	0f b6       	in	r0, 0x3f	; 63
    1f72:	f8 94       	cli
    1f74:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1f76:	eb 81       	ldd	r30, Y+3	; 0x03
    1f78:	fc 81       	ldd	r31, Y+4	; 0x04
    1f7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f7c:	8a 83       	std	Y+2, r24	; 0x02
    1f7e:	11 c0       	rjmp	.+34     	; 0x1fa2 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f80:	eb 81       	ldd	r30, Y+3	; 0x03
    1f82:	fc 81       	ldd	r31, Y+4	; 0x04
    1f84:	81 89       	ldd	r24, Z+17	; 0x11
    1f86:	88 23       	and	r24, r24
    1f88:	79 f0       	breq	.+30     	; 0x1fa8 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8e:	41 96       	adiw	r24, 0x11	; 17
    1f90:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1f94:	88 23       	and	r24, r24
    1f96:	11 f0       	breq	.+4      	; 0x1f9c <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1f98:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1f9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f9e:	81 50       	subi	r24, 0x01	; 1
    1fa0:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1fa2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa4:	18 16       	cp	r1, r24
    1fa6:	64 f3       	brlt	.-40     	; 0x1f80 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1fa8:	eb 81       	ldd	r30, Y+3	; 0x03
    1faa:	fc 81       	ldd	r31, Y+4	; 0x04
    1fac:	8f ef       	ldi	r24, 0xFF	; 255
    1fae:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1fb0:	0f 90       	pop	r0
    1fb2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1fba:	eb 81       	ldd	r30, Y+3	; 0x03
    1fbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fbe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fc0:	89 83       	std	Y+1, r24	; 0x01
    1fc2:	11 c0       	rjmp	.+34     	; 0x1fe6 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fc4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc8:	80 85       	ldd	r24, Z+8	; 0x08
    1fca:	88 23       	and	r24, r24
    1fcc:	79 f0       	breq	.+30     	; 0x1fec <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1fce:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd2:	08 96       	adiw	r24, 0x08	; 8
    1fd4:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <xTaskRemoveFromEventList>
    1fd8:	88 23       	and	r24, r24
    1fda:	11 f0       	breq	.+4      	; 0x1fe0 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1fdc:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
    1fe2:	81 50       	subi	r24, 0x01	; 1
    1fe4:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	18 16       	cp	r1, r24
    1fea:	64 f3       	brlt	.-40     	; 0x1fc4 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1fec:	eb 81       	ldd	r30, Y+3	; 0x03
    1fee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff0:	8f ef       	ldi	r24, 0xFF	; 255
    1ff2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63
}
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	cf 91       	pop	r28
    2002:	df 91       	pop	r29
    2004:	08 95       	ret

00002006 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2006:	df 93       	push	r29
    2008:	cf 93       	push	r28
    200a:	00 d0       	rcall	.+0      	; 0x200c <prvIsQueueEmpty+0x6>
    200c:	0f 92       	push	r0
    200e:	cd b7       	in	r28, 0x3d	; 61
    2010:	de b7       	in	r29, 0x3e	; 62
    2012:	9b 83       	std	Y+3, r25	; 0x03
    2014:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	f8 94       	cli
    201a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    201c:	ea 81       	ldd	r30, Y+2	; 0x02
    201e:	fb 81       	ldd	r31, Y+3	; 0x03
    2020:	82 8d       	ldd	r24, Z+26	; 0x1a
    2022:	88 23       	and	r24, r24
    2024:	19 f4       	brne	.+6      	; 0x202c <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2026:	81 e0       	ldi	r24, 0x01	; 1
    2028:	89 83       	std	Y+1, r24	; 0x01
    202a:	01 c0       	rjmp	.+2      	; 0x202e <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    202c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2032:	89 81       	ldd	r24, Y+1	; 0x01
}
    2034:	0f 90       	pop	r0
    2036:	0f 90       	pop	r0
    2038:	0f 90       	pop	r0
    203a:	cf 91       	pop	r28
    203c:	df 91       	pop	r29
    203e:	08 95       	ret

00002040 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2040:	df 93       	push	r29
    2042:	cf 93       	push	r28
    2044:	00 d0       	rcall	.+0      	; 0x2046 <xQueueIsQueueEmptyFromISR+0x6>
    2046:	00 d0       	rcall	.+0      	; 0x2048 <xQueueIsQueueEmptyFromISR+0x8>
    2048:	0f 92       	push	r0
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	9d 83       	std	Y+5, r25	; 0x05
    2050:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2052:	8c 81       	ldd	r24, Y+4	; 0x04
    2054:	9d 81       	ldd	r25, Y+5	; 0x05
    2056:	9a 83       	std	Y+2, r25	; 0x02
    2058:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    205a:	e9 81       	ldd	r30, Y+1	; 0x01
    205c:	fa 81       	ldd	r31, Y+2	; 0x02
    205e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2060:	88 23       	and	r24, r24
    2062:	19 f4       	brne	.+6      	; 0x206a <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	8b 83       	std	Y+3, r24	; 0x03
    2068:	01 c0       	rjmp	.+2      	; 0x206c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    206a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    206c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    206e:	0f 90       	pop	r0
    2070:	0f 90       	pop	r0
    2072:	0f 90       	pop	r0
    2074:	0f 90       	pop	r0
    2076:	0f 90       	pop	r0
    2078:	cf 91       	pop	r28
    207a:	df 91       	pop	r29
    207c:	08 95       	ret

0000207e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    207e:	df 93       	push	r29
    2080:	cf 93       	push	r28
    2082:	00 d0       	rcall	.+0      	; 0x2084 <prvIsQueueFull+0x6>
    2084:	0f 92       	push	r0
    2086:	cd b7       	in	r28, 0x3d	; 61
    2088:	de b7       	in	r29, 0x3e	; 62
    208a:	9b 83       	std	Y+3, r25	; 0x03
    208c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    208e:	0f b6       	in	r0, 0x3f	; 63
    2090:	f8 94       	cli
    2092:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2094:	ea 81       	ldd	r30, Y+2	; 0x02
    2096:	fb 81       	ldd	r31, Y+3	; 0x03
    2098:	92 8d       	ldd	r25, Z+26	; 0x1a
    209a:	ea 81       	ldd	r30, Y+2	; 0x02
    209c:	fb 81       	ldd	r31, Y+3	; 0x03
    209e:	83 8d       	ldd	r24, Z+27	; 0x1b
    20a0:	98 17       	cp	r25, r24
    20a2:	19 f4       	brne	.+6      	; 0x20aa <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    20a4:	81 e0       	ldi	r24, 0x01	; 1
    20a6:	89 83       	std	Y+1, r24	; 0x01
    20a8:	01 c0       	rjmp	.+2      	; 0x20ac <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    20aa:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    20ac:	0f 90       	pop	r0
    20ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	0f 90       	pop	r0
    20b8:	cf 91       	pop	r28
    20ba:	df 91       	pop	r29
    20bc:	08 95       	ret

000020be <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    20be:	df 93       	push	r29
    20c0:	cf 93       	push	r28
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <xQueueIsQueueFullFromISR+0x6>
    20c4:	00 d0       	rcall	.+0      	; 0x20c6 <xQueueIsQueueFullFromISR+0x8>
    20c6:	0f 92       	push	r0
    20c8:	cd b7       	in	r28, 0x3d	; 61
    20ca:	de b7       	in	r29, 0x3e	; 62
    20cc:	9d 83       	std	Y+5, r25	; 0x05
    20ce:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    20d0:	8c 81       	ldd	r24, Y+4	; 0x04
    20d2:	9d 81       	ldd	r25, Y+5	; 0x05
    20d4:	9a 83       	std	Y+2, r25	; 0x02
    20d6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    20d8:	e9 81       	ldd	r30, Y+1	; 0x01
    20da:	fa 81       	ldd	r31, Y+2	; 0x02
    20dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    20de:	e9 81       	ldd	r30, Y+1	; 0x01
    20e0:	fa 81       	ldd	r31, Y+2	; 0x02
    20e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    20e4:	98 17       	cp	r25, r24
    20e6:	19 f4       	brne	.+6      	; 0x20ee <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	8b 83       	std	Y+3, r24	; 0x03
    20ec:	01 c0       	rjmp	.+2      	; 0x20f0 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    20ee:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    20f2:	0f 90       	pop	r0
    20f4:	0f 90       	pop	r0
    20f6:	0f 90       	pop	r0
    20f8:	0f 90       	pop	r0
    20fa:	0f 90       	pop	r0
    20fc:	cf 91       	pop	r28
    20fe:	df 91       	pop	r29
    2100:	08 95       	ret

00002102 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2102:	0f 93       	push	r16
    2104:	df 93       	push	r29
    2106:	cf 93       	push	r28
    2108:	cd b7       	in	r28, 0x3d	; 61
    210a:	de b7       	in	r29, 0x3e	; 62
    210c:	28 97       	sbiw	r28, 0x08	; 8
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	de bf       	out	0x3e, r29	; 62
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	cd bf       	out	0x3d, r28	; 61
    2118:	9d 83       	std	Y+5, r25	; 0x05
    211a:	8c 83       	std	Y+4, r24	; 0x04
    211c:	7f 83       	std	Y+7, r23	; 0x07
    211e:	6e 83       	std	Y+6, r22	; 0x06
    2120:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2122:	88 85       	ldd	r24, Y+8	; 0x08
    2124:	81 30       	cpi	r24, 0x01	; 1
    2126:	19 f4       	brne	.+6      	; 0x212e <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	89 83       	std	Y+1, r24	; 0x01
    212c:	01 c0       	rjmp	.+2      	; 0x2130 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    212e:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2130:	8e 81       	ldd	r24, Y+6	; 0x06
    2132:	9f 81       	ldd	r25, Y+7	; 0x07
    2134:	00 97       	sbiw	r24, 0x00	; 0
    2136:	21 f4       	brne	.+8      	; 0x2140 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	9f 83       	std	Y+7, r25	; 0x07
    213e:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2140:	8c 81       	ldd	r24, Y+4	; 0x04
    2142:	9d 81       	ldd	r25, Y+5	; 0x05
    2144:	01 96       	adiw	r24, 0x01	; 1
    2146:	9d 83       	std	Y+5, r25	; 0x05
    2148:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    214a:	8c 81       	ldd	r24, Y+4	; 0x04
    214c:	9d 81       	ldd	r25, Y+5	; 0x05
    214e:	0f 96       	adiw	r24, 0x0f	; 15
    2150:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2154:	9b 83       	std	Y+3, r25	; 0x03
    2156:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2158:	8a 81       	ldd	r24, Y+2	; 0x02
    215a:	9b 81       	ldd	r25, Y+3	; 0x03
    215c:	00 97       	sbiw	r24, 0x00	; 0
    215e:	89 f0       	breq	.+34     	; 0x2182 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2160:	6a 81       	ldd	r22, Y+2	; 0x02
    2162:	7b 81       	ldd	r23, Y+3	; 0x03
    2164:	8a 81       	ldd	r24, Y+2	; 0x02
    2166:	9b 81       	ldd	r25, Y+3	; 0x03
    2168:	9c 01       	movw	r18, r24
    216a:	21 5f       	subi	r18, 0xF1	; 241
    216c:	3f 4f       	sbci	r19, 0xFF	; 255
    216e:	4c 81       	ldd	r20, Y+4	; 0x04
    2170:	5d 81       	ldd	r21, Y+5	; 0x05
    2172:	ee 81       	ldd	r30, Y+6	; 0x06
    2174:	ff 81       	ldd	r31, Y+7	; 0x07
    2176:	cb 01       	movw	r24, r22
    2178:	b9 01       	movw	r22, r18
    217a:	9f 01       	movw	r18, r30
    217c:	09 81       	ldd	r16, Y+1	; 0x01
    217e:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2182:	8a 81       	ldd	r24, Y+2	; 0x02
    2184:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2186:	28 96       	adiw	r28, 0x08	; 8
    2188:	0f b6       	in	r0, 0x3f	; 63
    218a:	f8 94       	cli
    218c:	de bf       	out	0x3e, r29	; 62
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	cd bf       	out	0x3d, r28	; 61
    2192:	cf 91       	pop	r28
    2194:	df 91       	pop	r29
    2196:	0f 91       	pop	r16
    2198:	08 95       	ret

0000219a <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    219a:	df 93       	push	r29
    219c:	cf 93       	push	r28
    219e:	00 d0       	rcall	.+0      	; 0x21a0 <vStreamBufferDelete+0x6>
    21a0:	00 d0       	rcall	.+0      	; 0x21a2 <vStreamBufferDelete+0x8>
    21a2:	cd b7       	in	r28, 0x3d	; 61
    21a4:	de b7       	in	r29, 0x3e	; 62
    21a6:	9c 83       	std	Y+4, r25	; 0x04
    21a8:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    21aa:	8b 81       	ldd	r24, Y+3	; 0x03
    21ac:	9c 81       	ldd	r25, Y+4	; 0x04
    21ae:	9a 83       	std	Y+2, r25	; 0x02
    21b0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    21b2:	e9 81       	ldd	r30, Y+1	; 0x01
    21b4:	fa 81       	ldd	r31, Y+2	; 0x02
    21b6:	86 85       	ldd	r24, Z+14	; 0x0e
    21b8:	88 2f       	mov	r24, r24
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	82 70       	andi	r24, 0x02	; 2
    21be:	90 70       	andi	r25, 0x00	; 0
    21c0:	00 97       	sbiw	r24, 0x00	; 0
    21c2:	29 f4       	brne	.+10     	; 0x21ce <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    21c4:	89 81       	ldd	r24, Y+1	; 0x01
    21c6:	9a 81       	ldd	r25, Y+2	; 0x02
    21c8:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    21cc:	08 c0       	rjmp	.+16     	; 0x21de <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	9a 81       	ldd	r25, Y+2	; 0x02
    21d2:	60 e0       	ldi	r22, 0x00	; 0
    21d4:	70 e0       	ldi	r23, 0x00	; 0
    21d6:	4f e0       	ldi	r20, 0x0F	; 15
    21d8:	50 e0       	ldi	r21, 0x00	; 0
    21da:	0e 94 06 2b 	call	0x560c	; 0x560c <memset>
	}
}
    21de:	0f 90       	pop	r0
    21e0:	0f 90       	pop	r0
    21e2:	0f 90       	pop	r0
    21e4:	0f 90       	pop	r0
    21e6:	cf 91       	pop	r28
    21e8:	df 91       	pop	r29
    21ea:	08 95       	ret

000021ec <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    21ec:	0f 93       	push	r16
    21ee:	df 93       	push	r29
    21f0:	cf 93       	push	r28
    21f2:	00 d0       	rcall	.+0      	; 0x21f4 <xStreamBufferReset+0x8>
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <xStreamBufferReset+0xa>
    21f6:	0f 92       	push	r0
    21f8:	cd b7       	in	r28, 0x3d	; 61
    21fa:	de b7       	in	r29, 0x3e	; 62
    21fc:	9d 83       	std	Y+5, r25	; 0x05
    21fe:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2200:	8c 81       	ldd	r24, Y+4	; 0x04
    2202:	9d 81       	ldd	r25, Y+5	; 0x05
    2204:	9b 83       	std	Y+3, r25	; 0x03
    2206:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2208:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	f8 94       	cli
    220e:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2210:	ea 81       	ldd	r30, Y+2	; 0x02
    2212:	fb 81       	ldd	r31, Y+3	; 0x03
    2214:	80 85       	ldd	r24, Z+8	; 0x08
    2216:	91 85       	ldd	r25, Z+9	; 0x09
    2218:	00 97       	sbiw	r24, 0x00	; 0
    221a:	f1 f4       	brne	.+60     	; 0x2258 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    221c:	ea 81       	ldd	r30, Y+2	; 0x02
    221e:	fb 81       	ldd	r31, Y+3	; 0x03
    2220:	82 85       	ldd	r24, Z+10	; 0x0a
    2222:	93 85       	ldd	r25, Z+11	; 0x0b
    2224:	00 97       	sbiw	r24, 0x00	; 0
    2226:	c1 f4       	brne	.+48     	; 0x2258 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2228:	ea 81       	ldd	r30, Y+2	; 0x02
    222a:	fb 81       	ldd	r31, Y+3	; 0x03
    222c:	24 85       	ldd	r18, Z+12	; 0x0c
    222e:	35 85       	ldd	r19, Z+13	; 0x0d
    2230:	ea 81       	ldd	r30, Y+2	; 0x02
    2232:	fb 81       	ldd	r31, Y+3	; 0x03
    2234:	44 81       	ldd	r20, Z+4	; 0x04
    2236:	55 81       	ldd	r21, Z+5	; 0x05
    2238:	ea 81       	ldd	r30, Y+2	; 0x02
    223a:	fb 81       	ldd	r31, Y+3	; 0x03
    223c:	a6 81       	ldd	r26, Z+6	; 0x06
    223e:	b7 81       	ldd	r27, Z+7	; 0x07
    2240:	ea 81       	ldd	r30, Y+2	; 0x02
    2242:	fb 81       	ldd	r31, Y+3	; 0x03
    2244:	e6 85       	ldd	r30, Z+14	; 0x0e
    2246:	8a 81       	ldd	r24, Y+2	; 0x02
    2248:	9b 81       	ldd	r25, Y+3	; 0x03
    224a:	b9 01       	movw	r22, r18
    224c:	9d 01       	movw	r18, r26
    224e:	0e 2f       	mov	r16, r30
    2250:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2254:	81 e0       	ldi	r24, 0x01	; 1
    2256:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2258:	0f 90       	pop	r0
    225a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    225c:	89 81       	ldd	r24, Y+1	; 0x01
}
    225e:	0f 90       	pop	r0
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	cf 91       	pop	r28
    226a:	df 91       	pop	r29
    226c:	0f 91       	pop	r16
    226e:	08 95       	ret

00002270 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2270:	df 93       	push	r29
    2272:	cf 93       	push	r28
    2274:	cd b7       	in	r28, 0x3d	; 61
    2276:	de b7       	in	r29, 0x3e	; 62
    2278:	27 97       	sbiw	r28, 0x07	; 7
    227a:	0f b6       	in	r0, 0x3f	; 63
    227c:	f8 94       	cli
    227e:	de bf       	out	0x3e, r29	; 62
    2280:	0f be       	out	0x3f, r0	; 63
    2282:	cd bf       	out	0x3d, r28	; 61
    2284:	9d 83       	std	Y+5, r25	; 0x05
    2286:	8c 83       	std	Y+4, r24	; 0x04
    2288:	7f 83       	std	Y+7, r23	; 0x07
    228a:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    228c:	8c 81       	ldd	r24, Y+4	; 0x04
    228e:	9d 81       	ldd	r25, Y+5	; 0x05
    2290:	9b 83       	std	Y+3, r25	; 0x03
    2292:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2294:	8e 81       	ldd	r24, Y+6	; 0x06
    2296:	9f 81       	ldd	r25, Y+7	; 0x07
    2298:	00 97       	sbiw	r24, 0x00	; 0
    229a:	21 f4       	brne	.+8      	; 0x22a4 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    229c:	81 e0       	ldi	r24, 0x01	; 1
    229e:	90 e0       	ldi	r25, 0x00	; 0
    22a0:	9f 83       	std	Y+7, r25	; 0x07
    22a2:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    22a4:	ea 81       	ldd	r30, Y+2	; 0x02
    22a6:	fb 81       	ldd	r31, Y+3	; 0x03
    22a8:	24 81       	ldd	r18, Z+4	; 0x04
    22aa:	35 81       	ldd	r19, Z+5	; 0x05
    22ac:	8e 81       	ldd	r24, Y+6	; 0x06
    22ae:	9f 81       	ldd	r25, Y+7	; 0x07
    22b0:	28 17       	cp	r18, r24
    22b2:	39 07       	cpc	r19, r25
    22b4:	48 f0       	brcs	.+18     	; 0x22c8 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    22b6:	ea 81       	ldd	r30, Y+2	; 0x02
    22b8:	fb 81       	ldd	r31, Y+3	; 0x03
    22ba:	8e 81       	ldd	r24, Y+6	; 0x06
    22bc:	9f 81       	ldd	r25, Y+7	; 0x07
    22be:	97 83       	std	Z+7, r25	; 0x07
    22c0:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	89 83       	std	Y+1, r24	; 0x01
    22c6:	01 c0       	rjmp	.+2      	; 0x22ca <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    22c8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    22ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    22cc:	27 96       	adiw	r28, 0x07	; 7
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	de bf       	out	0x3e, r29	; 62
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	cd bf       	out	0x3d, r28	; 61
    22d8:	cf 91       	pop	r28
    22da:	df 91       	pop	r29
    22dc:	08 95       	ret

000022de <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    22de:	df 93       	push	r29
    22e0:	cf 93       	push	r28
    22e2:	00 d0       	rcall	.+0      	; 0x22e4 <xStreamBufferSpacesAvailable+0x6>
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <xStreamBufferSpacesAvailable+0x8>
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <xStreamBufferSpacesAvailable+0xa>
    22e8:	cd b7       	in	r28, 0x3d	; 61
    22ea:	de b7       	in	r29, 0x3e	; 62
    22ec:	9e 83       	std	Y+6, r25	; 0x06
    22ee:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    22f0:	8d 81       	ldd	r24, Y+5	; 0x05
    22f2:	9e 81       	ldd	r25, Y+6	; 0x06
    22f4:	9c 83       	std	Y+4, r25	; 0x04
    22f6:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    22f8:	eb 81       	ldd	r30, Y+3	; 0x03
    22fa:	fc 81       	ldd	r31, Y+4	; 0x04
    22fc:	24 81       	ldd	r18, Z+4	; 0x04
    22fe:	35 81       	ldd	r19, Z+5	; 0x05
    2300:	eb 81       	ldd	r30, Y+3	; 0x03
    2302:	fc 81       	ldd	r31, Y+4	; 0x04
    2304:	80 81       	ld	r24, Z
    2306:	91 81       	ldd	r25, Z+1	; 0x01
    2308:	82 0f       	add	r24, r18
    230a:	93 1f       	adc	r25, r19
    230c:	9a 83       	std	Y+2, r25	; 0x02
    230e:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2310:	eb 81       	ldd	r30, Y+3	; 0x03
    2312:	fc 81       	ldd	r31, Y+4	; 0x04
    2314:	22 81       	ldd	r18, Z+2	; 0x02
    2316:	33 81       	ldd	r19, Z+3	; 0x03
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	9a 81       	ldd	r25, Y+2	; 0x02
    231c:	82 1b       	sub	r24, r18
    231e:	93 0b       	sbc	r25, r19
    2320:	9a 83       	std	Y+2, r25	; 0x02
    2322:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2324:	89 81       	ldd	r24, Y+1	; 0x01
    2326:	9a 81       	ldd	r25, Y+2	; 0x02
    2328:	01 97       	sbiw	r24, 0x01	; 1
    232a:	9a 83       	std	Y+2, r25	; 0x02
    232c:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    232e:	eb 81       	ldd	r30, Y+3	; 0x03
    2330:	fc 81       	ldd	r31, Y+4	; 0x04
    2332:	24 81       	ldd	r18, Z+4	; 0x04
    2334:	35 81       	ldd	r19, Z+5	; 0x05
    2336:	89 81       	ldd	r24, Y+1	; 0x01
    2338:	9a 81       	ldd	r25, Y+2	; 0x02
    233a:	82 17       	cp	r24, r18
    233c:	93 07       	cpc	r25, r19
    233e:	50 f0       	brcs	.+20     	; 0x2354 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2340:	eb 81       	ldd	r30, Y+3	; 0x03
    2342:	fc 81       	ldd	r31, Y+4	; 0x04
    2344:	24 81       	ldd	r18, Z+4	; 0x04
    2346:	35 81       	ldd	r19, Z+5	; 0x05
    2348:	89 81       	ldd	r24, Y+1	; 0x01
    234a:	9a 81       	ldd	r25, Y+2	; 0x02
    234c:	82 1b       	sub	r24, r18
    234e:	93 0b       	sbc	r25, r19
    2350:	9a 83       	std	Y+2, r25	; 0x02
    2352:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2354:	89 81       	ldd	r24, Y+1	; 0x01
    2356:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2358:	26 96       	adiw	r28, 0x06	; 6
    235a:	0f b6       	in	r0, 0x3f	; 63
    235c:	f8 94       	cli
    235e:	de bf       	out	0x3e, r29	; 62
    2360:	0f be       	out	0x3f, r0	; 63
    2362:	cd bf       	out	0x3d, r28	; 61
    2364:	cf 91       	pop	r28
    2366:	df 91       	pop	r29
    2368:	08 95       	ret

0000236a <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    236a:	df 93       	push	r29
    236c:	cf 93       	push	r28
    236e:	00 d0       	rcall	.+0      	; 0x2370 <xStreamBufferBytesAvailable+0x6>
    2370:	00 d0       	rcall	.+0      	; 0x2372 <xStreamBufferBytesAvailable+0x8>
    2372:	00 d0       	rcall	.+0      	; 0x2374 <xStreamBufferBytesAvailable+0xa>
    2374:	cd b7       	in	r28, 0x3d	; 61
    2376:	de b7       	in	r29, 0x3e	; 62
    2378:	9e 83       	std	Y+6, r25	; 0x06
    237a:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    237c:	8d 81       	ldd	r24, Y+5	; 0x05
    237e:	9e 81       	ldd	r25, Y+6	; 0x06
    2380:	9c 83       	std	Y+4, r25	; 0x04
    2382:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2384:	8b 81       	ldd	r24, Y+3	; 0x03
    2386:	9c 81       	ldd	r25, Y+4	; 0x04
    2388:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    238c:	9a 83       	std	Y+2, r25	; 0x02
    238e:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2390:	89 81       	ldd	r24, Y+1	; 0x01
    2392:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2394:	26 96       	adiw	r28, 0x06	; 6
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	de bf       	out	0x3e, r29	; 62
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	cd bf       	out	0x3d, r28	; 61
    23a0:	cf 91       	pop	r28
    23a2:	df 91       	pop	r29
    23a4:	08 95       	ret

000023a6 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    23a6:	ef 92       	push	r14
    23a8:	ff 92       	push	r15
    23aa:	0f 93       	push	r16
    23ac:	1f 93       	push	r17
    23ae:	df 93       	push	r29
    23b0:	cf 93       	push	r28
    23b2:	cd b7       	in	r28, 0x3d	; 61
    23b4:	de b7       	in	r29, 0x3e	; 62
    23b6:	63 97       	sbiw	r28, 0x13	; 19
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	de bf       	out	0x3e, r29	; 62
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	cd bf       	out	0x3d, r28	; 61
    23c2:	9d 87       	std	Y+13, r25	; 0x0d
    23c4:	8c 87       	std	Y+12, r24	; 0x0c
    23c6:	7f 87       	std	Y+15, r23	; 0x0f
    23c8:	6e 87       	std	Y+14, r22	; 0x0e
    23ca:	59 8b       	std	Y+17, r21	; 0x11
    23cc:	48 8b       	std	Y+16, r20	; 0x10
    23ce:	3b 8b       	std	Y+19, r19	; 0x13
    23d0:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    23d2:	8c 85       	ldd	r24, Y+12	; 0x0c
    23d4:	9d 85       	ldd	r25, Y+13	; 0x0d
    23d6:	98 87       	std	Y+8, r25	; 0x08
    23d8:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    23da:	1c 82       	std	Y+4, r1	; 0x04
    23dc:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    23de:	88 89       	ldd	r24, Y+16	; 0x10
    23e0:	99 89       	ldd	r25, Y+17	; 0x11
    23e2:	9a 83       	std	Y+2, r25	; 0x02
    23e4:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    23e6:	ef 81       	ldd	r30, Y+7	; 0x07
    23e8:	f8 85       	ldd	r31, Y+8	; 0x08
    23ea:	86 85       	ldd	r24, Z+14	; 0x0e
    23ec:	88 2f       	mov	r24, r24
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	81 70       	andi	r24, 0x01	; 1
    23f2:	90 70       	andi	r25, 0x00	; 0
    23f4:	88 23       	and	r24, r24
    23f6:	29 f0       	breq	.+10     	; 0x2402 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    23f8:	89 81       	ldd	r24, Y+1	; 0x01
    23fa:	9a 81       	ldd	r25, Y+2	; 0x02
    23fc:	02 96       	adiw	r24, 0x02	; 2
    23fe:	9a 83       	std	Y+2, r25	; 0x02
    2400:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2402:	8a 89       	ldd	r24, Y+18	; 0x12
    2404:	9b 89       	ldd	r25, Y+19	; 0x13
    2406:	00 97       	sbiw	r24, 0x00	; 0
    2408:	09 f4       	brne	.+2      	; 0x240c <xStreamBufferSend+0x66>
    240a:	40 c0       	rjmp	.+128    	; 0x248c <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    240c:	ce 01       	movw	r24, r28
    240e:	09 96       	adiw	r24, 0x09	; 9
    2410:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2414:	0f b6       	in	r0, 0x3f	; 63
    2416:	f8 94       	cli
    2418:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    241a:	8f 81       	ldd	r24, Y+7	; 0x07
    241c:	98 85       	ldd	r25, Y+8	; 0x08
    241e:	0e 94 6f 11 	call	0x22de	; 0x22de <xStreamBufferSpacesAvailable>
    2422:	9c 83       	std	Y+4, r25	; 0x04
    2424:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2426:	2b 81       	ldd	r18, Y+3	; 0x03
    2428:	3c 81       	ldd	r19, Y+4	; 0x04
    242a:	89 81       	ldd	r24, Y+1	; 0x01
    242c:	9a 81       	ldd	r25, Y+2	; 0x02
    242e:	28 17       	cp	r18, r24
    2430:	39 07       	cpc	r19, r25
    2432:	50 f5       	brcc	.+84     	; 0x2488 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2434:	80 e0       	ldi	r24, 0x00	; 0
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	0e 94 3c 26 	call	0x4c78	; 0x4c78 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    243c:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <xTaskGetCurrentTaskHandle>
    2440:	ef 81       	ldd	r30, Y+7	; 0x07
    2442:	f8 85       	ldd	r31, Y+8	; 0x08
    2444:	93 87       	std	Z+11, r25	; 0x0b
    2446:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2448:	0f 90       	pop	r0
    244a:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    244c:	ea 89       	ldd	r30, Y+18	; 0x12
    244e:	fb 89       	ldd	r31, Y+19	; 0x13
    2450:	60 e0       	ldi	r22, 0x00	; 0
    2452:	70 e0       	ldi	r23, 0x00	; 0
    2454:	80 e0       	ldi	r24, 0x00	; 0
    2456:	90 e0       	ldi	r25, 0x00	; 0
    2458:	20 e0       	ldi	r18, 0x00	; 0
    245a:	30 e0       	ldi	r19, 0x00	; 0
    245c:	40 e0       	ldi	r20, 0x00	; 0
    245e:	50 e0       	ldi	r21, 0x00	; 0
    2460:	00 e0       	ldi	r16, 0x00	; 0
    2462:	10 e0       	ldi	r17, 0x00	; 0
    2464:	7f 01       	movw	r14, r30
    2466:	0e 94 45 23 	call	0x468a	; 0x468a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    246a:	ef 81       	ldd	r30, Y+7	; 0x07
    246c:	f8 85       	ldd	r31, Y+8	; 0x08
    246e:	13 86       	std	Z+11, r1	; 0x0b
    2470:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2472:	ce 01       	movw	r24, r28
    2474:	09 96       	adiw	r24, 0x09	; 9
    2476:	9e 01       	movw	r18, r28
    2478:	2e 5e       	subi	r18, 0xEE	; 238
    247a:	3f 4f       	sbci	r19, 0xFF	; 255
    247c:	b9 01       	movw	r22, r18
    247e:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <xTaskCheckForTimeOut>
    2482:	88 23       	and	r24, r24
    2484:	39 f2       	breq	.-114    	; 0x2414 <xStreamBufferSend+0x6e>
    2486:	02 c0       	rjmp	.+4      	; 0x248c <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2488:	0f 90       	pop	r0
    248a:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    248c:	8b 81       	ldd	r24, Y+3	; 0x03
    248e:	9c 81       	ldd	r25, Y+4	; 0x04
    2490:	00 97       	sbiw	r24, 0x00	; 0
    2492:	31 f4       	brne	.+12     	; 0x24a0 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2494:	8f 81       	ldd	r24, Y+7	; 0x07
    2496:	98 85       	ldd	r25, Y+8	; 0x08
    2498:	0e 94 6f 11 	call	0x22de	; 0x22de <xStreamBufferSpacesAvailable>
    249c:	9c 83       	std	Y+4, r25	; 0x04
    249e:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    24a0:	8f 81       	ldd	r24, Y+7	; 0x07
    24a2:	98 85       	ldd	r25, Y+8	; 0x08
    24a4:	2e 85       	ldd	r18, Y+14	; 0x0e
    24a6:	3f 85       	ldd	r19, Y+15	; 0x0f
    24a8:	48 89       	ldd	r20, Y+16	; 0x10
    24aa:	59 89       	ldd	r21, Y+17	; 0x11
    24ac:	eb 81       	ldd	r30, Y+3	; 0x03
    24ae:	fc 81       	ldd	r31, Y+4	; 0x04
    24b0:	a9 81       	ldd	r26, Y+1	; 0x01
    24b2:	ba 81       	ldd	r27, Y+2	; 0x02
    24b4:	b9 01       	movw	r22, r18
    24b6:	9f 01       	movw	r18, r30
    24b8:	8d 01       	movw	r16, r26
    24ba:	0e 94 18 13 	call	0x2630	; 0x2630 <prvWriteMessageToBuffer>
    24be:	9e 83       	std	Y+6, r25	; 0x06
    24c0:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    24c2:	8d 81       	ldd	r24, Y+5	; 0x05
    24c4:	9e 81       	ldd	r25, Y+6	; 0x06
    24c6:	00 97       	sbiw	r24, 0x00	; 0
    24c8:	39 f1       	breq	.+78     	; 0x2518 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    24ca:	8f 81       	ldd	r24, Y+7	; 0x07
    24cc:	98 85       	ldd	r25, Y+8	; 0x08
    24ce:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    24d2:	9c 01       	movw	r18, r24
    24d4:	ef 81       	ldd	r30, Y+7	; 0x07
    24d6:	f8 85       	ldd	r31, Y+8	; 0x08
    24d8:	86 81       	ldd	r24, Z+6	; 0x06
    24da:	97 81       	ldd	r25, Z+7	; 0x07
    24dc:	28 17       	cp	r18, r24
    24de:	39 07       	cpc	r19, r25
    24e0:	d8 f0       	brcs	.+54     	; 0x2518 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    24e2:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
    24e6:	ef 81       	ldd	r30, Y+7	; 0x07
    24e8:	f8 85       	ldd	r31, Y+8	; 0x08
    24ea:	80 85       	ldd	r24, Z+8	; 0x08
    24ec:	91 85       	ldd	r25, Z+9	; 0x09
    24ee:	00 97       	sbiw	r24, 0x00	; 0
    24f0:	89 f0       	breq	.+34     	; 0x2514 <xStreamBufferSend+0x16e>
    24f2:	ef 81       	ldd	r30, Y+7	; 0x07
    24f4:	f8 85       	ldd	r31, Y+8	; 0x08
    24f6:	80 85       	ldd	r24, Z+8	; 0x08
    24f8:	91 85       	ldd	r25, Z+9	; 0x09
    24fa:	40 e0       	ldi	r20, 0x00	; 0
    24fc:	50 e0       	ldi	r21, 0x00	; 0
    24fe:	60 e0       	ldi	r22, 0x00	; 0
    2500:	70 e0       	ldi	r23, 0x00	; 0
    2502:	20 e0       	ldi	r18, 0x00	; 0
    2504:	00 e0       	ldi	r16, 0x00	; 0
    2506:	10 e0       	ldi	r17, 0x00	; 0
    2508:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <xTaskGenericNotify>
    250c:	ef 81       	ldd	r30, Y+7	; 0x07
    250e:	f8 85       	ldd	r31, Y+8	; 0x08
    2510:	11 86       	std	Z+9, r1	; 0x09
    2512:	10 86       	std	Z+8, r1	; 0x08
    2514:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2518:	8d 81       	ldd	r24, Y+5	; 0x05
    251a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    251c:	63 96       	adiw	r28, 0x13	; 19
    251e:	0f b6       	in	r0, 0x3f	; 63
    2520:	f8 94       	cli
    2522:	de bf       	out	0x3e, r29	; 62
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	cd bf       	out	0x3d, r28	; 61
    2528:	cf 91       	pop	r28
    252a:	df 91       	pop	r29
    252c:	1f 91       	pop	r17
    252e:	0f 91       	pop	r16
    2530:	ff 90       	pop	r15
    2532:	ef 90       	pop	r14
    2534:	08 95       	ret

00002536 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2536:	ef 92       	push	r14
    2538:	ff 92       	push	r15
    253a:	0f 93       	push	r16
    253c:	1f 93       	push	r17
    253e:	df 93       	push	r29
    2540:	cf 93       	push	r28
    2542:	cd b7       	in	r28, 0x3d	; 61
    2544:	de b7       	in	r29, 0x3e	; 62
    2546:	61 97       	sbiw	r28, 0x11	; 17
    2548:	0f b6       	in	r0, 0x3f	; 63
    254a:	f8 94       	cli
    254c:	de bf       	out	0x3e, r29	; 62
    254e:	0f be       	out	0x3f, r0	; 63
    2550:	cd bf       	out	0x3d, r28	; 61
    2552:	9b 87       	std	Y+11, r25	; 0x0b
    2554:	8a 87       	std	Y+10, r24	; 0x0a
    2556:	7d 87       	std	Y+13, r23	; 0x0d
    2558:	6c 87       	std	Y+12, r22	; 0x0c
    255a:	5f 87       	std	Y+15, r21	; 0x0f
    255c:	4e 87       	std	Y+14, r20	; 0x0e
    255e:	39 8b       	std	Y+17, r19	; 0x11
    2560:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2562:	8a 85       	ldd	r24, Y+10	; 0x0a
    2564:	9b 85       	ldd	r25, Y+11	; 0x0b
    2566:	99 87       	std	Y+9, r25	; 0x09
    2568:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    256a:	8e 85       	ldd	r24, Y+14	; 0x0e
    256c:	9f 85       	ldd	r25, Y+15	; 0x0f
    256e:	9b 83       	std	Y+3, r25	; 0x03
    2570:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2572:	e8 85       	ldd	r30, Y+8	; 0x08
    2574:	f9 85       	ldd	r31, Y+9	; 0x09
    2576:	86 85       	ldd	r24, Z+14	; 0x0e
    2578:	88 2f       	mov	r24, r24
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	81 70       	andi	r24, 0x01	; 1
    257e:	90 70       	andi	r25, 0x00	; 0
    2580:	88 23       	and	r24, r24
    2582:	29 f0       	breq	.+10     	; 0x258e <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
    2586:	9b 81       	ldd	r25, Y+3	; 0x03
    2588:	02 96       	adiw	r24, 0x02	; 2
    258a:	9b 83       	std	Y+3, r25	; 0x03
    258c:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    258e:	88 85       	ldd	r24, Y+8	; 0x08
    2590:	99 85       	ldd	r25, Y+9	; 0x09
    2592:	0e 94 6f 11 	call	0x22de	; 0x22de <xStreamBufferSpacesAvailable>
    2596:	9d 83       	std	Y+5, r25	; 0x05
    2598:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    259a:	88 85       	ldd	r24, Y+8	; 0x08
    259c:	99 85       	ldd	r25, Y+9	; 0x09
    259e:	2c 85       	ldd	r18, Y+12	; 0x0c
    25a0:	3d 85       	ldd	r19, Y+13	; 0x0d
    25a2:	4e 85       	ldd	r20, Y+14	; 0x0e
    25a4:	5f 85       	ldd	r21, Y+15	; 0x0f
    25a6:	ec 81       	ldd	r30, Y+4	; 0x04
    25a8:	fd 81       	ldd	r31, Y+5	; 0x05
    25aa:	aa 81       	ldd	r26, Y+2	; 0x02
    25ac:	bb 81       	ldd	r27, Y+3	; 0x03
    25ae:	b9 01       	movw	r22, r18
    25b0:	9f 01       	movw	r18, r30
    25b2:	8d 01       	movw	r16, r26
    25b4:	0e 94 18 13 	call	0x2630	; 0x2630 <prvWriteMessageToBuffer>
    25b8:	9f 83       	std	Y+7, r25	; 0x07
    25ba:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    25bc:	8e 81       	ldd	r24, Y+6	; 0x06
    25be:	9f 81       	ldd	r25, Y+7	; 0x07
    25c0:	00 97       	sbiw	r24, 0x00	; 0
    25c2:	39 f1       	breq	.+78     	; 0x2612 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    25c4:	88 85       	ldd	r24, Y+8	; 0x08
    25c6:	99 85       	ldd	r25, Y+9	; 0x09
    25c8:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    25cc:	9c 01       	movw	r18, r24
    25ce:	e8 85       	ldd	r30, Y+8	; 0x08
    25d0:	f9 85       	ldd	r31, Y+9	; 0x09
    25d2:	86 81       	ldd	r24, Z+6	; 0x06
    25d4:	97 81       	ldd	r25, Z+7	; 0x07
    25d6:	28 17       	cp	r18, r24
    25d8:	39 07       	cpc	r19, r25
    25da:	d8 f0       	brcs	.+54     	; 0x2612 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    25dc:	19 82       	std	Y+1, r1	; 0x01
    25de:	e8 85       	ldd	r30, Y+8	; 0x08
    25e0:	f9 85       	ldd	r31, Y+9	; 0x09
    25e2:	80 85       	ldd	r24, Z+8	; 0x08
    25e4:	91 85       	ldd	r25, Z+9	; 0x09
    25e6:	00 97       	sbiw	r24, 0x00	; 0
    25e8:	a1 f0       	breq	.+40     	; 0x2612 <xStreamBufferSendFromISR+0xdc>
    25ea:	e8 85       	ldd	r30, Y+8	; 0x08
    25ec:	f9 85       	ldd	r31, Y+9	; 0x09
    25ee:	80 85       	ldd	r24, Z+8	; 0x08
    25f0:	91 85       	ldd	r25, Z+9	; 0x09
    25f2:	e8 89       	ldd	r30, Y+16	; 0x10
    25f4:	f9 89       	ldd	r31, Y+17	; 0x11
    25f6:	40 e0       	ldi	r20, 0x00	; 0
    25f8:	50 e0       	ldi	r21, 0x00	; 0
    25fa:	60 e0       	ldi	r22, 0x00	; 0
    25fc:	70 e0       	ldi	r23, 0x00	; 0
    25fe:	20 e0       	ldi	r18, 0x00	; 0
    2600:	00 e0       	ldi	r16, 0x00	; 0
    2602:	10 e0       	ldi	r17, 0x00	; 0
    2604:	7f 01       	movw	r14, r30
    2606:	0e 94 be 24 	call	0x497c	; 0x497c <xTaskGenericNotifyFromISR>
    260a:	e8 85       	ldd	r30, Y+8	; 0x08
    260c:	f9 85       	ldd	r31, Y+9	; 0x09
    260e:	11 86       	std	Z+9, r1	; 0x09
    2610:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2612:	8e 81       	ldd	r24, Y+6	; 0x06
    2614:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2616:	61 96       	adiw	r28, 0x11	; 17
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	f8 94       	cli
    261c:	de bf       	out	0x3e, r29	; 62
    261e:	0f be       	out	0x3f, r0	; 63
    2620:	cd bf       	out	0x3d, r28	; 61
    2622:	cf 91       	pop	r28
    2624:	df 91       	pop	r29
    2626:	1f 91       	pop	r17
    2628:	0f 91       	pop	r16
    262a:	ff 90       	pop	r15
    262c:	ef 90       	pop	r14
    262e:	08 95       	ret

00002630 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2630:	0f 93       	push	r16
    2632:	1f 93       	push	r17
    2634:	df 93       	push	r29
    2636:	cf 93       	push	r28
    2638:	cd b7       	in	r28, 0x3d	; 61
    263a:	de b7       	in	r29, 0x3e	; 62
    263c:	61 97       	sbiw	r28, 0x11	; 17
    263e:	0f b6       	in	r0, 0x3f	; 63
    2640:	f8 94       	cli
    2642:	de bf       	out	0x3e, r29	; 62
    2644:	0f be       	out	0x3f, r0	; 63
    2646:	cd bf       	out	0x3d, r28	; 61
    2648:	9d 83       	std	Y+5, r25	; 0x05
    264a:	8c 83       	std	Y+4, r24	; 0x04
    264c:	7f 83       	std	Y+7, r23	; 0x07
    264e:	6e 83       	std	Y+6, r22	; 0x06
    2650:	59 87       	std	Y+9, r21	; 0x09
    2652:	48 87       	std	Y+8, r20	; 0x08
    2654:	3b 87       	std	Y+11, r19	; 0x0b
    2656:	2a 87       	std	Y+10, r18	; 0x0a
    2658:	1d 87       	std	Y+13, r17	; 0x0d
    265a:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    265c:	8a 85       	ldd	r24, Y+10	; 0x0a
    265e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2660:	00 97       	sbiw	r24, 0x00	; 0
    2662:	11 f4       	brne	.+4      	; 0x2668 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2664:	1b 82       	std	Y+3, r1	; 0x03
    2666:	38 c0       	rjmp	.+112    	; 0x26d8 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2668:	ec 81       	ldd	r30, Y+4	; 0x04
    266a:	fd 81       	ldd	r31, Y+5	; 0x05
    266c:	86 85       	ldd	r24, Z+14	; 0x0e
    266e:	88 2f       	mov	r24, r24
    2670:	90 e0       	ldi	r25, 0x00	; 0
    2672:	81 70       	andi	r24, 0x01	; 1
    2674:	90 70       	andi	r25, 0x00	; 0
    2676:	00 97       	sbiw	r24, 0x00	; 0
    2678:	d1 f4       	brne	.+52     	; 0x26ae <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    267e:	28 85       	ldd	r18, Y+8	; 0x08
    2680:	39 85       	ldd	r19, Y+9	; 0x09
    2682:	39 8b       	std	Y+17, r19	; 0x11
    2684:	28 8b       	std	Y+16, r18	; 0x10
    2686:	8a 85       	ldd	r24, Y+10	; 0x0a
    2688:	9b 85       	ldd	r25, Y+11	; 0x0b
    268a:	9f 87       	std	Y+15, r25	; 0x0f
    268c:	8e 87       	std	Y+14, r24	; 0x0e
    268e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2690:	3f 85       	ldd	r19, Y+15	; 0x0f
    2692:	88 89       	ldd	r24, Y+16	; 0x10
    2694:	99 89       	ldd	r25, Y+17	; 0x11
    2696:	82 17       	cp	r24, r18
    2698:	93 07       	cpc	r25, r19
    269a:	20 f4       	brcc	.+8      	; 0x26a4 <prvWriteMessageToBuffer+0x74>
    269c:	28 89       	ldd	r18, Y+16	; 0x10
    269e:	39 89       	ldd	r19, Y+17	; 0x11
    26a0:	3f 87       	std	Y+15, r19	; 0x0f
    26a2:	2e 87       	std	Y+14, r18	; 0x0e
    26a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    26a6:	9f 85       	ldd	r25, Y+15	; 0x0f
    26a8:	99 87       	std	Y+9, r25	; 0x09
    26aa:	88 87       	std	Y+8, r24	; 0x08
    26ac:	15 c0       	rjmp	.+42     	; 0x26d8 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    26ae:	2a 85       	ldd	r18, Y+10	; 0x0a
    26b0:	3b 85       	ldd	r19, Y+11	; 0x0b
    26b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    26b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    26b6:	28 17       	cp	r18, r24
    26b8:	39 07       	cpc	r19, r25
    26ba:	68 f0       	brcs	.+26     	; 0x26d6 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    26bc:	81 e0       	ldi	r24, 0x01	; 1
    26be:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    26c0:	9e 01       	movw	r18, r28
    26c2:	28 5f       	subi	r18, 0xF8	; 248
    26c4:	3f 4f       	sbci	r19, 0xFF	; 255
    26c6:	8c 81       	ldd	r24, Y+4	; 0x04
    26c8:	9d 81       	ldd	r25, Y+5	; 0x05
    26ca:	b9 01       	movw	r22, r18
    26cc:	42 e0       	ldi	r20, 0x02	; 2
    26ce:	50 e0       	ldi	r21, 0x00	; 0
    26d0:	0e 94 65 16 	call	0x2cca	; 0x2cca <prvWriteBytesToBuffer>
    26d4:	01 c0       	rjmp	.+2      	; 0x26d8 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    26d6:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    26d8:	8b 81       	ldd	r24, Y+3	; 0x03
    26da:	88 23       	and	r24, r24
    26dc:	61 f0       	breq	.+24     	; 0x26f6 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    26de:	2e 81       	ldd	r18, Y+6	; 0x06
    26e0:	3f 81       	ldd	r19, Y+7	; 0x07
    26e2:	48 85       	ldd	r20, Y+8	; 0x08
    26e4:	59 85       	ldd	r21, Y+9	; 0x09
    26e6:	8c 81       	ldd	r24, Y+4	; 0x04
    26e8:	9d 81       	ldd	r25, Y+5	; 0x05
    26ea:	b9 01       	movw	r22, r18
    26ec:	0e 94 65 16 	call	0x2cca	; 0x2cca <prvWriteBytesToBuffer>
    26f0:	9a 83       	std	Y+2, r25	; 0x02
    26f2:	89 83       	std	Y+1, r24	; 0x01
    26f4:	02 c0       	rjmp	.+4      	; 0x26fa <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    26f6:	1a 82       	std	Y+2, r1	; 0x02
    26f8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    26fa:	89 81       	ldd	r24, Y+1	; 0x01
    26fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    26fe:	61 96       	adiw	r28, 0x11	; 17
    2700:	0f b6       	in	r0, 0x3f	; 63
    2702:	f8 94       	cli
    2704:	de bf       	out	0x3e, r29	; 62
    2706:	0f be       	out	0x3f, r0	; 63
    2708:	cd bf       	out	0x3d, r28	; 61
    270a:	cf 91       	pop	r28
    270c:	df 91       	pop	r29
    270e:	1f 91       	pop	r17
    2710:	0f 91       	pop	r16
    2712:	08 95       	ret

00002714 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    2714:	ef 92       	push	r14
    2716:	ff 92       	push	r15
    2718:	0f 93       	push	r16
    271a:	1f 93       	push	r17
    271c:	df 93       	push	r29
    271e:	cf 93       	push	r28
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
    2724:	60 97       	sbiw	r28, 0x10	; 16
    2726:	0f b6       	in	r0, 0x3f	; 63
    2728:	f8 94       	cli
    272a:	de bf       	out	0x3e, r29	; 62
    272c:	0f be       	out	0x3f, r0	; 63
    272e:	cd bf       	out	0x3d, r28	; 61
    2730:	9a 87       	std	Y+10, r25	; 0x0a
    2732:	89 87       	std	Y+9, r24	; 0x09
    2734:	7c 87       	std	Y+12, r23	; 0x0c
    2736:	6b 87       	std	Y+11, r22	; 0x0b
    2738:	5e 87       	std	Y+14, r21	; 0x0e
    273a:	4d 87       	std	Y+13, r20	; 0x0d
    273c:	38 8b       	std	Y+16, r19	; 0x10
    273e:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2740:	89 85       	ldd	r24, Y+9	; 0x09
    2742:	9a 85       	ldd	r25, Y+10	; 0x0a
    2744:	98 87       	std	Y+8, r25	; 0x08
    2746:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2748:	1e 82       	std	Y+6, r1	; 0x06
    274a:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    274c:	ef 81       	ldd	r30, Y+7	; 0x07
    274e:	f8 85       	ldd	r31, Y+8	; 0x08
    2750:	86 85       	ldd	r24, Z+14	; 0x0e
    2752:	88 2f       	mov	r24, r24
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	81 70       	andi	r24, 0x01	; 1
    2758:	90 70       	andi	r25, 0x00	; 0
    275a:	88 23       	and	r24, r24
    275c:	29 f0       	breq	.+10     	; 0x2768 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    275e:	82 e0       	ldi	r24, 0x02	; 2
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	9a 83       	std	Y+2, r25	; 0x02
    2764:	89 83       	std	Y+1, r24	; 0x01
    2766:	02 c0       	rjmp	.+4      	; 0x276c <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2768:	1a 82       	std	Y+2, r1	; 0x02
    276a:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    276c:	8f 85       	ldd	r24, Y+15	; 0x0f
    276e:	98 89       	ldd	r25, Y+16	; 0x10
    2770:	00 97       	sbiw	r24, 0x00	; 0
    2772:	09 f4       	brne	.+2      	; 0x2776 <xStreamBufferReceive+0x62>
    2774:	3d c0       	rjmp	.+122    	; 0x27f0 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    2776:	0f b6       	in	r0, 0x3f	; 63
    2778:	f8 94       	cli
    277a:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    277c:	8f 81       	ldd	r24, Y+7	; 0x07
    277e:	98 85       	ldd	r25, Y+8	; 0x08
    2780:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    2784:	9c 83       	std	Y+4, r25	; 0x04
    2786:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    2788:	2b 81       	ldd	r18, Y+3	; 0x03
    278a:	3c 81       	ldd	r19, Y+4	; 0x04
    278c:	89 81       	ldd	r24, Y+1	; 0x01
    278e:	9a 81       	ldd	r25, Y+2	; 0x02
    2790:	82 17       	cp	r24, r18
    2792:	93 07       	cpc	r25, r19
    2794:	50 f0       	brcs	.+20     	; 0x27aa <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    2796:	80 e0       	ldi	r24, 0x00	; 0
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 3c 26 	call	0x4c78	; 0x4c78 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    279e:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <xTaskGetCurrentTaskHandle>
    27a2:	ef 81       	ldd	r30, Y+7	; 0x07
    27a4:	f8 85       	ldd	r31, Y+8	; 0x08
    27a6:	91 87       	std	Z+9, r25	; 0x09
    27a8:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    27aa:	0f 90       	pop	r0
    27ac:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    27ae:	2b 81       	ldd	r18, Y+3	; 0x03
    27b0:	3c 81       	ldd	r19, Y+4	; 0x04
    27b2:	89 81       	ldd	r24, Y+1	; 0x01
    27b4:	9a 81       	ldd	r25, Y+2	; 0x02
    27b6:	82 17       	cp	r24, r18
    27b8:	93 07       	cpc	r25, r19
    27ba:	00 f1       	brcs	.+64     	; 0x27fc <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    27bc:	ef 85       	ldd	r30, Y+15	; 0x0f
    27be:	f8 89       	ldd	r31, Y+16	; 0x10
    27c0:	60 e0       	ldi	r22, 0x00	; 0
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	80 e0       	ldi	r24, 0x00	; 0
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	20 e0       	ldi	r18, 0x00	; 0
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	40 e0       	ldi	r20, 0x00	; 0
    27ce:	50 e0       	ldi	r21, 0x00	; 0
    27d0:	00 e0       	ldi	r16, 0x00	; 0
    27d2:	10 e0       	ldi	r17, 0x00	; 0
    27d4:	7f 01       	movw	r14, r30
    27d6:	0e 94 45 23 	call	0x468a	; 0x468a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    27da:	ef 81       	ldd	r30, Y+7	; 0x07
    27dc:	f8 85       	ldd	r31, Y+8	; 0x08
    27de:	11 86       	std	Z+9, r1	; 0x09
    27e0:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    27e2:	8f 81       	ldd	r24, Y+7	; 0x07
    27e4:	98 85       	ldd	r25, Y+8	; 0x08
    27e6:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    27ea:	9c 83       	std	Y+4, r25	; 0x04
    27ec:	8b 83       	std	Y+3, r24	; 0x03
    27ee:	06 c0       	rjmp	.+12     	; 0x27fc <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    27f0:	8f 81       	ldd	r24, Y+7	; 0x07
    27f2:	98 85       	ldd	r25, Y+8	; 0x08
    27f4:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    27f8:	9c 83       	std	Y+4, r25	; 0x04
    27fa:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    27fc:	2b 81       	ldd	r18, Y+3	; 0x03
    27fe:	3c 81       	ldd	r19, Y+4	; 0x04
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	82 17       	cp	r24, r18
    2806:	93 07       	cpc	r25, r19
    2808:	80 f5       	brcc	.+96     	; 0x286a <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    280a:	8f 81       	ldd	r24, Y+7	; 0x07
    280c:	98 85       	ldd	r25, Y+8	; 0x08
    280e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2810:	3c 85       	ldd	r19, Y+12	; 0x0c
    2812:	4d 85       	ldd	r20, Y+13	; 0x0d
    2814:	5e 85       	ldd	r21, Y+14	; 0x0e
    2816:	eb 81       	ldd	r30, Y+3	; 0x03
    2818:	fc 81       	ldd	r31, Y+4	; 0x04
    281a:	a9 81       	ldd	r26, Y+1	; 0x01
    281c:	ba 81       	ldd	r27, Y+2	; 0x02
    281e:	b9 01       	movw	r22, r18
    2820:	9f 01       	movw	r18, r30
    2822:	8d 01       	movw	r16, r26
    2824:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <prvReadMessageFromBuffer>
    2828:	9e 83       	std	Y+6, r25	; 0x06
    282a:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    282c:	8d 81       	ldd	r24, Y+5	; 0x05
    282e:	9e 81       	ldd	r25, Y+6	; 0x06
    2830:	00 97       	sbiw	r24, 0x00	; 0
    2832:	d9 f0       	breq	.+54     	; 0x286a <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    2834:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
    2838:	ef 81       	ldd	r30, Y+7	; 0x07
    283a:	f8 85       	ldd	r31, Y+8	; 0x08
    283c:	82 85       	ldd	r24, Z+10	; 0x0a
    283e:	93 85       	ldd	r25, Z+11	; 0x0b
    2840:	00 97       	sbiw	r24, 0x00	; 0
    2842:	89 f0       	breq	.+34     	; 0x2866 <xStreamBufferReceive+0x152>
    2844:	ef 81       	ldd	r30, Y+7	; 0x07
    2846:	f8 85       	ldd	r31, Y+8	; 0x08
    2848:	82 85       	ldd	r24, Z+10	; 0x0a
    284a:	93 85       	ldd	r25, Z+11	; 0x0b
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	50 e0       	ldi	r21, 0x00	; 0
    2850:	60 e0       	ldi	r22, 0x00	; 0
    2852:	70 e0       	ldi	r23, 0x00	; 0
    2854:	20 e0       	ldi	r18, 0x00	; 0
    2856:	00 e0       	ldi	r16, 0x00	; 0
    2858:	10 e0       	ldi	r17, 0x00	; 0
    285a:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <xTaskGenericNotify>
    285e:	ef 81       	ldd	r30, Y+7	; 0x07
    2860:	f8 85       	ldd	r31, Y+8	; 0x08
    2862:	13 86       	std	Z+11, r1	; 0x0b
    2864:	12 86       	std	Z+10, r1	; 0x0a
    2866:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    286a:	8d 81       	ldd	r24, Y+5	; 0x05
    286c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    286e:	60 96       	adiw	r28, 0x10	; 16
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	cf 91       	pop	r28
    287c:	df 91       	pop	r29
    287e:	1f 91       	pop	r17
    2880:	0f 91       	pop	r16
    2882:	ff 90       	pop	r15
    2884:	ef 90       	pop	r14
    2886:	08 95       	ret

00002888 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2888:	df 93       	push	r29
    288a:	cf 93       	push	r28
    288c:	cd b7       	in	r28, 0x3d	; 61
    288e:	de b7       	in	r29, 0x3e	; 62
    2890:	2c 97       	sbiw	r28, 0x0c	; 12
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	de bf       	out	0x3e, r29	; 62
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	cd bf       	out	0x3d, r28	; 61
    289c:	9c 87       	std	Y+12, r25	; 0x0c
    289e:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    28a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    28a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    28a4:	98 87       	std	Y+8, r25	; 0x08
    28a6:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    28a8:	ef 81       	ldd	r30, Y+7	; 0x07
    28aa:	f8 85       	ldd	r31, Y+8	; 0x08
    28ac:	86 85       	ldd	r24, Z+14	; 0x0e
    28ae:	88 2f       	mov	r24, r24
    28b0:	90 e0       	ldi	r25, 0x00	; 0
    28b2:	81 70       	andi	r24, 0x01	; 1
    28b4:	90 70       	andi	r25, 0x00	; 0
    28b6:	88 23       	and	r24, r24
    28b8:	61 f1       	breq	.+88     	; 0x2912 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    28ba:	8f 81       	ldd	r24, Y+7	; 0x07
    28bc:	98 85       	ldd	r25, Y+8	; 0x08
    28be:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    28c2:	9c 83       	std	Y+4, r25	; 0x04
    28c4:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	83 30       	cpi	r24, 0x03	; 3
    28cc:	91 05       	cpc	r25, r1
    28ce:	f0 f0       	brcs	.+60     	; 0x290c <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    28d0:	ef 81       	ldd	r30, Y+7	; 0x07
    28d2:	f8 85       	ldd	r31, Y+8	; 0x08
    28d4:	80 81       	ld	r24, Z
    28d6:	91 81       	ldd	r25, Z+1	; 0x01
    28d8:	9a 83       	std	Y+2, r25	; 0x02
    28da:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    28dc:	9e 01       	movw	r18, r28
    28de:	27 5f       	subi	r18, 0xF7	; 247
    28e0:	3f 4f       	sbci	r19, 0xFF	; 255
    28e2:	8f 81       	ldd	r24, Y+7	; 0x07
    28e4:	98 85       	ldd	r25, Y+8	; 0x08
    28e6:	eb 81       	ldd	r30, Y+3	; 0x03
    28e8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ea:	b9 01       	movw	r22, r18
    28ec:	42 e0       	ldi	r20, 0x02	; 2
    28ee:	50 e0       	ldi	r21, 0x00	; 0
    28f0:	9f 01       	movw	r18, r30
    28f2:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    28f6:	89 85       	ldd	r24, Y+9	; 0x09
    28f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    28fa:	9e 83       	std	Y+6, r25	; 0x06
    28fc:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    28fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2900:	f8 85       	ldd	r31, Y+8	; 0x08
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	9a 81       	ldd	r25, Y+2	; 0x02
    2906:	91 83       	std	Z+1, r25	; 0x01
    2908:	80 83       	st	Z, r24
    290a:	05 c0       	rjmp	.+10     	; 0x2916 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    290c:	1e 82       	std	Y+6, r1	; 0x06
    290e:	1d 82       	std	Y+5, r1	; 0x05
    2910:	02 c0       	rjmp	.+4      	; 0x2916 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    2912:	1e 82       	std	Y+6, r1	; 0x06
    2914:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2916:	8d 81       	ldd	r24, Y+5	; 0x05
    2918:	9e 81       	ldd	r25, Y+6	; 0x06
}
    291a:	2c 96       	adiw	r28, 0x0c	; 12
    291c:	0f b6       	in	r0, 0x3f	; 63
    291e:	f8 94       	cli
    2920:	de bf       	out	0x3e, r29	; 62
    2922:	0f be       	out	0x3f, r0	; 63
    2924:	cd bf       	out	0x3d, r28	; 61
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	08 95       	ret

0000292c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    292c:	ef 92       	push	r14
    292e:	ff 92       	push	r15
    2930:	0f 93       	push	r16
    2932:	1f 93       	push	r17
    2934:	df 93       	push	r29
    2936:	cf 93       	push	r28
    2938:	cd b7       	in	r28, 0x3d	; 61
    293a:	de b7       	in	r29, 0x3e	; 62
    293c:	61 97       	sbiw	r28, 0x11	; 17
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	de bf       	out	0x3e, r29	; 62
    2944:	0f be       	out	0x3f, r0	; 63
    2946:	cd bf       	out	0x3d, r28	; 61
    2948:	9b 87       	std	Y+11, r25	; 0x0b
    294a:	8a 87       	std	Y+10, r24	; 0x0a
    294c:	7d 87       	std	Y+13, r23	; 0x0d
    294e:	6c 87       	std	Y+12, r22	; 0x0c
    2950:	5f 87       	std	Y+15, r21	; 0x0f
    2952:	4e 87       	std	Y+14, r20	; 0x0e
    2954:	39 8b       	std	Y+17, r19	; 0x11
    2956:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2958:	8a 85       	ldd	r24, Y+10	; 0x0a
    295a:	9b 85       	ldd	r25, Y+11	; 0x0b
    295c:	99 87       	std	Y+9, r25	; 0x09
    295e:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2960:	1f 82       	std	Y+7, r1	; 0x07
    2962:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2964:	e8 85       	ldd	r30, Y+8	; 0x08
    2966:	f9 85       	ldd	r31, Y+9	; 0x09
    2968:	86 85       	ldd	r24, Z+14	; 0x0e
    296a:	88 2f       	mov	r24, r24
    296c:	90 e0       	ldi	r25, 0x00	; 0
    296e:	81 70       	andi	r24, 0x01	; 1
    2970:	90 70       	andi	r25, 0x00	; 0
    2972:	88 23       	and	r24, r24
    2974:	29 f0       	breq	.+10     	; 0x2980 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2976:	82 e0       	ldi	r24, 0x02	; 2
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	9b 83       	std	Y+3, r25	; 0x03
    297c:	8a 83       	std	Y+2, r24	; 0x02
    297e:	02 c0       	rjmp	.+4      	; 0x2984 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2980:	1b 82       	std	Y+3, r1	; 0x03
    2982:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2984:	88 85       	ldd	r24, Y+8	; 0x08
    2986:	99 85       	ldd	r25, Y+9	; 0x09
    2988:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvBytesInBuffer>
    298c:	9d 83       	std	Y+5, r25	; 0x05
    298e:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2990:	2c 81       	ldd	r18, Y+4	; 0x04
    2992:	3d 81       	ldd	r19, Y+5	; 0x05
    2994:	8a 81       	ldd	r24, Y+2	; 0x02
    2996:	9b 81       	ldd	r25, Y+3	; 0x03
    2998:	82 17       	cp	r24, r18
    299a:	93 07       	cpc	r25, r19
    299c:	80 f5       	brcc	.+96     	; 0x29fe <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    299e:	88 85       	ldd	r24, Y+8	; 0x08
    29a0:	99 85       	ldd	r25, Y+9	; 0x09
    29a2:	2c 85       	ldd	r18, Y+12	; 0x0c
    29a4:	3d 85       	ldd	r19, Y+13	; 0x0d
    29a6:	4e 85       	ldd	r20, Y+14	; 0x0e
    29a8:	5f 85       	ldd	r21, Y+15	; 0x0f
    29aa:	ec 81       	ldd	r30, Y+4	; 0x04
    29ac:	fd 81       	ldd	r31, Y+5	; 0x05
    29ae:	aa 81       	ldd	r26, Y+2	; 0x02
    29b0:	bb 81       	ldd	r27, Y+3	; 0x03
    29b2:	b9 01       	movw	r22, r18
    29b4:	9f 01       	movw	r18, r30
    29b6:	8d 01       	movw	r16, r26
    29b8:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <prvReadMessageFromBuffer>
    29bc:	9f 83       	std	Y+7, r25	; 0x07
    29be:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    29c0:	8e 81       	ldd	r24, Y+6	; 0x06
    29c2:	9f 81       	ldd	r25, Y+7	; 0x07
    29c4:	00 97       	sbiw	r24, 0x00	; 0
    29c6:	d9 f0       	breq	.+54     	; 0x29fe <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    29c8:	19 82       	std	Y+1, r1	; 0x01
    29ca:	e8 85       	ldd	r30, Y+8	; 0x08
    29cc:	f9 85       	ldd	r31, Y+9	; 0x09
    29ce:	82 85       	ldd	r24, Z+10	; 0x0a
    29d0:	93 85       	ldd	r25, Z+11	; 0x0b
    29d2:	00 97       	sbiw	r24, 0x00	; 0
    29d4:	a1 f0       	breq	.+40     	; 0x29fe <xStreamBufferReceiveFromISR+0xd2>
    29d6:	e8 85       	ldd	r30, Y+8	; 0x08
    29d8:	f9 85       	ldd	r31, Y+9	; 0x09
    29da:	82 85       	ldd	r24, Z+10	; 0x0a
    29dc:	93 85       	ldd	r25, Z+11	; 0x0b
    29de:	e8 89       	ldd	r30, Y+16	; 0x10
    29e0:	f9 89       	ldd	r31, Y+17	; 0x11
    29e2:	40 e0       	ldi	r20, 0x00	; 0
    29e4:	50 e0       	ldi	r21, 0x00	; 0
    29e6:	60 e0       	ldi	r22, 0x00	; 0
    29e8:	70 e0       	ldi	r23, 0x00	; 0
    29ea:	20 e0       	ldi	r18, 0x00	; 0
    29ec:	00 e0       	ldi	r16, 0x00	; 0
    29ee:	10 e0       	ldi	r17, 0x00	; 0
    29f0:	7f 01       	movw	r14, r30
    29f2:	0e 94 be 24 	call	0x497c	; 0x497c <xTaskGenericNotifyFromISR>
    29f6:	e8 85       	ldd	r30, Y+8	; 0x08
    29f8:	f9 85       	ldd	r31, Y+9	; 0x09
    29fa:	13 86       	std	Z+11, r1	; 0x0b
    29fc:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    29fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2a00:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2a02:	61 96       	adiw	r28, 0x11	; 17
    2a04:	0f b6       	in	r0, 0x3f	; 63
    2a06:	f8 94       	cli
    2a08:	de bf       	out	0x3e, r29	; 62
    2a0a:	0f be       	out	0x3f, r0	; 63
    2a0c:	cd bf       	out	0x3d, r28	; 61
    2a0e:	cf 91       	pop	r28
    2a10:	df 91       	pop	r29
    2a12:	1f 91       	pop	r17
    2a14:	0f 91       	pop	r16
    2a16:	ff 90       	pop	r15
    2a18:	ef 90       	pop	r14
    2a1a:	08 95       	ret

00002a1c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    2a1c:	0f 93       	push	r16
    2a1e:	1f 93       	push	r17
    2a20:	df 93       	push	r29
    2a22:	cf 93       	push	r28
    2a24:	cd b7       	in	r28, 0x3d	; 61
    2a26:	de b7       	in	r29, 0x3e	; 62
    2a28:	62 97       	sbiw	r28, 0x12	; 18
    2a2a:	0f b6       	in	r0, 0x3f	; 63
    2a2c:	f8 94       	cli
    2a2e:	de bf       	out	0x3e, r29	; 62
    2a30:	0f be       	out	0x3f, r0	; 63
    2a32:	cd bf       	out	0x3d, r28	; 61
    2a34:	9a 87       	std	Y+10, r25	; 0x0a
    2a36:	89 87       	std	Y+9, r24	; 0x09
    2a38:	7c 87       	std	Y+12, r23	; 0x0c
    2a3a:	6b 87       	std	Y+11, r22	; 0x0b
    2a3c:	5e 87       	std	Y+14, r21	; 0x0e
    2a3e:	4d 87       	std	Y+13, r20	; 0x0d
    2a40:	38 8b       	std	Y+16, r19	; 0x10
    2a42:	2f 87       	std	Y+15, r18	; 0x0f
    2a44:	1a 8b       	std	Y+18, r17	; 0x12
    2a46:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    2a48:	89 89       	ldd	r24, Y+17	; 0x11
    2a4a:	9a 89       	ldd	r25, Y+18	; 0x12
    2a4c:	00 97       	sbiw	r24, 0x00	; 0
    2a4e:	91 f1       	breq	.+100    	; 0x2ab4 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    2a50:	e9 85       	ldd	r30, Y+9	; 0x09
    2a52:	fa 85       	ldd	r31, Y+10	; 0x0a
    2a54:	80 81       	ld	r24, Z
    2a56:	91 81       	ldd	r25, Z+1	; 0x01
    2a58:	9e 83       	std	Y+6, r25	; 0x06
    2a5a:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    2a5c:	ae 01       	movw	r20, r28
    2a5e:	49 5f       	subi	r20, 0xF9	; 249
    2a60:	5f 4f       	sbci	r21, 0xFF	; 255
    2a62:	89 85       	ldd	r24, Y+9	; 0x09
    2a64:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a66:	29 89       	ldd	r18, Y+17	; 0x11
    2a68:	3a 89       	ldd	r19, Y+18	; 0x12
    2a6a:	ef 85       	ldd	r30, Y+15	; 0x0f
    2a6c:	f8 89       	ldd	r31, Y+16	; 0x10
    2a6e:	ba 01       	movw	r22, r20
    2a70:	a9 01       	movw	r20, r18
    2a72:	9f 01       	movw	r18, r30
    2a74:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2a78:	8f 81       	ldd	r24, Y+7	; 0x07
    2a7a:	98 85       	ldd	r25, Y+8	; 0x08
    2a7c:	9a 83       	std	Y+2, r25	; 0x02
    2a7e:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    2a80:	2f 85       	ldd	r18, Y+15	; 0x0f
    2a82:	38 89       	ldd	r19, Y+16	; 0x10
    2a84:	89 89       	ldd	r24, Y+17	; 0x11
    2a86:	9a 89       	ldd	r25, Y+18	; 0x12
    2a88:	a9 01       	movw	r20, r18
    2a8a:	48 1b       	sub	r20, r24
    2a8c:	59 0b       	sbc	r21, r25
    2a8e:	ca 01       	movw	r24, r20
    2a90:	98 8b       	std	Y+16, r25	; 0x10
    2a92:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    2a94:	29 81       	ldd	r18, Y+1	; 0x01
    2a96:	3a 81       	ldd	r19, Y+2	; 0x02
    2a98:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a9c:	82 17       	cp	r24, r18
    2a9e:	93 07       	cpc	r25, r19
    2aa0:	68 f4       	brcc	.+26     	; 0x2abc <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    2aa2:	e9 85       	ldd	r30, Y+9	; 0x09
    2aa4:	fa 85       	ldd	r31, Y+10	; 0x0a
    2aa6:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa8:	9e 81       	ldd	r25, Y+6	; 0x06
    2aaa:	91 83       	std	Z+1, r25	; 0x01
    2aac:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    2aae:	1a 82       	std	Y+2, r1	; 0x02
    2ab0:	19 82       	std	Y+1, r1	; 0x01
    2ab2:	04 c0       	rjmp	.+8      	; 0x2abc <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    2ab4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ab6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ab8:	9a 83       	std	Y+2, r25	; 0x02
    2aba:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2abc:	4b 85       	ldd	r20, Y+11	; 0x0b
    2abe:	5c 85       	ldd	r21, Y+12	; 0x0c
    2ac0:	89 85       	ldd	r24, Y+9	; 0x09
    2ac2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ac4:	29 81       	ldd	r18, Y+1	; 0x01
    2ac6:	3a 81       	ldd	r19, Y+2	; 0x02
    2ac8:	ef 85       	ldd	r30, Y+15	; 0x0f
    2aca:	f8 89       	ldd	r31, Y+16	; 0x10
    2acc:	ba 01       	movw	r22, r20
    2ace:	a9 01       	movw	r20, r18
    2ad0:	9f 01       	movw	r18, r30
    2ad2:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <prvReadBytesFromBuffer>
    2ad6:	9c 83       	std	Y+4, r25	; 0x04
    2ad8:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    2ada:	8b 81       	ldd	r24, Y+3	; 0x03
    2adc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2ade:	62 96       	adiw	r28, 0x12	; 18
    2ae0:	0f b6       	in	r0, 0x3f	; 63
    2ae2:	f8 94       	cli
    2ae4:	de bf       	out	0x3e, r29	; 62
    2ae6:	0f be       	out	0x3f, r0	; 63
    2ae8:	cd bf       	out	0x3d, r28	; 61
    2aea:	cf 91       	pop	r28
    2aec:	df 91       	pop	r29
    2aee:	1f 91       	pop	r17
    2af0:	0f 91       	pop	r16
    2af2:	08 95       	ret

00002af4 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2af4:	df 93       	push	r29
    2af6:	cf 93       	push	r28
    2af8:	cd b7       	in	r28, 0x3d	; 61
    2afa:	de b7       	in	r29, 0x3e	; 62
    2afc:	27 97       	sbiw	r28, 0x07	; 7
    2afe:	0f b6       	in	r0, 0x3f	; 63
    2b00:	f8 94       	cli
    2b02:	de bf       	out	0x3e, r29	; 62
    2b04:	0f be       	out	0x3f, r0	; 63
    2b06:	cd bf       	out	0x3d, r28	; 61
    2b08:	9f 83       	std	Y+7, r25	; 0x07
    2b0a:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b0c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b0e:	9f 81       	ldd	r25, Y+7	; 0x07
    2b10:	9d 83       	std	Y+5, r25	; 0x05
    2b12:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    2b14:	ec 81       	ldd	r30, Y+4	; 0x04
    2b16:	fd 81       	ldd	r31, Y+5	; 0x05
    2b18:	80 81       	ld	r24, Z
    2b1a:	91 81       	ldd	r25, Z+1	; 0x01
    2b1c:	9a 83       	std	Y+2, r25	; 0x02
    2b1e:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    2b20:	ec 81       	ldd	r30, Y+4	; 0x04
    2b22:	fd 81       	ldd	r31, Y+5	; 0x05
    2b24:	22 81       	ldd	r18, Z+2	; 0x02
    2b26:	33 81       	ldd	r19, Z+3	; 0x03
    2b28:	89 81       	ldd	r24, Y+1	; 0x01
    2b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b2c:	28 17       	cp	r18, r24
    2b2e:	39 07       	cpc	r19, r25
    2b30:	19 f4       	brne	.+6      	; 0x2b38 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	8b 83       	std	Y+3, r24	; 0x03
    2b36:	01 c0       	rjmp	.+2      	; 0x2b3a <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    2b38:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2b3a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2b3c:	27 96       	adiw	r28, 0x07	; 7
    2b3e:	0f b6       	in	r0, 0x3f	; 63
    2b40:	f8 94       	cli
    2b42:	de bf       	out	0x3e, r29	; 62
    2b44:	0f be       	out	0x3f, r0	; 63
    2b46:	cd bf       	out	0x3d, r28	; 61
    2b48:	cf 91       	pop	r28
    2b4a:	df 91       	pop	r29
    2b4c:	08 95       	ret

00002b4e <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2b4e:	df 93       	push	r29
    2b50:	cf 93       	push	r28
    2b52:	cd b7       	in	r28, 0x3d	; 61
    2b54:	de b7       	in	r29, 0x3e	; 62
    2b56:	27 97       	sbiw	r28, 0x07	; 7
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	9f 83       	std	Y+7, r25	; 0x07
    2b64:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b66:	8e 81       	ldd	r24, Y+6	; 0x06
    2b68:	9f 81       	ldd	r25, Y+7	; 0x07
    2b6a:	9a 83       	std	Y+2, r25	; 0x02
    2b6c:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b70:	fa 81       	ldd	r31, Y+2	; 0x02
    2b72:	86 85       	ldd	r24, Z+14	; 0x0e
    2b74:	88 2f       	mov	r24, r24
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	81 70       	andi	r24, 0x01	; 1
    2b7a:	90 70       	andi	r25, 0x00	; 0
    2b7c:	88 23       	and	r24, r24
    2b7e:	29 f0       	breq	.+10     	; 0x2b8a <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2b80:	82 e0       	ldi	r24, 0x02	; 2
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	9c 83       	std	Y+4, r25	; 0x04
    2b86:	8b 83       	std	Y+3, r24	; 0x03
    2b88:	02 c0       	rjmp	.+4      	; 0x2b8e <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2b8a:	1c 82       	std	Y+4, r1	; 0x04
    2b8c:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2b8e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b90:	9f 81       	ldd	r25, Y+7	; 0x07
    2b92:	0e 94 6f 11 	call	0x22de	; 0x22de <xStreamBufferSpacesAvailable>
    2b96:	9c 01       	movw	r18, r24
    2b98:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b9c:	82 17       	cp	r24, r18
    2b9e:	93 07       	cpc	r25, r19
    2ba0:	18 f0       	brcs	.+6      	; 0x2ba8 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	8d 83       	std	Y+5, r24	; 0x05
    2ba6:	01 c0       	rjmp	.+2      	; 0x2baa <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    2ba8:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2baa:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2bac:	27 96       	adiw	r28, 0x07	; 7
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	f8 94       	cli
    2bb2:	de bf       	out	0x3e, r29	; 62
    2bb4:	0f be       	out	0x3f, r0	; 63
    2bb6:	cd bf       	out	0x3d, r28	; 61
    2bb8:	cf 91       	pop	r28
    2bba:	df 91       	pop	r29
    2bbc:	08 95       	ret

00002bbe <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2bbe:	ef 92       	push	r14
    2bc0:	ff 92       	push	r15
    2bc2:	0f 93       	push	r16
    2bc4:	1f 93       	push	r17
    2bc6:	df 93       	push	r29
    2bc8:	cf 93       	push	r28
    2bca:	cd b7       	in	r28, 0x3d	; 61
    2bcc:	de b7       	in	r29, 0x3e	; 62
    2bce:	28 97       	sbiw	r28, 0x08	; 8
    2bd0:	0f b6       	in	r0, 0x3f	; 63
    2bd2:	f8 94       	cli
    2bd4:	de bf       	out	0x3e, r29	; 62
    2bd6:	0f be       	out	0x3f, r0	; 63
    2bd8:	cd bf       	out	0x3d, r28	; 61
    2bda:	9e 83       	std	Y+6, r25	; 0x06
    2bdc:	8d 83       	std	Y+5, r24	; 0x05
    2bde:	78 87       	std	Y+8, r23	; 0x08
    2be0:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2be2:	8d 81       	ldd	r24, Y+5	; 0x05
    2be4:	9e 81       	ldd	r25, Y+6	; 0x06
    2be6:	9c 83       	std	Y+4, r25	; 0x04
    2be8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2bea:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2bec:	eb 81       	ldd	r30, Y+3	; 0x03
    2bee:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf0:	80 85       	ldd	r24, Z+8	; 0x08
    2bf2:	91 85       	ldd	r25, Z+9	; 0x09
    2bf4:	00 97       	sbiw	r24, 0x00	; 0
    2bf6:	b9 f0       	breq	.+46     	; 0x2c26 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfc:	80 85       	ldd	r24, Z+8	; 0x08
    2bfe:	91 85       	ldd	r25, Z+9	; 0x09
    2c00:	ef 81       	ldd	r30, Y+7	; 0x07
    2c02:	f8 85       	ldd	r31, Y+8	; 0x08
    2c04:	40 e0       	ldi	r20, 0x00	; 0
    2c06:	50 e0       	ldi	r21, 0x00	; 0
    2c08:	60 e0       	ldi	r22, 0x00	; 0
    2c0a:	70 e0       	ldi	r23, 0x00	; 0
    2c0c:	20 e0       	ldi	r18, 0x00	; 0
    2c0e:	00 e0       	ldi	r16, 0x00	; 0
    2c10:	10 e0       	ldi	r17, 0x00	; 0
    2c12:	7f 01       	movw	r14, r30
    2c14:	0e 94 be 24 	call	0x497c	; 0x497c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2c18:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1c:	11 86       	std	Z+9, r1	; 0x09
    2c1e:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	8a 83       	std	Y+2, r24	; 0x02
    2c24:	01 c0       	rjmp	.+2      	; 0x2c28 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2c26:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2c2a:	28 96       	adiw	r28, 0x08	; 8
    2c2c:	0f b6       	in	r0, 0x3f	; 63
    2c2e:	f8 94       	cli
    2c30:	de bf       	out	0x3e, r29	; 62
    2c32:	0f be       	out	0x3f, r0	; 63
    2c34:	cd bf       	out	0x3d, r28	; 61
    2c36:	cf 91       	pop	r28
    2c38:	df 91       	pop	r29
    2c3a:	1f 91       	pop	r17
    2c3c:	0f 91       	pop	r16
    2c3e:	ff 90       	pop	r15
    2c40:	ef 90       	pop	r14
    2c42:	08 95       	ret

00002c44 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2c44:	ef 92       	push	r14
    2c46:	ff 92       	push	r15
    2c48:	0f 93       	push	r16
    2c4a:	1f 93       	push	r17
    2c4c:	df 93       	push	r29
    2c4e:	cf 93       	push	r28
    2c50:	cd b7       	in	r28, 0x3d	; 61
    2c52:	de b7       	in	r29, 0x3e	; 62
    2c54:	28 97       	sbiw	r28, 0x08	; 8
    2c56:	0f b6       	in	r0, 0x3f	; 63
    2c58:	f8 94       	cli
    2c5a:	de bf       	out	0x3e, r29	; 62
    2c5c:	0f be       	out	0x3f, r0	; 63
    2c5e:	cd bf       	out	0x3d, r28	; 61
    2c60:	9e 83       	std	Y+6, r25	; 0x06
    2c62:	8d 83       	std	Y+5, r24	; 0x05
    2c64:	78 87       	std	Y+8, r23	; 0x08
    2c66:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c68:	8d 81       	ldd	r24, Y+5	; 0x05
    2c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c6c:	9c 83       	std	Y+4, r25	; 0x04
    2c6e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2c70:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2c72:	eb 81       	ldd	r30, Y+3	; 0x03
    2c74:	fc 81       	ldd	r31, Y+4	; 0x04
    2c76:	82 85       	ldd	r24, Z+10	; 0x0a
    2c78:	93 85       	ldd	r25, Z+11	; 0x0b
    2c7a:	00 97       	sbiw	r24, 0x00	; 0
    2c7c:	b9 f0       	breq	.+46     	; 0x2cac <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c80:	fc 81       	ldd	r31, Y+4	; 0x04
    2c82:	82 85       	ldd	r24, Z+10	; 0x0a
    2c84:	93 85       	ldd	r25, Z+11	; 0x0b
    2c86:	ef 81       	ldd	r30, Y+7	; 0x07
    2c88:	f8 85       	ldd	r31, Y+8	; 0x08
    2c8a:	40 e0       	ldi	r20, 0x00	; 0
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	60 e0       	ldi	r22, 0x00	; 0
    2c90:	70 e0       	ldi	r23, 0x00	; 0
    2c92:	20 e0       	ldi	r18, 0x00	; 0
    2c94:	00 e0       	ldi	r16, 0x00	; 0
    2c96:	10 e0       	ldi	r17, 0x00	; 0
    2c98:	7f 01       	movw	r14, r30
    2c9a:	0e 94 be 24 	call	0x497c	; 0x497c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	13 86       	std	Z+11, r1	; 0x0b
    2ca4:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	8a 83       	std	Y+2, r24	; 0x02
    2caa:	01 c0       	rjmp	.+2      	; 0x2cae <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2cac:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2cae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2cb0:	28 96       	adiw	r28, 0x08	; 8
    2cb2:	0f b6       	in	r0, 0x3f	; 63
    2cb4:	f8 94       	cli
    2cb6:	de bf       	out	0x3e, r29	; 62
    2cb8:	0f be       	out	0x3f, r0	; 63
    2cba:	cd bf       	out	0x3d, r28	; 61
    2cbc:	cf 91       	pop	r28
    2cbe:	df 91       	pop	r29
    2cc0:	1f 91       	pop	r17
    2cc2:	0f 91       	pop	r16
    2cc4:	ff 90       	pop	r15
    2cc6:	ef 90       	pop	r14
    2cc8:	08 95       	ret

00002cca <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    2cca:	df 93       	push	r29
    2ccc:	cf 93       	push	r28
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
    2cd2:	2e 97       	sbiw	r28, 0x0e	; 14
    2cd4:	0f b6       	in	r0, 0x3f	; 63
    2cd6:	f8 94       	cli
    2cd8:	de bf       	out	0x3e, r29	; 62
    2cda:	0f be       	out	0x3f, r0	; 63
    2cdc:	cd bf       	out	0x3d, r28	; 61
    2cde:	9e 83       	std	Y+6, r25	; 0x06
    2ce0:	8d 83       	std	Y+5, r24	; 0x05
    2ce2:	78 87       	std	Y+8, r23	; 0x08
    2ce4:	6f 83       	std	Y+7, r22	; 0x07
    2ce6:	5a 87       	std	Y+10, r21	; 0x0a
    2ce8:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    2cea:	ed 81       	ldd	r30, Y+5	; 0x05
    2cec:	fe 81       	ldd	r31, Y+6	; 0x06
    2cee:	82 81       	ldd	r24, Z+2	; 0x02
    2cf0:	93 81       	ldd	r25, Z+3	; 0x03
    2cf2:	9c 83       	std	Y+4, r25	; 0x04
    2cf4:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    2cf6:	ed 81       	ldd	r30, Y+5	; 0x05
    2cf8:	fe 81       	ldd	r31, Y+6	; 0x06
    2cfa:	24 81       	ldd	r18, Z+4	; 0x04
    2cfc:	35 81       	ldd	r19, Z+5	; 0x05
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	a9 01       	movw	r20, r18
    2d04:	48 1b       	sub	r20, r24
    2d06:	59 0b       	sbc	r21, r25
    2d08:	ca 01       	movw	r24, r20
    2d0a:	29 85       	ldd	r18, Y+9	; 0x09
    2d0c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d0e:	3e 87       	std	Y+14, r19	; 0x0e
    2d10:	2d 87       	std	Y+13, r18	; 0x0d
    2d12:	9c 87       	std	Y+12, r25	; 0x0c
    2d14:	8b 87       	std	Y+11, r24	; 0x0b
    2d16:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d18:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d1e:	84 17       	cp	r24, r20
    2d20:	95 07       	cpc	r25, r21
    2d22:	20 f4       	brcc	.+8      	; 0x2d2c <prvWriteBytesToBuffer+0x62>
    2d24:	2d 85       	ldd	r18, Y+13	; 0x0d
    2d26:	3e 85       	ldd	r19, Y+14	; 0x0e
    2d28:	3c 87       	std	Y+12, r19	; 0x0c
    2d2a:	2b 87       	std	Y+11, r18	; 0x0b
    2d2c:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d2e:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d30:	5a 83       	std	Y+2, r21	; 0x02
    2d32:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d34:	ed 81       	ldd	r30, Y+5	; 0x05
    2d36:	fe 81       	ldd	r31, Y+6	; 0x06
    2d38:	24 85       	ldd	r18, Z+12	; 0x0c
    2d3a:	35 85       	ldd	r19, Z+13	; 0x0d
    2d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d40:	82 0f       	add	r24, r18
    2d42:	93 1f       	adc	r25, r19
    2d44:	2f 81       	ldd	r18, Y+7	; 0x07
    2d46:	38 85       	ldd	r19, Y+8	; 0x08
    2d48:	49 81       	ldd	r20, Y+1	; 0x01
    2d4a:	5a 81       	ldd	r21, Y+2	; 0x02
    2d4c:	b9 01       	movw	r22, r18
    2d4e:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    2d52:	29 85       	ldd	r18, Y+9	; 0x09
    2d54:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d56:	89 81       	ldd	r24, Y+1	; 0x01
    2d58:	9a 81       	ldd	r25, Y+2	; 0x02
    2d5a:	82 17       	cp	r24, r18
    2d5c:	93 07       	cpc	r25, r19
    2d5e:	b0 f4       	brcc	.+44     	; 0x2d8c <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d60:	ed 81       	ldd	r30, Y+5	; 0x05
    2d62:	fe 81       	ldd	r31, Y+6	; 0x06
    2d64:	64 85       	ldd	r22, Z+12	; 0x0c
    2d66:	75 85       	ldd	r23, Z+13	; 0x0d
    2d68:	2f 81       	ldd	r18, Y+7	; 0x07
    2d6a:	38 85       	ldd	r19, Y+8	; 0x08
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d70:	a9 01       	movw	r20, r18
    2d72:	48 0f       	add	r20, r24
    2d74:	59 1f       	adc	r21, r25
    2d76:	29 85       	ldd	r18, Y+9	; 0x09
    2d78:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d7a:	89 81       	ldd	r24, Y+1	; 0x01
    2d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7e:	28 1b       	sub	r18, r24
    2d80:	39 0b       	sbc	r19, r25
    2d82:	cb 01       	movw	r24, r22
    2d84:	ba 01       	movw	r22, r20
    2d86:	a9 01       	movw	r20, r18
    2d88:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    2d8c:	2b 81       	ldd	r18, Y+3	; 0x03
    2d8e:	3c 81       	ldd	r19, Y+4	; 0x04
    2d90:	89 85       	ldd	r24, Y+9	; 0x09
    2d92:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d94:	82 0f       	add	r24, r18
    2d96:	93 1f       	adc	r25, r19
    2d98:	9c 83       	std	Y+4, r25	; 0x04
    2d9a:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    2d9c:	ed 81       	ldd	r30, Y+5	; 0x05
    2d9e:	fe 81       	ldd	r31, Y+6	; 0x06
    2da0:	24 81       	ldd	r18, Z+4	; 0x04
    2da2:	35 81       	ldd	r19, Z+5	; 0x05
    2da4:	8b 81       	ldd	r24, Y+3	; 0x03
    2da6:	9c 81       	ldd	r25, Y+4	; 0x04
    2da8:	82 17       	cp	r24, r18
    2daa:	93 07       	cpc	r25, r19
    2dac:	50 f0       	brcs	.+20     	; 0x2dc2 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    2dae:	ed 81       	ldd	r30, Y+5	; 0x05
    2db0:	fe 81       	ldd	r31, Y+6	; 0x06
    2db2:	24 81       	ldd	r18, Z+4	; 0x04
    2db4:	35 81       	ldd	r19, Z+5	; 0x05
    2db6:	8b 81       	ldd	r24, Y+3	; 0x03
    2db8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dba:	82 1b       	sub	r24, r18
    2dbc:	93 0b       	sbc	r25, r19
    2dbe:	9c 83       	std	Y+4, r25	; 0x04
    2dc0:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    2dc2:	ed 81       	ldd	r30, Y+5	; 0x05
    2dc4:	fe 81       	ldd	r31, Y+6	; 0x06
    2dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dca:	93 83       	std	Z+3, r25	; 0x03
    2dcc:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    2dce:	89 85       	ldd	r24, Y+9	; 0x09
    2dd0:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2dd2:	2e 96       	adiw	r28, 0x0e	; 14
    2dd4:	0f b6       	in	r0, 0x3f	; 63
    2dd6:	f8 94       	cli
    2dd8:	de bf       	out	0x3e, r29	; 62
    2dda:	0f be       	out	0x3f, r0	; 63
    2ddc:	cd bf       	out	0x3d, r28	; 61
    2dde:	cf 91       	pop	r28
    2de0:	df 91       	pop	r29
    2de2:	08 95       	ret

00002de4 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    2de4:	df 93       	push	r29
    2de6:	cf 93       	push	r28
    2de8:	cd b7       	in	r28, 0x3d	; 61
    2dea:	de b7       	in	r29, 0x3e	; 62
    2dec:	66 97       	sbiw	r28, 0x16	; 22
    2dee:	0f b6       	in	r0, 0x3f	; 63
    2df0:	f8 94       	cli
    2df2:	de bf       	out	0x3e, r29	; 62
    2df4:	0f be       	out	0x3f, r0	; 63
    2df6:	cd bf       	out	0x3d, r28	; 61
    2df8:	98 87       	std	Y+8, r25	; 0x08
    2dfa:	8f 83       	std	Y+7, r24	; 0x07
    2dfc:	7a 87       	std	Y+10, r23	; 0x0a
    2dfe:	69 87       	std	Y+9, r22	; 0x09
    2e00:	5c 87       	std	Y+12, r21	; 0x0c
    2e02:	4b 87       	std	Y+11, r20	; 0x0b
    2e04:	3e 87       	std	Y+14, r19	; 0x0e
    2e06:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    2e08:	2d 85       	ldd	r18, Y+13	; 0x0d
    2e0a:	3e 85       	ldd	r19, Y+14	; 0x0e
    2e0c:	3a 8b       	std	Y+18, r19	; 0x12
    2e0e:	29 8b       	std	Y+17, r18	; 0x11
    2e10:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e12:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e14:	58 8b       	std	Y+16, r21	; 0x10
    2e16:	4f 87       	std	Y+15, r20	; 0x0f
    2e18:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e1a:	98 89       	ldd	r25, Y+16	; 0x10
    2e1c:	29 89       	ldd	r18, Y+17	; 0x11
    2e1e:	3a 89       	ldd	r19, Y+18	; 0x12
    2e20:	28 17       	cp	r18, r24
    2e22:	39 07       	cpc	r19, r25
    2e24:	20 f4       	brcc	.+8      	; 0x2e2e <prvReadBytesFromBuffer+0x4a>
    2e26:	49 89       	ldd	r20, Y+17	; 0x11
    2e28:	5a 89       	ldd	r21, Y+18	; 0x12
    2e2a:	58 8b       	std	Y+16, r21	; 0x10
    2e2c:	4f 87       	std	Y+15, r20	; 0x0f
    2e2e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e30:	98 89       	ldd	r25, Y+16	; 0x10
    2e32:	9e 83       	std	Y+6, r25	; 0x06
    2e34:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    2e36:	8d 81       	ldd	r24, Y+5	; 0x05
    2e38:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3a:	00 97       	sbiw	r24, 0x00	; 0
    2e3c:	09 f4       	brne	.+2      	; 0x2e40 <prvReadBytesFromBuffer+0x5c>
    2e3e:	74 c0       	rjmp	.+232    	; 0x2f28 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    2e40:	ef 81       	ldd	r30, Y+7	; 0x07
    2e42:	f8 85       	ldd	r31, Y+8	; 0x08
    2e44:	80 81       	ld	r24, Z
    2e46:	91 81       	ldd	r25, Z+1	; 0x01
    2e48:	9a 83       	std	Y+2, r25	; 0x02
    2e4a:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    2e4c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e4e:	f8 85       	ldd	r31, Y+8	; 0x08
    2e50:	24 81       	ldd	r18, Z+4	; 0x04
    2e52:	35 81       	ldd	r19, Z+5	; 0x05
    2e54:	89 81       	ldd	r24, Y+1	; 0x01
    2e56:	9a 81       	ldd	r25, Y+2	; 0x02
    2e58:	a9 01       	movw	r20, r18
    2e5a:	48 1b       	sub	r20, r24
    2e5c:	59 0b       	sbc	r21, r25
    2e5e:	ca 01       	movw	r24, r20
    2e60:	2d 81       	ldd	r18, Y+5	; 0x05
    2e62:	3e 81       	ldd	r19, Y+6	; 0x06
    2e64:	3e 8b       	std	Y+22, r19	; 0x16
    2e66:	2d 8b       	std	Y+21, r18	; 0x15
    2e68:	9c 8b       	std	Y+20, r25	; 0x14
    2e6a:	8b 8b       	std	Y+19, r24	; 0x13
    2e6c:	4b 89       	ldd	r20, Y+19	; 0x13
    2e6e:	5c 89       	ldd	r21, Y+20	; 0x14
    2e70:	8d 89       	ldd	r24, Y+21	; 0x15
    2e72:	9e 89       	ldd	r25, Y+22	; 0x16
    2e74:	84 17       	cp	r24, r20
    2e76:	95 07       	cpc	r25, r21
    2e78:	20 f4       	brcc	.+8      	; 0x2e82 <prvReadBytesFromBuffer+0x9e>
    2e7a:	2d 89       	ldd	r18, Y+21	; 0x15
    2e7c:	3e 89       	ldd	r19, Y+22	; 0x16
    2e7e:	3c 8b       	std	Y+20, r19	; 0x14
    2e80:	2b 8b       	std	Y+19, r18	; 0x13
    2e82:	4b 89       	ldd	r20, Y+19	; 0x13
    2e84:	5c 89       	ldd	r21, Y+20	; 0x14
    2e86:	5c 83       	std	Y+4, r21	; 0x04
    2e88:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2e8a:	ef 81       	ldd	r30, Y+7	; 0x07
    2e8c:	f8 85       	ldd	r31, Y+8	; 0x08
    2e8e:	24 85       	ldd	r18, Z+12	; 0x0c
    2e90:	35 85       	ldd	r19, Z+13	; 0x0d
    2e92:	89 81       	ldd	r24, Y+1	; 0x01
    2e94:	9a 81       	ldd	r25, Y+2	; 0x02
    2e96:	a9 01       	movw	r20, r18
    2e98:	48 0f       	add	r20, r24
    2e9a:	59 1f       	adc	r21, r25
    2e9c:	89 85       	ldd	r24, Y+9	; 0x09
    2e9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ea0:	2b 81       	ldd	r18, Y+3	; 0x03
    2ea2:	3c 81       	ldd	r19, Y+4	; 0x04
    2ea4:	ba 01       	movw	r22, r20
    2ea6:	a9 01       	movw	r20, r18
    2ea8:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    2eac:	2d 81       	ldd	r18, Y+5	; 0x05
    2eae:	3e 81       	ldd	r19, Y+6	; 0x06
    2eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb4:	82 17       	cp	r24, r18
    2eb6:	93 07       	cpc	r25, r19
    2eb8:	b0 f4       	brcc	.+44     	; 0x2ee6 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2eba:	29 85       	ldd	r18, Y+9	; 0x09
    2ebc:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	b9 01       	movw	r22, r18
    2ec4:	68 0f       	add	r22, r24
    2ec6:	79 1f       	adc	r23, r25
    2ec8:	ef 81       	ldd	r30, Y+7	; 0x07
    2eca:	f8 85       	ldd	r31, Y+8	; 0x08
    2ecc:	44 85       	ldd	r20, Z+12	; 0x0c
    2ece:	55 85       	ldd	r21, Z+13	; 0x0d
    2ed0:	2d 81       	ldd	r18, Y+5	; 0x05
    2ed2:	3e 81       	ldd	r19, Y+6	; 0x06
    2ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed8:	28 1b       	sub	r18, r24
    2eda:	39 0b       	sbc	r19, r25
    2edc:	cb 01       	movw	r24, r22
    2ede:	ba 01       	movw	r22, r20
    2ee0:	a9 01       	movw	r20, r18
    2ee2:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    2ee6:	29 81       	ldd	r18, Y+1	; 0x01
    2ee8:	3a 81       	ldd	r19, Y+2	; 0x02
    2eea:	8d 81       	ldd	r24, Y+5	; 0x05
    2eec:	9e 81       	ldd	r25, Y+6	; 0x06
    2eee:	82 0f       	add	r24, r18
    2ef0:	93 1f       	adc	r25, r19
    2ef2:	9a 83       	std	Y+2, r25	; 0x02
    2ef4:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    2ef6:	ef 81       	ldd	r30, Y+7	; 0x07
    2ef8:	f8 85       	ldd	r31, Y+8	; 0x08
    2efa:	24 81       	ldd	r18, Z+4	; 0x04
    2efc:	35 81       	ldd	r19, Z+5	; 0x05
    2efe:	89 81       	ldd	r24, Y+1	; 0x01
    2f00:	9a 81       	ldd	r25, Y+2	; 0x02
    2f02:	82 17       	cp	r24, r18
    2f04:	93 07       	cpc	r25, r19
    2f06:	50 f0       	brcs	.+20     	; 0x2f1c <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    2f08:	ef 81       	ldd	r30, Y+7	; 0x07
    2f0a:	f8 85       	ldd	r31, Y+8	; 0x08
    2f0c:	24 81       	ldd	r18, Z+4	; 0x04
    2f0e:	35 81       	ldd	r19, Z+5	; 0x05
    2f10:	89 81       	ldd	r24, Y+1	; 0x01
    2f12:	9a 81       	ldd	r25, Y+2	; 0x02
    2f14:	82 1b       	sub	r24, r18
    2f16:	93 0b       	sbc	r25, r19
    2f18:	9a 83       	std	Y+2, r25	; 0x02
    2f1a:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    2f1c:	ef 81       	ldd	r30, Y+7	; 0x07
    2f1e:	f8 85       	ldd	r31, Y+8	; 0x08
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
    2f24:	91 83       	std	Z+1, r25	; 0x01
    2f26:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2f28:	8d 81       	ldd	r24, Y+5	; 0x05
    2f2a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2f2c:	66 96       	adiw	r28, 0x16	; 22
    2f2e:	0f b6       	in	r0, 0x3f	; 63
    2f30:	f8 94       	cli
    2f32:	de bf       	out	0x3e, r29	; 62
    2f34:	0f be       	out	0x3f, r0	; 63
    2f36:	cd bf       	out	0x3d, r28	; 61
    2f38:	cf 91       	pop	r28
    2f3a:	df 91       	pop	r29
    2f3c:	08 95       	ret

00002f3e <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2f3e:	df 93       	push	r29
    2f40:	cf 93       	push	r28
    2f42:	00 d0       	rcall	.+0      	; 0x2f44 <prvBytesInBuffer+0x6>
    2f44:	00 d0       	rcall	.+0      	; 0x2f46 <prvBytesInBuffer+0x8>
    2f46:	cd b7       	in	r28, 0x3d	; 61
    2f48:	de b7       	in	r29, 0x3e	; 62
    2f4a:	9c 83       	std	Y+4, r25	; 0x04
    2f4c:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f50:	fc 81       	ldd	r31, Y+4	; 0x04
    2f52:	24 81       	ldd	r18, Z+4	; 0x04
    2f54:	35 81       	ldd	r19, Z+5	; 0x05
    2f56:	eb 81       	ldd	r30, Y+3	; 0x03
    2f58:	fc 81       	ldd	r31, Y+4	; 0x04
    2f5a:	82 81       	ldd	r24, Z+2	; 0x02
    2f5c:	93 81       	ldd	r25, Z+3	; 0x03
    2f5e:	82 0f       	add	r24, r18
    2f60:	93 1f       	adc	r25, r19
    2f62:	9a 83       	std	Y+2, r25	; 0x02
    2f64:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    2f66:	eb 81       	ldd	r30, Y+3	; 0x03
    2f68:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6a:	20 81       	ld	r18, Z
    2f6c:	31 81       	ldd	r19, Z+1	; 0x01
    2f6e:	89 81       	ldd	r24, Y+1	; 0x01
    2f70:	9a 81       	ldd	r25, Y+2	; 0x02
    2f72:	82 1b       	sub	r24, r18
    2f74:	93 0b       	sbc	r25, r19
    2f76:	9a 83       	std	Y+2, r25	; 0x02
    2f78:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    2f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7e:	24 81       	ldd	r18, Z+4	; 0x04
    2f80:	35 81       	ldd	r19, Z+5	; 0x05
    2f82:	89 81       	ldd	r24, Y+1	; 0x01
    2f84:	9a 81       	ldd	r25, Y+2	; 0x02
    2f86:	82 17       	cp	r24, r18
    2f88:	93 07       	cpc	r25, r19
    2f8a:	50 f0       	brcs	.+20     	; 0x2fa0 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    2f8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f90:	24 81       	ldd	r18, Z+4	; 0x04
    2f92:	35 81       	ldd	r19, Z+5	; 0x05
    2f94:	89 81       	ldd	r24, Y+1	; 0x01
    2f96:	9a 81       	ldd	r25, Y+2	; 0x02
    2f98:	82 1b       	sub	r24, r18
    2f9a:	93 0b       	sbc	r25, r19
    2f9c:	9a 83       	std	Y+2, r25	; 0x02
    2f9e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2fa0:	89 81       	ldd	r24, Y+1	; 0x01
    2fa2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2fa4:	0f 90       	pop	r0
    2fa6:	0f 90       	pop	r0
    2fa8:	0f 90       	pop	r0
    2faa:	0f 90       	pop	r0
    2fac:	cf 91       	pop	r28
    2fae:	df 91       	pop	r29
    2fb0:	08 95       	ret

00002fb2 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    2fb2:	0f 93       	push	r16
    2fb4:	df 93       	push	r29
    2fb6:	cf 93       	push	r28
    2fb8:	cd b7       	in	r28, 0x3d	; 61
    2fba:	de b7       	in	r29, 0x3e	; 62
    2fbc:	29 97       	sbiw	r28, 0x09	; 9
    2fbe:	0f b6       	in	r0, 0x3f	; 63
    2fc0:	f8 94       	cli
    2fc2:	de bf       	out	0x3e, r29	; 62
    2fc4:	0f be       	out	0x3f, r0	; 63
    2fc6:	cd bf       	out	0x3d, r28	; 61
    2fc8:	9a 83       	std	Y+2, r25	; 0x02
    2fca:	89 83       	std	Y+1, r24	; 0x01
    2fcc:	7c 83       	std	Y+4, r23	; 0x04
    2fce:	6b 83       	std	Y+3, r22	; 0x03
    2fd0:	5e 83       	std	Y+6, r21	; 0x06
    2fd2:	4d 83       	std	Y+5, r20	; 0x05
    2fd4:	38 87       	std	Y+8, r19	; 0x08
    2fd6:	2f 83       	std	Y+7, r18	; 0x07
    2fd8:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2fda:	89 81       	ldd	r24, Y+1	; 0x01
    2fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    2fde:	60 e0       	ldi	r22, 0x00	; 0
    2fe0:	70 e0       	ldi	r23, 0x00	; 0
    2fe2:	4f e0       	ldi	r20, 0x0F	; 15
    2fe4:	50 e0       	ldi	r21, 0x00	; 0
    2fe6:	0e 94 06 2b 	call	0x560c	; 0x560c <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    2fea:	e9 81       	ldd	r30, Y+1	; 0x01
    2fec:	fa 81       	ldd	r31, Y+2	; 0x02
    2fee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff2:	95 87       	std	Z+13, r25	; 0x0d
    2ff4:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    2ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffa:	8d 81       	ldd	r24, Y+5	; 0x05
    2ffc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ffe:	95 83       	std	Z+5, r25	; 0x05
    3000:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3002:	e9 81       	ldd	r30, Y+1	; 0x01
    3004:	fa 81       	ldd	r31, Y+2	; 0x02
    3006:	8f 81       	ldd	r24, Y+7	; 0x07
    3008:	98 85       	ldd	r25, Y+8	; 0x08
    300a:	97 83       	std	Z+7, r25	; 0x07
    300c:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    300e:	e9 81       	ldd	r30, Y+1	; 0x01
    3010:	fa 81       	ldd	r31, Y+2	; 0x02
    3012:	89 85       	ldd	r24, Y+9	; 0x09
    3014:	86 87       	std	Z+14, r24	; 0x0e
}
    3016:	29 96       	adiw	r28, 0x09	; 9
    3018:	0f b6       	in	r0, 0x3f	; 63
    301a:	f8 94       	cli
    301c:	de bf       	out	0x3e, r29	; 62
    301e:	0f be       	out	0x3f, r0	; 63
    3020:	cd bf       	out	0x3d, r28	; 61
    3022:	cf 91       	pop	r28
    3024:	df 91       	pop	r29
    3026:	0f 91       	pop	r16
    3028:	08 95       	ret

0000302a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    302a:	8f 92       	push	r8
    302c:	9f 92       	push	r9
    302e:	af 92       	push	r10
    3030:	bf 92       	push	r11
    3032:	cf 92       	push	r12
    3034:	df 92       	push	r13
    3036:	ef 92       	push	r14
    3038:	ff 92       	push	r15
    303a:	0f 93       	push	r16
    303c:	1f 93       	push	r17
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	cd b7       	in	r28, 0x3d	; 61
    3044:	de b7       	in	r29, 0x3e	; 62
    3046:	60 97       	sbiw	r28, 0x10	; 16
    3048:	0f b6       	in	r0, 0x3f	; 63
    304a:	f8 94       	cli
    304c:	de bf       	out	0x3e, r29	; 62
    304e:	0f be       	out	0x3f, r0	; 63
    3050:	cd bf       	out	0x3d, r28	; 61
    3052:	9f 83       	std	Y+7, r25	; 0x07
    3054:	8e 83       	std	Y+6, r24	; 0x06
    3056:	79 87       	std	Y+9, r23	; 0x09
    3058:	68 87       	std	Y+8, r22	; 0x08
    305a:	5b 87       	std	Y+11, r21	; 0x0b
    305c:	4a 87       	std	Y+10, r20	; 0x0a
    305e:	3d 87       	std	Y+13, r19	; 0x0d
    3060:	2c 87       	std	Y+12, r18	; 0x0c
    3062:	0e 87       	std	Y+14, r16	; 0x0e
    3064:	f8 8a       	std	Y+16, r15	; 0x10
    3066:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3068:	8a 85       	ldd	r24, Y+10	; 0x0a
    306a:	9b 85       	ldd	r25, Y+11	; 0x0b
    306c:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    3070:	9a 83       	std	Y+2, r25	; 0x02
    3072:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3074:	89 81       	ldd	r24, Y+1	; 0x01
    3076:	9a 81       	ldd	r25, Y+2	; 0x02
    3078:	00 97       	sbiw	r24, 0x00	; 0
    307a:	b1 f0       	breq	.+44     	; 0x30a8 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    307c:	8a e2       	ldi	r24, 0x2A	; 42
    307e:	90 e0       	ldi	r25, 0x00	; 0
    3080:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    3084:	9d 83       	std	Y+5, r25	; 0x05
    3086:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3088:	8c 81       	ldd	r24, Y+4	; 0x04
    308a:	9d 81       	ldd	r25, Y+5	; 0x05
    308c:	00 97       	sbiw	r24, 0x00	; 0
    308e:	39 f0       	breq	.+14     	; 0x309e <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3090:	ec 81       	ldd	r30, Y+4	; 0x04
    3092:	fd 81       	ldd	r31, Y+5	; 0x05
    3094:	89 81       	ldd	r24, Y+1	; 0x01
    3096:	9a 81       	ldd	r25, Y+2	; 0x02
    3098:	90 8f       	std	Z+24, r25	; 0x18
    309a:	87 8b       	std	Z+23, r24	; 0x17
    309c:	07 c0       	rjmp	.+14     	; 0x30ac <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    309e:	89 81       	ldd	r24, Y+1	; 0x01
    30a0:	9a 81       	ldd	r25, Y+2	; 0x02
    30a2:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    30a6:	02 c0       	rjmp	.+4      	; 0x30ac <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    30a8:	1d 82       	std	Y+5, r1	; 0x05
    30aa:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    30ac:	8c 81       	ldd	r24, Y+4	; 0x04
    30ae:	9d 81       	ldd	r25, Y+5	; 0x05
    30b0:	00 97       	sbiw	r24, 0x00	; 0
    30b2:	e9 f0       	breq	.+58     	; 0x30ee <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    30b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    30b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    30b8:	9c 01       	movw	r18, r24
    30ba:	40 e0       	ldi	r20, 0x00	; 0
    30bc:	50 e0       	ldi	r21, 0x00	; 0
    30be:	8e 81       	ldd	r24, Y+6	; 0x06
    30c0:	9f 81       	ldd	r25, Y+7	; 0x07
    30c2:	68 85       	ldd	r22, Y+8	; 0x08
    30c4:	79 85       	ldd	r23, Y+9	; 0x09
    30c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    30c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    30ca:	af 85       	ldd	r26, Y+15	; 0x0f
    30cc:	b8 89       	ldd	r27, Y+16	; 0x10
    30ce:	ac 80       	ldd	r10, Y+4	; 0x04
    30d0:	bd 80       	ldd	r11, Y+5	; 0x05
    30d2:	8f 01       	movw	r16, r30
    30d4:	ee 84       	ldd	r14, Y+14	; 0x0e
    30d6:	6d 01       	movw	r12, r26
    30d8:	88 24       	eor	r8, r8
    30da:	99 24       	eor	r9, r9
    30dc:	0e 94 8d 18 	call	0x311a	; 0x311a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    30e0:	8c 81       	ldd	r24, Y+4	; 0x04
    30e2:	9d 81       	ldd	r25, Y+5	; 0x05
    30e4:	0e 94 50 19 	call	0x32a0	; 0x32a0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    30e8:	81 e0       	ldi	r24, 0x01	; 1
    30ea:	8b 83       	std	Y+3, r24	; 0x03
    30ec:	02 c0       	rjmp	.+4      	; 0x30f2 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    30ee:	8f ef       	ldi	r24, 0xFF	; 255
    30f0:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    30f2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    30f4:	60 96       	adiw	r28, 0x10	; 16
    30f6:	0f b6       	in	r0, 0x3f	; 63
    30f8:	f8 94       	cli
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	0f be       	out	0x3f, r0	; 63
    30fe:	cd bf       	out	0x3d, r28	; 61
    3100:	cf 91       	pop	r28
    3102:	df 91       	pop	r29
    3104:	1f 91       	pop	r17
    3106:	0f 91       	pop	r16
    3108:	ff 90       	pop	r15
    310a:	ef 90       	pop	r14
    310c:	df 90       	pop	r13
    310e:	cf 90       	pop	r12
    3110:	bf 90       	pop	r11
    3112:	af 90       	pop	r10
    3114:	9f 90       	pop	r9
    3116:	8f 90       	pop	r8
    3118:	08 95       	ret

0000311a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    311a:	8f 92       	push	r8
    311c:	9f 92       	push	r9
    311e:	af 92       	push	r10
    3120:	bf 92       	push	r11
    3122:	cf 92       	push	r12
    3124:	df 92       	push	r13
    3126:	ef 92       	push	r14
    3128:	0f 93       	push	r16
    312a:	1f 93       	push	r17
    312c:	df 93       	push	r29
    312e:	cf 93       	push	r28
    3130:	cd b7       	in	r28, 0x3d	; 61
    3132:	de b7       	in	r29, 0x3e	; 62
    3134:	64 97       	sbiw	r28, 0x14	; 20
    3136:	0f b6       	in	r0, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	de bf       	out	0x3e, r29	; 62
    313c:	0f be       	out	0x3f, r0	; 63
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	9d 83       	std	Y+5, r25	; 0x05
    3142:	8c 83       	std	Y+4, r24	; 0x04
    3144:	7f 83       	std	Y+7, r23	; 0x07
    3146:	6e 83       	std	Y+6, r22	; 0x06
    3148:	28 87       	std	Y+8, r18	; 0x08
    314a:	39 87       	std	Y+9, r19	; 0x09
    314c:	4a 87       	std	Y+10, r20	; 0x0a
    314e:	5b 87       	std	Y+11, r21	; 0x0b
    3150:	1d 87       	std	Y+13, r17	; 0x0d
    3152:	0c 87       	std	Y+12, r16	; 0x0c
    3154:	ee 86       	std	Y+14, r14	; 0x0e
    3156:	d8 8a       	std	Y+16, r13	; 0x10
    3158:	cf 86       	std	Y+15, r12	; 0x0f
    315a:	ba 8a       	std	Y+18, r11	; 0x12
    315c:	a9 8a       	std	Y+17, r10	; 0x11
    315e:	9c 8a       	std	Y+20, r9	; 0x14
    3160:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3162:	e9 89       	ldd	r30, Y+17	; 0x11
    3164:	fa 89       	ldd	r31, Y+18	; 0x12
    3166:	27 89       	ldd	r18, Z+23	; 0x17
    3168:	30 8d       	ldd	r19, Z+24	; 0x18
    316a:	88 85       	ldd	r24, Y+8	; 0x08
    316c:	99 85       	ldd	r25, Y+9	; 0x09
    316e:	01 97       	sbiw	r24, 0x01	; 1
    3170:	82 0f       	add	r24, r18
    3172:	93 1f       	adc	r25, r19
    3174:	9b 83       	std	Y+3, r25	; 0x03
    3176:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3178:	8e 81       	ldd	r24, Y+6	; 0x06
    317a:	9f 81       	ldd	r25, Y+7	; 0x07
    317c:	00 97       	sbiw	r24, 0x00	; 0
    317e:	51 f1       	breq	.+84     	; 0x31d4 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3180:	19 82       	std	Y+1, r1	; 0x01
    3182:	21 c0       	rjmp	.+66     	; 0x31c6 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3184:	89 81       	ldd	r24, Y+1	; 0x01
    3186:	48 2f       	mov	r20, r24
    3188:	50 e0       	ldi	r21, 0x00	; 0
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	28 2f       	mov	r18, r24
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	8e 81       	ldd	r24, Y+6	; 0x06
    3192:	9f 81       	ldd	r25, Y+7	; 0x07
    3194:	fc 01       	movw	r30, r24
    3196:	e2 0f       	add	r30, r18
    3198:	f3 1f       	adc	r31, r19
    319a:	20 81       	ld	r18, Z
    319c:	89 89       	ldd	r24, Y+17	; 0x11
    319e:	9a 89       	ldd	r25, Y+18	; 0x12
    31a0:	84 0f       	add	r24, r20
    31a2:	95 1f       	adc	r25, r21
    31a4:	fc 01       	movw	r30, r24
    31a6:	79 96       	adiw	r30, 0x19	; 25
    31a8:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    31aa:	89 81       	ldd	r24, Y+1	; 0x01
    31ac:	28 2f       	mov	r18, r24
    31ae:	30 e0       	ldi	r19, 0x00	; 0
    31b0:	8e 81       	ldd	r24, Y+6	; 0x06
    31b2:	9f 81       	ldd	r25, Y+7	; 0x07
    31b4:	fc 01       	movw	r30, r24
    31b6:	e2 0f       	add	r30, r18
    31b8:	f3 1f       	adc	r31, r19
    31ba:	80 81       	ld	r24, Z
    31bc:	88 23       	and	r24, r24
    31be:	31 f0       	breq	.+12     	; 0x31cc <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    31c0:	89 81       	ldd	r24, Y+1	; 0x01
    31c2:	8f 5f       	subi	r24, 0xFF	; 255
    31c4:	89 83       	std	Y+1, r24	; 0x01
    31c6:	89 81       	ldd	r24, Y+1	; 0x01
    31c8:	8a 30       	cpi	r24, 0x0A	; 10
    31ca:	e0 f2       	brcs	.-72     	; 0x3184 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    31cc:	e9 89       	ldd	r30, Y+17	; 0x11
    31ce:	fa 89       	ldd	r31, Y+18	; 0x12
    31d0:	12 a2       	std	Z+34, r1	; 0x22
    31d2:	03 c0       	rjmp	.+6      	; 0x31da <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    31d4:	e9 89       	ldd	r30, Y+17	; 0x11
    31d6:	fa 89       	ldd	r31, Y+18	; 0x12
    31d8:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    31da:	8e 85       	ldd	r24, Y+14	; 0x0e
    31dc:	84 30       	cpi	r24, 0x04	; 4
    31de:	10 f0       	brcs	.+4      	; 0x31e4 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    31e0:	83 e0       	ldi	r24, 0x03	; 3
    31e2:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    31e4:	e9 89       	ldd	r30, Y+17	; 0x11
    31e6:	fa 89       	ldd	r31, Y+18	; 0x12
    31e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ea:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    31ec:	e9 89       	ldd	r30, Y+17	; 0x11
    31ee:	fa 89       	ldd	r31, Y+18	; 0x12
    31f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    31f2:	83 a3       	std	Z+35, r24	; 0x23
		pxNewTCB->uxMutexesHeld = 0;
    31f4:	e9 89       	ldd	r30, Y+17	; 0x11
    31f6:	fa 89       	ldd	r31, Y+18	; 0x12
    31f8:	14 a2       	std	Z+36, r1	; 0x24
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    31fa:	89 89       	ldd	r24, Y+17	; 0x11
    31fc:	9a 89       	ldd	r25, Y+18	; 0x12
    31fe:	02 96       	adiw	r24, 0x02	; 2
    3200:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3204:	89 89       	ldd	r24, Y+17	; 0x11
    3206:	9a 89       	ldd	r25, Y+18	; 0x12
    3208:	0c 96       	adiw	r24, 0x0c	; 12
    320a:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    320e:	e9 89       	ldd	r30, Y+17	; 0x11
    3210:	fa 89       	ldd	r31, Y+18	; 0x12
    3212:	89 89       	ldd	r24, Y+17	; 0x11
    3214:	9a 89       	ldd	r25, Y+18	; 0x12
    3216:	91 87       	std	Z+9, r25	; 0x09
    3218:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    321a:	8e 85       	ldd	r24, Y+14	; 0x0e
    321c:	28 2f       	mov	r18, r24
    321e:	30 e0       	ldi	r19, 0x00	; 0
    3220:	84 e0       	ldi	r24, 0x04	; 4
    3222:	90 e0       	ldi	r25, 0x00	; 0
    3224:	82 1b       	sub	r24, r18
    3226:	93 0b       	sbc	r25, r19
    3228:	e9 89       	ldd	r30, Y+17	; 0x11
    322a:	fa 89       	ldd	r31, Y+18	; 0x12
    322c:	95 87       	std	Z+13, r25	; 0x0d
    322e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3230:	e9 89       	ldd	r30, Y+17	; 0x11
    3232:	fa 89       	ldd	r31, Y+18	; 0x12
    3234:	89 89       	ldd	r24, Y+17	; 0x11
    3236:	9a 89       	ldd	r25, Y+18	; 0x12
    3238:	93 8b       	std	Z+19, r25	; 0x13
    323a:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    323c:	e9 89       	ldd	r30, Y+17	; 0x11
    323e:	fa 89       	ldd	r31, Y+18	; 0x12
    3240:	15 a2       	std	Z+37, r1	; 0x25
    3242:	16 a2       	std	Z+38, r1	; 0x26
    3244:	17 a2       	std	Z+39, r1	; 0x27
    3246:	10 a6       	std	Z+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3248:	e9 89       	ldd	r30, Y+17	; 0x11
    324a:	fa 89       	ldd	r31, Y+18	; 0x12
    324c:	11 a6       	std	Z+41, r1	; 0x29
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    324e:	8a 81       	ldd	r24, Y+2	; 0x02
    3250:	9b 81       	ldd	r25, Y+3	; 0x03
    3252:	2c 81       	ldd	r18, Y+4	; 0x04
    3254:	3d 81       	ldd	r19, Y+5	; 0x05
    3256:	4c 85       	ldd	r20, Y+12	; 0x0c
    3258:	5d 85       	ldd	r21, Y+13	; 0x0d
    325a:	b9 01       	movw	r22, r18
    325c:	0e 94 40 05 	call	0xa80	; 0xa80 <pxPortInitialiseStack>
    3260:	e9 89       	ldd	r30, Y+17	; 0x11
    3262:	fa 89       	ldd	r31, Y+18	; 0x12
    3264:	91 83       	std	Z+1, r25	; 0x01
    3266:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3268:	8f 85       	ldd	r24, Y+15	; 0x0f
    326a:	98 89       	ldd	r25, Y+16	; 0x10
    326c:	00 97       	sbiw	r24, 0x00	; 0
    326e:	31 f0       	breq	.+12     	; 0x327c <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3270:	ef 85       	ldd	r30, Y+15	; 0x0f
    3272:	f8 89       	ldd	r31, Y+16	; 0x10
    3274:	89 89       	ldd	r24, Y+17	; 0x11
    3276:	9a 89       	ldd	r25, Y+18	; 0x12
    3278:	91 83       	std	Z+1, r25	; 0x01
    327a:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    327c:	64 96       	adiw	r28, 0x14	; 20
    327e:	0f b6       	in	r0, 0x3f	; 63
    3280:	f8 94       	cli
    3282:	de bf       	out	0x3e, r29	; 62
    3284:	0f be       	out	0x3f, r0	; 63
    3286:	cd bf       	out	0x3d, r28	; 61
    3288:	cf 91       	pop	r28
    328a:	df 91       	pop	r29
    328c:	1f 91       	pop	r17
    328e:	0f 91       	pop	r16
    3290:	ef 90       	pop	r14
    3292:	df 90       	pop	r13
    3294:	cf 90       	pop	r12
    3296:	bf 90       	pop	r11
    3298:	af 90       	pop	r10
    329a:	9f 90       	pop	r9
    329c:	8f 90       	pop	r8
    329e:	08 95       	ret

000032a0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    32a0:	df 93       	push	r29
    32a2:	cf 93       	push	r28
    32a4:	00 d0       	rcall	.+0      	; 0x32a6 <prvAddNewTaskToReadyList+0x6>
    32a6:	cd b7       	in	r28, 0x3d	; 61
    32a8:	de b7       	in	r29, 0x3e	; 62
    32aa:	9a 83       	std	Y+2, r25	; 0x02
    32ac:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    32ae:	0f b6       	in	r0, 0x3f	; 63
    32b0:	f8 94       	cli
    32b2:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    32b4:	80 91 49 06 	lds	r24, 0x0649
    32b8:	8f 5f       	subi	r24, 0xFF	; 255
    32ba:	80 93 49 06 	sts	0x0649, r24
		if( pxCurrentTCB == NULL )
    32be:	80 91 46 06 	lds	r24, 0x0646
    32c2:	90 91 47 06 	lds	r25, 0x0647
    32c6:	00 97       	sbiw	r24, 0x00	; 0
    32c8:	69 f4       	brne	.+26     	; 0x32e4 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    32ca:	89 81       	ldd	r24, Y+1	; 0x01
    32cc:	9a 81       	ldd	r25, Y+2	; 0x02
    32ce:	90 93 47 06 	sts	0x0647, r25
    32d2:	80 93 46 06 	sts	0x0646, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    32d6:	80 91 49 06 	lds	r24, 0x0649
    32da:	81 30       	cpi	r24, 0x01	; 1
    32dc:	b9 f4       	brne	.+46     	; 0x330c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    32de:	0e 94 27 20 	call	0x404e	; 0x404e <prvInitialiseTaskLists>
    32e2:	14 c0       	rjmp	.+40     	; 0x330c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    32e4:	80 91 4d 06 	lds	r24, 0x064D
    32e8:	88 23       	and	r24, r24
    32ea:	81 f4       	brne	.+32     	; 0x330c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    32ec:	e0 91 46 06 	lds	r30, 0x0646
    32f0:	f0 91 47 06 	lds	r31, 0x0647
    32f4:	96 89       	ldd	r25, Z+22	; 0x16
    32f6:	e9 81       	ldd	r30, Y+1	; 0x01
    32f8:	fa 81       	ldd	r31, Y+2	; 0x02
    32fa:	86 89       	ldd	r24, Z+22	; 0x16
    32fc:	89 17       	cp	r24, r25
    32fe:	30 f0       	brcs	.+12     	; 0x330c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3300:	89 81       	ldd	r24, Y+1	; 0x01
    3302:	9a 81       	ldd	r25, Y+2	; 0x02
    3304:	90 93 47 06 	sts	0x0647, r25
    3308:	80 93 46 06 	sts	0x0646, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    330c:	80 91 51 06 	lds	r24, 0x0651
    3310:	8f 5f       	subi	r24, 0xFF	; 255
    3312:	80 93 51 06 	sts	0x0651, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3316:	e9 81       	ldd	r30, Y+1	; 0x01
    3318:	fa 81       	ldd	r31, Y+2	; 0x02
    331a:	96 89       	ldd	r25, Z+22	; 0x16
    331c:	80 91 4c 06 	lds	r24, 0x064C
    3320:	89 17       	cp	r24, r25
    3322:	28 f4       	brcc	.+10     	; 0x332e <prvAddNewTaskToReadyList+0x8e>
    3324:	e9 81       	ldd	r30, Y+1	; 0x01
    3326:	fa 81       	ldd	r31, Y+2	; 0x02
    3328:	86 89       	ldd	r24, Z+22	; 0x16
    332a:	80 93 4c 06 	sts	0x064C, r24
    332e:	e9 81       	ldd	r30, Y+1	; 0x01
    3330:	fa 81       	ldd	r31, Y+2	; 0x02
    3332:	86 89       	ldd	r24, Z+22	; 0x16
    3334:	28 2f       	mov	r18, r24
    3336:	30 e0       	ldi	r19, 0x00	; 0
    3338:	c9 01       	movw	r24, r18
    333a:	88 0f       	add	r24, r24
    333c:	99 1f       	adc	r25, r25
    333e:	88 0f       	add	r24, r24
    3340:	99 1f       	adc	r25, r25
    3342:	88 0f       	add	r24, r24
    3344:	99 1f       	adc	r25, r25
    3346:	82 0f       	add	r24, r18
    3348:	93 1f       	adc	r25, r19
    334a:	ac 01       	movw	r20, r24
    334c:	49 5a       	subi	r20, 0xA9	; 169
    334e:	59 4f       	sbci	r21, 0xF9	; 249
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	9c 01       	movw	r18, r24
    3356:	2e 5f       	subi	r18, 0xFE	; 254
    3358:	3f 4f       	sbci	r19, 0xFF	; 255
    335a:	ca 01       	movw	r24, r20
    335c:	b9 01       	movw	r22, r18
    335e:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3362:	0f 90       	pop	r0
    3364:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3366:	80 91 4d 06 	lds	r24, 0x064D
    336a:	88 23       	and	r24, r24
    336c:	61 f0       	breq	.+24     	; 0x3386 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    336e:	e0 91 46 06 	lds	r30, 0x0646
    3372:	f0 91 47 06 	lds	r31, 0x0647
    3376:	96 89       	ldd	r25, Z+22	; 0x16
    3378:	e9 81       	ldd	r30, Y+1	; 0x01
    337a:	fa 81       	ldd	r31, Y+2	; 0x02
    337c:	86 89       	ldd	r24, Z+22	; 0x16
    337e:	98 17       	cp	r25, r24
    3380:	10 f4       	brcc	.+4      	; 0x3386 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3382:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3386:	0f 90       	pop	r0
    3388:	0f 90       	pop	r0
    338a:	cf 91       	pop	r28
    338c:	df 91       	pop	r29
    338e:	08 95       	ret

00003390 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3390:	df 93       	push	r29
    3392:	cf 93       	push	r28
    3394:	00 d0       	rcall	.+0      	; 0x3396 <vTaskDelete+0x6>
    3396:	00 d0       	rcall	.+0      	; 0x3398 <vTaskDelete+0x8>
    3398:	00 d0       	rcall	.+0      	; 0x339a <vTaskDelete+0xa>
    339a:	cd b7       	in	r28, 0x3d	; 61
    339c:	de b7       	in	r29, 0x3e	; 62
    339e:	9c 83       	std	Y+4, r25	; 0x04
    33a0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    33a2:	0f b6       	in	r0, 0x3f	; 63
    33a4:	f8 94       	cli
    33a6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    33a8:	8b 81       	ldd	r24, Y+3	; 0x03
    33aa:	9c 81       	ldd	r25, Y+4	; 0x04
    33ac:	00 97       	sbiw	r24, 0x00	; 0
    33ae:	39 f4       	brne	.+14     	; 0x33be <vTaskDelete+0x2e>
    33b0:	80 91 46 06 	lds	r24, 0x0646
    33b4:	90 91 47 06 	lds	r25, 0x0647
    33b8:	9e 83       	std	Y+6, r25	; 0x06
    33ba:	8d 83       	std	Y+5, r24	; 0x05
    33bc:	04 c0       	rjmp	.+8      	; 0x33c6 <vTaskDelete+0x36>
    33be:	8b 81       	ldd	r24, Y+3	; 0x03
    33c0:	9c 81       	ldd	r25, Y+4	; 0x04
    33c2:	9e 83       	std	Y+6, r25	; 0x06
    33c4:	8d 83       	std	Y+5, r24	; 0x05
    33c6:	8d 81       	ldd	r24, Y+5	; 0x05
    33c8:	9e 81       	ldd	r25, Y+6	; 0x06
    33ca:	9a 83       	std	Y+2, r25	; 0x02
    33cc:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    33ce:	89 81       	ldd	r24, Y+1	; 0x01
    33d0:	9a 81       	ldd	r25, Y+2	; 0x02
    33d2:	02 96       	adiw	r24, 0x02	; 2
    33d4:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    33d8:	e9 81       	ldd	r30, Y+1	; 0x01
    33da:	fa 81       	ldd	r31, Y+2	; 0x02
    33dc:	84 89       	ldd	r24, Z+20	; 0x14
    33de:	95 89       	ldd	r25, Z+21	; 0x15
    33e0:	00 97       	sbiw	r24, 0x00	; 0
    33e2:	29 f0       	breq	.+10     	; 0x33ee <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    33e4:	89 81       	ldd	r24, Y+1	; 0x01
    33e6:	9a 81       	ldd	r25, Y+2	; 0x02
    33e8:	0c 96       	adiw	r24, 0x0c	; 12
    33ea:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    33ee:	80 91 51 06 	lds	r24, 0x0651
    33f2:	8f 5f       	subi	r24, 0xFF	; 255
    33f4:	80 93 51 06 	sts	0x0651, r24

			if( pxTCB == pxCurrentTCB )
    33f8:	20 91 46 06 	lds	r18, 0x0646
    33fc:	30 91 47 06 	lds	r19, 0x0647
    3400:	89 81       	ldd	r24, Y+1	; 0x01
    3402:	9a 81       	ldd	r25, Y+2	; 0x02
    3404:	82 17       	cp	r24, r18
    3406:	93 07       	cpc	r25, r19
    3408:	81 f4       	brne	.+32     	; 0x342a <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    340a:	89 81       	ldd	r24, Y+1	; 0x01
    340c:	9a 81       	ldd	r25, Y+2	; 0x02
    340e:	9c 01       	movw	r18, r24
    3410:	2e 5f       	subi	r18, 0xFE	; 254
    3412:	3f 4f       	sbci	r19, 0xFF	; 255
    3414:	8a e9       	ldi	r24, 0x9A	; 154
    3416:	96 e0       	ldi	r25, 0x06	; 6
    3418:	b9 01       	movw	r22, r18
    341a:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    341e:	80 91 48 06 	lds	r24, 0x0648
    3422:	8f 5f       	subi	r24, 0xFF	; 255
    3424:	80 93 48 06 	sts	0x0648, r24
    3428:	0b c0       	rjmp	.+22     	; 0x3440 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    342a:	80 91 49 06 	lds	r24, 0x0649
    342e:	81 50       	subi	r24, 0x01	; 1
    3430:	80 93 49 06 	sts	0x0649, r24
				prvDeleteTCB( pxTCB );
    3434:	89 81       	ldd	r24, Y+1	; 0x01
    3436:	9a 81       	ldd	r25, Y+2	; 0x02
    3438:	0e 94 97 20 	call	0x412e	; 0x412e <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    343c:	0e 94 ad 20 	call	0x415a	; 0x415a <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3440:	0f 90       	pop	r0
    3442:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3444:	80 91 4d 06 	lds	r24, 0x064D
    3448:	88 23       	and	r24, r24
    344a:	59 f0       	breq	.+22     	; 0x3462 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    344c:	20 91 46 06 	lds	r18, 0x0646
    3450:	30 91 47 06 	lds	r19, 0x0647
    3454:	89 81       	ldd	r24, Y+1	; 0x01
    3456:	9a 81       	ldd	r25, Y+2	; 0x02
    3458:	82 17       	cp	r24, r18
    345a:	93 07       	cpc	r25, r19
    345c:	11 f4       	brne	.+4      	; 0x3462 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    345e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3462:	26 96       	adiw	r28, 0x06	; 6
    3464:	0f b6       	in	r0, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	de bf       	out	0x3e, r29	; 62
    346a:	0f be       	out	0x3f, r0	; 63
    346c:	cd bf       	out	0x3d, r28	; 61
    346e:	cf 91       	pop	r28
    3470:	df 91       	pop	r29
    3472:	08 95       	ret

00003474 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3474:	df 93       	push	r29
    3476:	cf 93       	push	r28
    3478:	00 d0       	rcall	.+0      	; 0x347a <vTaskDelay+0x6>
    347a:	0f 92       	push	r0
    347c:	cd b7       	in	r28, 0x3d	; 61
    347e:	de b7       	in	r29, 0x3e	; 62
    3480:	9b 83       	std	Y+3, r25	; 0x03
    3482:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3484:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3486:	8a 81       	ldd	r24, Y+2	; 0x02
    3488:	9b 81       	ldd	r25, Y+3	; 0x03
    348a:	00 97       	sbiw	r24, 0x00	; 0
    348c:	51 f0       	breq	.+20     	; 0x34a2 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    348e:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3492:	8a 81       	ldd	r24, Y+2	; 0x02
    3494:	9b 81       	ldd	r25, Y+3	; 0x03
    3496:	60 e0       	ldi	r22, 0x00	; 0
    3498:	0e 94 76 26 	call	0x4cec	; 0x4cec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    349c:	0e 94 13 1c 	call	0x3826	; 0x3826 <xTaskResumeAll>
    34a0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    34a2:	89 81       	ldd	r24, Y+1	; 0x01
    34a4:	88 23       	and	r24, r24
    34a6:	11 f4       	brne	.+4      	; 0x34ac <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    34a8:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    34ac:	0f 90       	pop	r0
    34ae:	0f 90       	pop	r0
    34b0:	0f 90       	pop	r0
    34b2:	cf 91       	pop	r28
    34b4:	df 91       	pop	r29
    34b6:	08 95       	ret

000034b8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    34b8:	df 93       	push	r29
    34ba:	cf 93       	push	r28
    34bc:	00 d0       	rcall	.+0      	; 0x34be <vTaskSuspend+0x6>
    34be:	00 d0       	rcall	.+0      	; 0x34c0 <vTaskSuspend+0x8>
    34c0:	00 d0       	rcall	.+0      	; 0x34c2 <vTaskSuspend+0xa>
    34c2:	cd b7       	in	r28, 0x3d	; 61
    34c4:	de b7       	in	r29, 0x3e	; 62
    34c6:	9c 83       	std	Y+4, r25	; 0x04
    34c8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    34ca:	0f b6       	in	r0, 0x3f	; 63
    34cc:	f8 94       	cli
    34ce:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    34d0:	8b 81       	ldd	r24, Y+3	; 0x03
    34d2:	9c 81       	ldd	r25, Y+4	; 0x04
    34d4:	00 97       	sbiw	r24, 0x00	; 0
    34d6:	39 f4       	brne	.+14     	; 0x34e6 <vTaskSuspend+0x2e>
    34d8:	80 91 46 06 	lds	r24, 0x0646
    34dc:	90 91 47 06 	lds	r25, 0x0647
    34e0:	9e 83       	std	Y+6, r25	; 0x06
    34e2:	8d 83       	std	Y+5, r24	; 0x05
    34e4:	04 c0       	rjmp	.+8      	; 0x34ee <vTaskSuspend+0x36>
    34e6:	8b 81       	ldd	r24, Y+3	; 0x03
    34e8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ea:	9e 83       	std	Y+6, r25	; 0x06
    34ec:	8d 83       	std	Y+5, r24	; 0x05
    34ee:	8d 81       	ldd	r24, Y+5	; 0x05
    34f0:	9e 81       	ldd	r25, Y+6	; 0x06
    34f2:	9a 83       	std	Y+2, r25	; 0x02
    34f4:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    34f6:	89 81       	ldd	r24, Y+1	; 0x01
    34f8:	9a 81       	ldd	r25, Y+2	; 0x02
    34fa:	02 96       	adiw	r24, 0x02	; 2
    34fc:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3500:	e9 81       	ldd	r30, Y+1	; 0x01
    3502:	fa 81       	ldd	r31, Y+2	; 0x02
    3504:	84 89       	ldd	r24, Z+20	; 0x14
    3506:	95 89       	ldd	r25, Z+21	; 0x15
    3508:	00 97       	sbiw	r24, 0x00	; 0
    350a:	29 f0       	breq	.+10     	; 0x3516 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    350c:	89 81       	ldd	r24, Y+1	; 0x01
    350e:	9a 81       	ldd	r25, Y+2	; 0x02
    3510:	0c 96       	adiw	r24, 0x0c	; 12
    3512:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3516:	89 81       	ldd	r24, Y+1	; 0x01
    3518:	9a 81       	ldd	r25, Y+2	; 0x02
    351a:	9c 01       	movw	r18, r24
    351c:	2e 5f       	subi	r18, 0xFE	; 254
    351e:	3f 4f       	sbci	r19, 0xFF	; 255
    3520:	83 ea       	ldi	r24, 0xA3	; 163
    3522:	96 e0       	ldi	r25, 0x06	; 6
    3524:	b9 01       	movw	r22, r18
    3526:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    352a:	e9 81       	ldd	r30, Y+1	; 0x01
    352c:	fa 81       	ldd	r31, Y+2	; 0x02
    352e:	81 a5       	ldd	r24, Z+41	; 0x29
    3530:	81 30       	cpi	r24, 0x01	; 1
    3532:	19 f4       	brne	.+6      	; 0x353a <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3534:	e9 81       	ldd	r30, Y+1	; 0x01
    3536:	fa 81       	ldd	r31, Y+2	; 0x02
    3538:	11 a6       	std	Z+41, r1	; 0x29
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    353a:	0f 90       	pop	r0
    353c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    353e:	80 91 4d 06 	lds	r24, 0x064D
    3542:	88 23       	and	r24, r24
    3544:	39 f0       	breq	.+14     	; 0x3554 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3546:	0f b6       	in	r0, 0x3f	; 63
    3548:	f8 94       	cli
    354a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    354c:	0e 94 ad 20 	call	0x415a	; 0x415a <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3550:	0f 90       	pop	r0
    3552:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3554:	20 91 46 06 	lds	r18, 0x0646
    3558:	30 91 47 06 	lds	r19, 0x0647
    355c:	89 81       	ldd	r24, Y+1	; 0x01
    355e:	9a 81       	ldd	r25, Y+2	; 0x02
    3560:	82 17       	cp	r24, r18
    3562:	93 07       	cpc	r25, r19
    3564:	a1 f4       	brne	.+40     	; 0x358e <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3566:	80 91 4d 06 	lds	r24, 0x064D
    356a:	88 23       	and	r24, r24
    356c:	19 f0       	breq	.+6      	; 0x3574 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    356e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    3572:	0d c0       	rjmp	.+26     	; 0x358e <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3574:	90 91 a3 06 	lds	r25, 0x06A3
    3578:	80 91 49 06 	lds	r24, 0x0649
    357c:	98 17       	cp	r25, r24
    357e:	29 f4       	brne	.+10     	; 0x358a <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3580:	10 92 47 06 	sts	0x0647, r1
    3584:	10 92 46 06 	sts	0x0646, r1
    3588:	02 c0       	rjmp	.+4      	; 0x358e <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    358a:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    358e:	26 96       	adiw	r28, 0x06	; 6
    3590:	0f b6       	in	r0, 0x3f	; 63
    3592:	f8 94       	cli
    3594:	de bf       	out	0x3e, r29	; 62
    3596:	0f be       	out	0x3f, r0	; 63
    3598:	cd bf       	out	0x3d, r28	; 61
    359a:	cf 91       	pop	r28
    359c:	df 91       	pop	r29
    359e:	08 95       	ret

000035a0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    35a0:	df 93       	push	r29
    35a2:	cf 93       	push	r28
    35a4:	00 d0       	rcall	.+0      	; 0x35a6 <prvTaskIsTaskSuspended+0x6>
    35a6:	00 d0       	rcall	.+0      	; 0x35a8 <prvTaskIsTaskSuspended+0x8>
    35a8:	0f 92       	push	r0
    35aa:	cd b7       	in	r28, 0x3d	; 61
    35ac:	de b7       	in	r29, 0x3e	; 62
    35ae:	9d 83       	std	Y+5, r25	; 0x05
    35b0:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    35b2:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    35b4:	8c 81       	ldd	r24, Y+4	; 0x04
    35b6:	9d 81       	ldd	r25, Y+5	; 0x05
    35b8:	9a 83       	std	Y+2, r25	; 0x02
    35ba:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    35bc:	e9 81       	ldd	r30, Y+1	; 0x01
    35be:	fa 81       	ldd	r31, Y+2	; 0x02
    35c0:	82 85       	ldd	r24, Z+10	; 0x0a
    35c2:	93 85       	ldd	r25, Z+11	; 0x0b
    35c4:	26 e0       	ldi	r18, 0x06	; 6
    35c6:	83 3a       	cpi	r24, 0xA3	; 163
    35c8:	92 07       	cpc	r25, r18
    35ca:	81 f4       	brne	.+32     	; 0x35ec <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    35cc:	e9 81       	ldd	r30, Y+1	; 0x01
    35ce:	fa 81       	ldd	r31, Y+2	; 0x02
    35d0:	84 89       	ldd	r24, Z+20	; 0x14
    35d2:	95 89       	ldd	r25, Z+21	; 0x15
    35d4:	26 e0       	ldi	r18, 0x06	; 6
    35d6:	81 39       	cpi	r24, 0x91	; 145
    35d8:	92 07       	cpc	r25, r18
    35da:	41 f0       	breq	.+16     	; 0x35ec <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    35dc:	e9 81       	ldd	r30, Y+1	; 0x01
    35de:	fa 81       	ldd	r31, Y+2	; 0x02
    35e0:	84 89       	ldd	r24, Z+20	; 0x14
    35e2:	95 89       	ldd	r25, Z+21	; 0x15
    35e4:	00 97       	sbiw	r24, 0x00	; 0
    35e6:	11 f4       	brne	.+4      	; 0x35ec <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    35ec:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    35ee:	0f 90       	pop	r0
    35f0:	0f 90       	pop	r0
    35f2:	0f 90       	pop	r0
    35f4:	0f 90       	pop	r0
    35f6:	0f 90       	pop	r0
    35f8:	cf 91       	pop	r28
    35fa:	df 91       	pop	r29
    35fc:	08 95       	ret

000035fe <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    35fe:	df 93       	push	r29
    3600:	cf 93       	push	r28
    3602:	00 d0       	rcall	.+0      	; 0x3604 <vTaskResume+0x6>
    3604:	00 d0       	rcall	.+0      	; 0x3606 <vTaskResume+0x8>
    3606:	cd b7       	in	r28, 0x3d	; 61
    3608:	de b7       	in	r29, 0x3e	; 62
    360a:	9c 83       	std	Y+4, r25	; 0x04
    360c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    360e:	8b 81       	ldd	r24, Y+3	; 0x03
    3610:	9c 81       	ldd	r25, Y+4	; 0x04
    3612:	9a 83       	std	Y+2, r25	; 0x02
    3614:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3616:	20 91 46 06 	lds	r18, 0x0646
    361a:	30 91 47 06 	lds	r19, 0x0647
    361e:	89 81       	ldd	r24, Y+1	; 0x01
    3620:	9a 81       	ldd	r25, Y+2	; 0x02
    3622:	82 17       	cp	r24, r18
    3624:	93 07       	cpc	r25, r19
    3626:	09 f4       	brne	.+2      	; 0x362a <vTaskResume+0x2c>
    3628:	47 c0       	rjmp	.+142    	; 0x36b8 <vTaskResume+0xba>
    362a:	89 81       	ldd	r24, Y+1	; 0x01
    362c:	9a 81       	ldd	r25, Y+2	; 0x02
    362e:	00 97       	sbiw	r24, 0x00	; 0
    3630:	09 f4       	brne	.+2      	; 0x3634 <vTaskResume+0x36>
    3632:	42 c0       	rjmp	.+132    	; 0x36b8 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3634:	0f b6       	in	r0, 0x3f	; 63
    3636:	f8 94       	cli
    3638:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    363a:	89 81       	ldd	r24, Y+1	; 0x01
    363c:	9a 81       	ldd	r25, Y+2	; 0x02
    363e:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <prvTaskIsTaskSuspended>
    3642:	88 23       	and	r24, r24
    3644:	b9 f1       	breq	.+110    	; 0x36b4 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	9a 81       	ldd	r25, Y+2	; 0x02
    364a:	02 96       	adiw	r24, 0x02	; 2
    364c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3650:	e9 81       	ldd	r30, Y+1	; 0x01
    3652:	fa 81       	ldd	r31, Y+2	; 0x02
    3654:	96 89       	ldd	r25, Z+22	; 0x16
    3656:	80 91 4c 06 	lds	r24, 0x064C
    365a:	89 17       	cp	r24, r25
    365c:	28 f4       	brcc	.+10     	; 0x3668 <vTaskResume+0x6a>
    365e:	e9 81       	ldd	r30, Y+1	; 0x01
    3660:	fa 81       	ldd	r31, Y+2	; 0x02
    3662:	86 89       	ldd	r24, Z+22	; 0x16
    3664:	80 93 4c 06 	sts	0x064C, r24
    3668:	e9 81       	ldd	r30, Y+1	; 0x01
    366a:	fa 81       	ldd	r31, Y+2	; 0x02
    366c:	86 89       	ldd	r24, Z+22	; 0x16
    366e:	28 2f       	mov	r18, r24
    3670:	30 e0       	ldi	r19, 0x00	; 0
    3672:	c9 01       	movw	r24, r18
    3674:	88 0f       	add	r24, r24
    3676:	99 1f       	adc	r25, r25
    3678:	88 0f       	add	r24, r24
    367a:	99 1f       	adc	r25, r25
    367c:	88 0f       	add	r24, r24
    367e:	99 1f       	adc	r25, r25
    3680:	82 0f       	add	r24, r18
    3682:	93 1f       	adc	r25, r19
    3684:	ac 01       	movw	r20, r24
    3686:	49 5a       	subi	r20, 0xA9	; 169
    3688:	59 4f       	sbci	r21, 0xF9	; 249
    368a:	89 81       	ldd	r24, Y+1	; 0x01
    368c:	9a 81       	ldd	r25, Y+2	; 0x02
    368e:	9c 01       	movw	r18, r24
    3690:	2e 5f       	subi	r18, 0xFE	; 254
    3692:	3f 4f       	sbci	r19, 0xFF	; 255
    3694:	ca 01       	movw	r24, r20
    3696:	b9 01       	movw	r22, r18
    3698:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    369c:	e9 81       	ldd	r30, Y+1	; 0x01
    369e:	fa 81       	ldd	r31, Y+2	; 0x02
    36a0:	96 89       	ldd	r25, Z+22	; 0x16
    36a2:	e0 91 46 06 	lds	r30, 0x0646
    36a6:	f0 91 47 06 	lds	r31, 0x0647
    36aa:	86 89       	ldd	r24, Z+22	; 0x16
    36ac:	98 17       	cp	r25, r24
    36ae:	10 f0       	brcs	.+4      	; 0x36b4 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    36b0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    36b4:	0f 90       	pop	r0
    36b6:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    36b8:	0f 90       	pop	r0
    36ba:	0f 90       	pop	r0
    36bc:	0f 90       	pop	r0
    36be:	0f 90       	pop	r0
    36c0:	cf 91       	pop	r28
    36c2:	df 91       	pop	r29
    36c4:	08 95       	ret

000036c6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    36c6:	df 93       	push	r29
    36c8:	cf 93       	push	r28
    36ca:	00 d0       	rcall	.+0      	; 0x36cc <xTaskResumeFromISR+0x6>
    36cc:	00 d0       	rcall	.+0      	; 0x36ce <xTaskResumeFromISR+0x8>
    36ce:	00 d0       	rcall	.+0      	; 0x36d0 <xTaskResumeFromISR+0xa>
    36d0:	cd b7       	in	r28, 0x3d	; 61
    36d2:	de b7       	in	r29, 0x3e	; 62
    36d4:	9e 83       	std	Y+6, r25	; 0x06
    36d6:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    36d8:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    36da:	8d 81       	ldd	r24, Y+5	; 0x05
    36dc:	9e 81       	ldd	r25, Y+6	; 0x06
    36de:	9b 83       	std	Y+3, r25	; 0x03
    36e0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36e2:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    36e4:	8a 81       	ldd	r24, Y+2	; 0x02
    36e6:	9b 81       	ldd	r25, Y+3	; 0x03
    36e8:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <prvTaskIsTaskSuspended>
    36ec:	88 23       	and	r24, r24
    36ee:	09 f4       	brne	.+2      	; 0x36f2 <xTaskResumeFromISR+0x2c>
    36f0:	46 c0       	rjmp	.+140    	; 0x377e <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    36f2:	80 91 56 06 	lds	r24, 0x0656
    36f6:	88 23       	and	r24, r24
    36f8:	c1 f5       	brne	.+112    	; 0x376a <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    36fa:	ea 81       	ldd	r30, Y+2	; 0x02
    36fc:	fb 81       	ldd	r31, Y+3	; 0x03
    36fe:	96 89       	ldd	r25, Z+22	; 0x16
    3700:	e0 91 46 06 	lds	r30, 0x0646
    3704:	f0 91 47 06 	lds	r31, 0x0647
    3708:	86 89       	ldd	r24, Z+22	; 0x16
    370a:	98 17       	cp	r25, r24
    370c:	10 f0       	brcs	.+4      	; 0x3712 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    370e:	81 e0       	ldi	r24, 0x01	; 1
    3710:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3712:	8a 81       	ldd	r24, Y+2	; 0x02
    3714:	9b 81       	ldd	r25, Y+3	; 0x03
    3716:	02 96       	adiw	r24, 0x02	; 2
    3718:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    371c:	ea 81       	ldd	r30, Y+2	; 0x02
    371e:	fb 81       	ldd	r31, Y+3	; 0x03
    3720:	96 89       	ldd	r25, Z+22	; 0x16
    3722:	80 91 4c 06 	lds	r24, 0x064C
    3726:	89 17       	cp	r24, r25
    3728:	28 f4       	brcc	.+10     	; 0x3734 <xTaskResumeFromISR+0x6e>
    372a:	ea 81       	ldd	r30, Y+2	; 0x02
    372c:	fb 81       	ldd	r31, Y+3	; 0x03
    372e:	86 89       	ldd	r24, Z+22	; 0x16
    3730:	80 93 4c 06 	sts	0x064C, r24
    3734:	ea 81       	ldd	r30, Y+2	; 0x02
    3736:	fb 81       	ldd	r31, Y+3	; 0x03
    3738:	86 89       	ldd	r24, Z+22	; 0x16
    373a:	28 2f       	mov	r18, r24
    373c:	30 e0       	ldi	r19, 0x00	; 0
    373e:	c9 01       	movw	r24, r18
    3740:	88 0f       	add	r24, r24
    3742:	99 1f       	adc	r25, r25
    3744:	88 0f       	add	r24, r24
    3746:	99 1f       	adc	r25, r25
    3748:	88 0f       	add	r24, r24
    374a:	99 1f       	adc	r25, r25
    374c:	82 0f       	add	r24, r18
    374e:	93 1f       	adc	r25, r19
    3750:	ac 01       	movw	r20, r24
    3752:	49 5a       	subi	r20, 0xA9	; 169
    3754:	59 4f       	sbci	r21, 0xF9	; 249
    3756:	8a 81       	ldd	r24, Y+2	; 0x02
    3758:	9b 81       	ldd	r25, Y+3	; 0x03
    375a:	9c 01       	movw	r18, r24
    375c:	2e 5f       	subi	r18, 0xFE	; 254
    375e:	3f 4f       	sbci	r19, 0xFF	; 255
    3760:	ca 01       	movw	r24, r20
    3762:	b9 01       	movw	r22, r18
    3764:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    3768:	0a c0       	rjmp	.+20     	; 0x377e <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    376a:	8a 81       	ldd	r24, Y+2	; 0x02
    376c:	9b 81       	ldd	r25, Y+3	; 0x03
    376e:	9c 01       	movw	r18, r24
    3770:	24 5f       	subi	r18, 0xF4	; 244
    3772:	3f 4f       	sbci	r19, 0xFF	; 255
    3774:	81 e9       	ldi	r24, 0x91	; 145
    3776:	96 e0       	ldi	r25, 0x06	; 6
    3778:	b9 01       	movw	r22, r18
    377a:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    377e:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    3780:	26 96       	adiw	r28, 0x06	; 6
    3782:	0f b6       	in	r0, 0x3f	; 63
    3784:	f8 94       	cli
    3786:	de bf       	out	0x3e, r29	; 62
    3788:	0f be       	out	0x3f, r0	; 63
    378a:	cd bf       	out	0x3d, r28	; 61
    378c:	cf 91       	pop	r28
    378e:	df 91       	pop	r29
    3790:	08 95       	ret

00003792 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3792:	ef 92       	push	r14
    3794:	ff 92       	push	r15
    3796:	0f 93       	push	r16
    3798:	df 93       	push	r29
    379a:	cf 93       	push	r28
    379c:	0f 92       	push	r0
    379e:	cd b7       	in	r28, 0x3d	; 61
    37a0:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    37a2:	8d e1       	ldi	r24, 0x1D	; 29
    37a4:	90 e2       	ldi	r25, 0x20	; 32
    37a6:	20 e6       	ldi	r18, 0x60	; 96
    37a8:	30 e0       	ldi	r19, 0x00	; 0
    37aa:	e4 e5       	ldi	r30, 0x54	; 84
    37ac:	f6 e0       	ldi	r31, 0x06	; 6
    37ae:	b9 01       	movw	r22, r18
    37b0:	45 e5       	ldi	r20, 0x55	; 85
    37b2:	50 e0       	ldi	r21, 0x00	; 0
    37b4:	20 e0       	ldi	r18, 0x00	; 0
    37b6:	30 e0       	ldi	r19, 0x00	; 0
    37b8:	00 e0       	ldi	r16, 0x00	; 0
    37ba:	7f 01       	movw	r14, r30
    37bc:	0e 94 15 18 	call	0x302a	; 0x302a <xTaskCreate>
    37c0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    37c2:	89 81       	ldd	r24, Y+1	; 0x01
    37c4:	81 30       	cpi	r24, 0x01	; 1
    37c6:	81 f4       	brne	.+32     	; 0x37e8 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    37c8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    37ca:	8f ef       	ldi	r24, 0xFF	; 255
    37cc:	9f ef       	ldi	r25, 0xFF	; 255
    37ce:	90 93 53 06 	sts	0x0653, r25
    37d2:	80 93 52 06 	sts	0x0652, r24
		xSchedulerRunning = pdTRUE;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	80 93 4d 06 	sts	0x064D, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    37dc:	10 92 4b 06 	sts	0x064B, r1
    37e0:	10 92 4a 06 	sts	0x064A, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    37e4:	0e 94 c3 06 	call	0xd86	; 0xd86 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    37e8:	0f 90       	pop	r0
    37ea:	cf 91       	pop	r28
    37ec:	df 91       	pop	r29
    37ee:	0f 91       	pop	r16
    37f0:	ff 90       	pop	r15
    37f2:	ef 90       	pop	r14
    37f4:	08 95       	ret

000037f6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    37f6:	df 93       	push	r29
    37f8:	cf 93       	push	r28
    37fa:	cd b7       	in	r28, 0x3d	; 61
    37fc:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    37fe:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3800:	10 92 4d 06 	sts	0x064D, r1
	vPortEndScheduler();
    3804:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortEndScheduler>
}
    3808:	cf 91       	pop	r28
    380a:	df 91       	pop	r29
    380c:	08 95       	ret

0000380e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    380e:	df 93       	push	r29
    3810:	cf 93       	push	r28
    3812:	cd b7       	in	r28, 0x3d	; 61
    3814:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3816:	80 91 56 06 	lds	r24, 0x0656
    381a:	8f 5f       	subi	r24, 0xFF	; 255
    381c:	80 93 56 06 	sts	0x0656, r24
}
    3820:	cf 91       	pop	r28
    3822:	df 91       	pop	r29
    3824:	08 95       	ret

00003826 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3826:	df 93       	push	r29
    3828:	cf 93       	push	r28
    382a:	00 d0       	rcall	.+0      	; 0x382c <xTaskResumeAll+0x6>
    382c:	00 d0       	rcall	.+0      	; 0x382e <xTaskResumeAll+0x8>
    382e:	cd b7       	in	r28, 0x3d	; 61
    3830:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3832:	1c 82       	std	Y+4, r1	; 0x04
    3834:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    3836:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3838:	0f b6       	in	r0, 0x3f	; 63
    383a:	f8 94       	cli
    383c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    383e:	80 91 56 06 	lds	r24, 0x0656
    3842:	81 50       	subi	r24, 0x01	; 1
    3844:	80 93 56 06 	sts	0x0656, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3848:	80 91 56 06 	lds	r24, 0x0656
    384c:	88 23       	and	r24, r24
    384e:	09 f0       	breq	.+2      	; 0x3852 <xTaskResumeAll+0x2c>
    3850:	73 c0       	rjmp	.+230    	; 0x3938 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3852:	80 91 49 06 	lds	r24, 0x0649
    3856:	88 23       	and	r24, r24
    3858:	09 f4       	brne	.+2      	; 0x385c <xTaskResumeAll+0x36>
    385a:	6e c0       	rjmp	.+220    	; 0x3938 <xTaskResumeAll+0x112>
    385c:	45 c0       	rjmp	.+138    	; 0x38e8 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    385e:	e0 91 96 06 	lds	r30, 0x0696
    3862:	f0 91 97 06 	lds	r31, 0x0697
    3866:	86 81       	ldd	r24, Z+6	; 0x06
    3868:	97 81       	ldd	r25, Z+7	; 0x07
    386a:	9c 83       	std	Y+4, r25	; 0x04
    386c:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    386e:	8b 81       	ldd	r24, Y+3	; 0x03
    3870:	9c 81       	ldd	r25, Y+4	; 0x04
    3872:	0c 96       	adiw	r24, 0x0c	; 12
    3874:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3878:	8b 81       	ldd	r24, Y+3	; 0x03
    387a:	9c 81       	ldd	r25, Y+4	; 0x04
    387c:	02 96       	adiw	r24, 0x02	; 2
    387e:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	96 89       	ldd	r25, Z+22	; 0x16
    3888:	80 91 4c 06 	lds	r24, 0x064C
    388c:	89 17       	cp	r24, r25
    388e:	28 f4       	brcc	.+10     	; 0x389a <xTaskResumeAll+0x74>
    3890:	eb 81       	ldd	r30, Y+3	; 0x03
    3892:	fc 81       	ldd	r31, Y+4	; 0x04
    3894:	86 89       	ldd	r24, Z+22	; 0x16
    3896:	80 93 4c 06 	sts	0x064C, r24
    389a:	eb 81       	ldd	r30, Y+3	; 0x03
    389c:	fc 81       	ldd	r31, Y+4	; 0x04
    389e:	86 89       	ldd	r24, Z+22	; 0x16
    38a0:	28 2f       	mov	r18, r24
    38a2:	30 e0       	ldi	r19, 0x00	; 0
    38a4:	c9 01       	movw	r24, r18
    38a6:	88 0f       	add	r24, r24
    38a8:	99 1f       	adc	r25, r25
    38aa:	88 0f       	add	r24, r24
    38ac:	99 1f       	adc	r25, r25
    38ae:	88 0f       	add	r24, r24
    38b0:	99 1f       	adc	r25, r25
    38b2:	82 0f       	add	r24, r18
    38b4:	93 1f       	adc	r25, r19
    38b6:	ac 01       	movw	r20, r24
    38b8:	49 5a       	subi	r20, 0xA9	; 169
    38ba:	59 4f       	sbci	r21, 0xF9	; 249
    38bc:	8b 81       	ldd	r24, Y+3	; 0x03
    38be:	9c 81       	ldd	r25, Y+4	; 0x04
    38c0:	9c 01       	movw	r18, r24
    38c2:	2e 5f       	subi	r18, 0xFE	; 254
    38c4:	3f 4f       	sbci	r19, 0xFF	; 255
    38c6:	ca 01       	movw	r24, r20
    38c8:	b9 01       	movw	r22, r18
    38ca:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38ce:	eb 81       	ldd	r30, Y+3	; 0x03
    38d0:	fc 81       	ldd	r31, Y+4	; 0x04
    38d2:	96 89       	ldd	r25, Z+22	; 0x16
    38d4:	e0 91 46 06 	lds	r30, 0x0646
    38d8:	f0 91 47 06 	lds	r31, 0x0647
    38dc:	86 89       	ldd	r24, Z+22	; 0x16
    38de:	98 17       	cp	r25, r24
    38e0:	18 f0       	brcs	.+6      	; 0x38e8 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    38e2:	81 e0       	ldi	r24, 0x01	; 1
    38e4:	80 93 4f 06 	sts	0x064F, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38e8:	80 91 91 06 	lds	r24, 0x0691
    38ec:	88 23       	and	r24, r24
    38ee:	09 f0       	breq	.+2      	; 0x38f2 <xTaskResumeAll+0xcc>
    38f0:	b6 cf       	rjmp	.-148    	; 0x385e <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    38f2:	8b 81       	ldd	r24, Y+3	; 0x03
    38f4:	9c 81       	ldd	r25, Y+4	; 0x04
    38f6:	00 97       	sbiw	r24, 0x00	; 0
    38f8:	11 f0       	breq	.+4      	; 0x38fe <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    38fa:	0e 94 ad 20 	call	0x415a	; 0x415a <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    38fe:	80 91 4e 06 	lds	r24, 0x064E
    3902:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3904:	89 81       	ldd	r24, Y+1	; 0x01
    3906:	88 23       	and	r24, r24
    3908:	79 f0       	breq	.+30     	; 0x3928 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    390a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <xTaskIncrementTick>
    390e:	88 23       	and	r24, r24
    3910:	19 f0       	breq	.+6      	; 0x3918 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    3912:	81 e0       	ldi	r24, 0x01	; 1
    3914:	80 93 4f 06 	sts	0x064F, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3918:	89 81       	ldd	r24, Y+1	; 0x01
    391a:	81 50       	subi	r24, 0x01	; 1
    391c:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    391e:	89 81       	ldd	r24, Y+1	; 0x01
    3920:	88 23       	and	r24, r24
    3922:	99 f7       	brne	.-26     	; 0x390a <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3924:	10 92 4e 06 	sts	0x064E, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3928:	80 91 4f 06 	lds	r24, 0x064F
    392c:	88 23       	and	r24, r24
    392e:	21 f0       	breq	.+8      	; 0x3938 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3930:	81 e0       	ldi	r24, 0x01	; 1
    3932:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3934:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3938:	0f 90       	pop	r0
    393a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    393c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    393e:	0f 90       	pop	r0
    3940:	0f 90       	pop	r0
    3942:	0f 90       	pop	r0
    3944:	0f 90       	pop	r0
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	00 d0       	rcall	.+0      	; 0x3952 <xTaskGetTickCount+0x6>
    3952:	cd b7       	in	r28, 0x3d	; 61
    3954:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3956:	0f b6       	in	r0, 0x3f	; 63
    3958:	f8 94       	cli
    395a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    395c:	80 91 4a 06 	lds	r24, 0x064A
    3960:	90 91 4b 06 	lds	r25, 0x064B
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3968:	0f 90       	pop	r0
    396a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    396c:	89 81       	ldd	r24, Y+1	; 0x01
    396e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3970:	0f 90       	pop	r0
    3972:	0f 90       	pop	r0
    3974:	cf 91       	pop	r28
    3976:	df 91       	pop	r29
    3978:	08 95       	ret

0000397a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    397a:	df 93       	push	r29
    397c:	cf 93       	push	r28
    397e:	00 d0       	rcall	.+0      	; 0x3980 <xTaskGetTickCountFromISR+0x6>
    3980:	0f 92       	push	r0
    3982:	cd b7       	in	r28, 0x3d	; 61
    3984:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3986:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3988:	80 91 4a 06 	lds	r24, 0x064A
    398c:	90 91 4b 06 	lds	r25, 0x064B
    3990:	9b 83       	std	Y+3, r25	; 0x03
    3992:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3994:	8a 81       	ldd	r24, Y+2	; 0x02
    3996:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3998:	0f 90       	pop	r0
    399a:	0f 90       	pop	r0
    399c:	0f 90       	pop	r0
    399e:	cf 91       	pop	r28
    39a0:	df 91       	pop	r29
    39a2:	08 95       	ret

000039a4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    39a4:	df 93       	push	r29
    39a6:	cf 93       	push	r28
    39a8:	cd b7       	in	r28, 0x3d	; 61
    39aa:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    39ac:	80 91 49 06 	lds	r24, 0x0649
}
    39b0:	cf 91       	pop	r28
    39b2:	df 91       	pop	r29
    39b4:	08 95       	ret

000039b6 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    39b6:	df 93       	push	r29
    39b8:	cf 93       	push	r28
    39ba:	00 d0       	rcall	.+0      	; 0x39bc <pcTaskGetName+0x6>
    39bc:	00 d0       	rcall	.+0      	; 0x39be <pcTaskGetName+0x8>
    39be:	00 d0       	rcall	.+0      	; 0x39c0 <pcTaskGetName+0xa>
    39c0:	cd b7       	in	r28, 0x3d	; 61
    39c2:	de b7       	in	r29, 0x3e	; 62
    39c4:	9c 83       	std	Y+4, r25	; 0x04
    39c6:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    39c8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ca:	9c 81       	ldd	r25, Y+4	; 0x04
    39cc:	00 97       	sbiw	r24, 0x00	; 0
    39ce:	39 f4       	brne	.+14     	; 0x39de <pcTaskGetName+0x28>
    39d0:	80 91 46 06 	lds	r24, 0x0646
    39d4:	90 91 47 06 	lds	r25, 0x0647
    39d8:	9e 83       	std	Y+6, r25	; 0x06
    39da:	8d 83       	std	Y+5, r24	; 0x05
    39dc:	04 c0       	rjmp	.+8      	; 0x39e6 <pcTaskGetName+0x30>
    39de:	8b 81       	ldd	r24, Y+3	; 0x03
    39e0:	9c 81       	ldd	r25, Y+4	; 0x04
    39e2:	9e 83       	std	Y+6, r25	; 0x06
    39e4:	8d 83       	std	Y+5, r24	; 0x05
    39e6:	8d 81       	ldd	r24, Y+5	; 0x05
    39e8:	9e 81       	ldd	r25, Y+6	; 0x06
    39ea:	9a 83       	std	Y+2, r25	; 0x02
    39ec:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    39ee:	89 81       	ldd	r24, Y+1	; 0x01
    39f0:	9a 81       	ldd	r25, Y+2	; 0x02
    39f2:	49 96       	adiw	r24, 0x19	; 25
}
    39f4:	26 96       	adiw	r28, 0x06	; 6
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	f8 94       	cli
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	0f be       	out	0x3f, r0	; 63
    39fe:	cd bf       	out	0x3d, r28	; 61
    3a00:	cf 91       	pop	r28
    3a02:	df 91       	pop	r29
    3a04:	08 95       	ret

00003a06 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3a06:	df 93       	push	r29
    3a08:	cf 93       	push	r28
    3a0a:	cd b7       	in	r28, 0x3d	; 61
    3a0c:	de b7       	in	r29, 0x3e	; 62
    3a0e:	29 97       	sbiw	r28, 0x09	; 9
    3a10:	0f b6       	in	r0, 0x3f	; 63
    3a12:	f8 94       	cli
    3a14:	de bf       	out	0x3e, r29	; 62
    3a16:	0f be       	out	0x3f, r0	; 63
    3a18:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3a1a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a1c:	80 91 56 06 	lds	r24, 0x0656
    3a20:	88 23       	and	r24, r24
    3a22:	09 f0       	breq	.+2      	; 0x3a26 <xTaskIncrementTick+0x20>
    3a24:	c0 c0       	rjmp	.+384    	; 0x3ba6 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3a26:	80 91 4a 06 	lds	r24, 0x064A
    3a2a:	90 91 4b 06 	lds	r25, 0x064B
    3a2e:	01 96       	adiw	r24, 0x01	; 1
    3a30:	9c 83       	std	Y+4, r25	; 0x04
    3a32:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3a34:	8b 81       	ldd	r24, Y+3	; 0x03
    3a36:	9c 81       	ldd	r25, Y+4	; 0x04
    3a38:	90 93 4b 06 	sts	0x064B, r25
    3a3c:	80 93 4a 06 	sts	0x064A, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3a40:	8b 81       	ldd	r24, Y+3	; 0x03
    3a42:	9c 81       	ldd	r25, Y+4	; 0x04
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	d9 f4       	brne	.+54     	; 0x3a7e <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3a48:	80 91 8d 06 	lds	r24, 0x068D
    3a4c:	90 91 8e 06 	lds	r25, 0x068E
    3a50:	9a 83       	std	Y+2, r25	; 0x02
    3a52:	89 83       	std	Y+1, r24	; 0x01
    3a54:	80 91 8f 06 	lds	r24, 0x068F
    3a58:	90 91 90 06 	lds	r25, 0x0690
    3a5c:	90 93 8e 06 	sts	0x068E, r25
    3a60:	80 93 8d 06 	sts	0x068D, r24
    3a64:	89 81       	ldd	r24, Y+1	; 0x01
    3a66:	9a 81       	ldd	r25, Y+2	; 0x02
    3a68:	90 93 90 06 	sts	0x0690, r25
    3a6c:	80 93 8f 06 	sts	0x068F, r24
    3a70:	80 91 50 06 	lds	r24, 0x0650
    3a74:	8f 5f       	subi	r24, 0xFF	; 255
    3a76:	80 93 50 06 	sts	0x0650, r24
    3a7a:	0e 94 ad 20 	call	0x415a	; 0x415a <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    3a7e:	20 91 52 06 	lds	r18, 0x0652
    3a82:	30 91 53 06 	lds	r19, 0x0653
    3a86:	8b 81       	ldd	r24, Y+3	; 0x03
    3a88:	9c 81       	ldd	r25, Y+4	; 0x04
    3a8a:	82 17       	cp	r24, r18
    3a8c:	93 07       	cpc	r25, r19
    3a8e:	08 f4       	brcc	.+2      	; 0x3a92 <xTaskIncrementTick+0x8c>
    3a90:	71 c0       	rjmp	.+226    	; 0x3b74 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3a92:	e0 91 8d 06 	lds	r30, 0x068D
    3a96:	f0 91 8e 06 	lds	r31, 0x068E
    3a9a:	80 81       	ld	r24, Z
    3a9c:	88 23       	and	r24, r24
    3a9e:	39 f4       	brne	.+14     	; 0x3aae <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3aa0:	8f ef       	ldi	r24, 0xFF	; 255
    3aa2:	9f ef       	ldi	r25, 0xFF	; 255
    3aa4:	90 93 53 06 	sts	0x0653, r25
    3aa8:	80 93 52 06 	sts	0x0652, r24
    3aac:	63 c0       	rjmp	.+198    	; 0x3b74 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3aae:	e0 91 8d 06 	lds	r30, 0x068D
    3ab2:	f0 91 8e 06 	lds	r31, 0x068E
    3ab6:	05 80       	ldd	r0, Z+5	; 0x05
    3ab8:	f6 81       	ldd	r31, Z+6	; 0x06
    3aba:	e0 2d       	mov	r30, r0
    3abc:	86 81       	ldd	r24, Z+6	; 0x06
    3abe:	97 81       	ldd	r25, Z+7	; 0x07
    3ac0:	99 87       	std	Y+9, r25	; 0x09
    3ac2:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3ac4:	e8 85       	ldd	r30, Y+8	; 0x08
    3ac6:	f9 85       	ldd	r31, Y+9	; 0x09
    3ac8:	82 81       	ldd	r24, Z+2	; 0x02
    3aca:	93 81       	ldd	r25, Z+3	; 0x03
    3acc:	9f 83       	std	Y+7, r25	; 0x07
    3ace:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    3ad0:	2b 81       	ldd	r18, Y+3	; 0x03
    3ad2:	3c 81       	ldd	r19, Y+4	; 0x04
    3ad4:	8e 81       	ldd	r24, Y+6	; 0x06
    3ad6:	9f 81       	ldd	r25, Y+7	; 0x07
    3ad8:	28 17       	cp	r18, r24
    3ada:	39 07       	cpc	r19, r25
    3adc:	38 f4       	brcc	.+14     	; 0x3aec <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3ade:	8e 81       	ldd	r24, Y+6	; 0x06
    3ae0:	9f 81       	ldd	r25, Y+7	; 0x07
    3ae2:	90 93 53 06 	sts	0x0653, r25
    3ae6:	80 93 52 06 	sts	0x0652, r24
    3aea:	44 c0       	rjmp	.+136    	; 0x3b74 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3aec:	88 85       	ldd	r24, Y+8	; 0x08
    3aee:	99 85       	ldd	r25, Y+9	; 0x09
    3af0:	02 96       	adiw	r24, 0x02	; 2
    3af2:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3af6:	e8 85       	ldd	r30, Y+8	; 0x08
    3af8:	f9 85       	ldd	r31, Y+9	; 0x09
    3afa:	84 89       	ldd	r24, Z+20	; 0x14
    3afc:	95 89       	ldd	r25, Z+21	; 0x15
    3afe:	00 97       	sbiw	r24, 0x00	; 0
    3b00:	29 f0       	breq	.+10     	; 0x3b0c <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b02:	88 85       	ldd	r24, Y+8	; 0x08
    3b04:	99 85       	ldd	r25, Y+9	; 0x09
    3b06:	0c 96       	adiw	r24, 0x0c	; 12
    3b08:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3b0c:	e8 85       	ldd	r30, Y+8	; 0x08
    3b0e:	f9 85       	ldd	r31, Y+9	; 0x09
    3b10:	96 89       	ldd	r25, Z+22	; 0x16
    3b12:	80 91 4c 06 	lds	r24, 0x064C
    3b16:	89 17       	cp	r24, r25
    3b18:	28 f4       	brcc	.+10     	; 0x3b24 <xTaskIncrementTick+0x11e>
    3b1a:	e8 85       	ldd	r30, Y+8	; 0x08
    3b1c:	f9 85       	ldd	r31, Y+9	; 0x09
    3b1e:	86 89       	ldd	r24, Z+22	; 0x16
    3b20:	80 93 4c 06 	sts	0x064C, r24
    3b24:	e8 85       	ldd	r30, Y+8	; 0x08
    3b26:	f9 85       	ldd	r31, Y+9	; 0x09
    3b28:	86 89       	ldd	r24, Z+22	; 0x16
    3b2a:	28 2f       	mov	r18, r24
    3b2c:	30 e0       	ldi	r19, 0x00	; 0
    3b2e:	c9 01       	movw	r24, r18
    3b30:	88 0f       	add	r24, r24
    3b32:	99 1f       	adc	r25, r25
    3b34:	88 0f       	add	r24, r24
    3b36:	99 1f       	adc	r25, r25
    3b38:	88 0f       	add	r24, r24
    3b3a:	99 1f       	adc	r25, r25
    3b3c:	82 0f       	add	r24, r18
    3b3e:	93 1f       	adc	r25, r19
    3b40:	ac 01       	movw	r20, r24
    3b42:	49 5a       	subi	r20, 0xA9	; 169
    3b44:	59 4f       	sbci	r21, 0xF9	; 249
    3b46:	88 85       	ldd	r24, Y+8	; 0x08
    3b48:	99 85       	ldd	r25, Y+9	; 0x09
    3b4a:	9c 01       	movw	r18, r24
    3b4c:	2e 5f       	subi	r18, 0xFE	; 254
    3b4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3b50:	ca 01       	movw	r24, r20
    3b52:	b9 01       	movw	r22, r18
    3b54:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b58:	e8 85       	ldd	r30, Y+8	; 0x08
    3b5a:	f9 85       	ldd	r31, Y+9	; 0x09
    3b5c:	96 89       	ldd	r25, Z+22	; 0x16
    3b5e:	e0 91 46 06 	lds	r30, 0x0646
    3b62:	f0 91 47 06 	lds	r31, 0x0647
    3b66:	86 89       	ldd	r24, Z+22	; 0x16
    3b68:	98 17       	cp	r25, r24
    3b6a:	08 f4       	brcc	.+2      	; 0x3b6e <xTaskIncrementTick+0x168>
    3b6c:	92 cf       	rjmp	.-220    	; 0x3a92 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    3b6e:	81 e0       	ldi	r24, 0x01	; 1
    3b70:	8d 83       	std	Y+5, r24	; 0x05
    3b72:	8f cf       	rjmp	.-226    	; 0x3a92 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3b74:	e0 91 46 06 	lds	r30, 0x0646
    3b78:	f0 91 47 06 	lds	r31, 0x0647
    3b7c:	86 89       	ldd	r24, Z+22	; 0x16
    3b7e:	28 2f       	mov	r18, r24
    3b80:	30 e0       	ldi	r19, 0x00	; 0
    3b82:	c9 01       	movw	r24, r18
    3b84:	88 0f       	add	r24, r24
    3b86:	99 1f       	adc	r25, r25
    3b88:	88 0f       	add	r24, r24
    3b8a:	99 1f       	adc	r25, r25
    3b8c:	88 0f       	add	r24, r24
    3b8e:	99 1f       	adc	r25, r25
    3b90:	82 0f       	add	r24, r18
    3b92:	93 1f       	adc	r25, r19
    3b94:	fc 01       	movw	r30, r24
    3b96:	e9 5a       	subi	r30, 0xA9	; 169
    3b98:	f9 4f       	sbci	r31, 0xF9	; 249
    3b9a:	80 81       	ld	r24, Z
    3b9c:	82 30       	cpi	r24, 0x02	; 2
    3b9e:	40 f0       	brcs	.+16     	; 0x3bb0 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    3ba0:	81 e0       	ldi	r24, 0x01	; 1
    3ba2:	8d 83       	std	Y+5, r24	; 0x05
    3ba4:	05 c0       	rjmp	.+10     	; 0x3bb0 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3ba6:	80 91 4e 06 	lds	r24, 0x064E
    3baa:	8f 5f       	subi	r24, 0xFF	; 255
    3bac:	80 93 4e 06 	sts	0x064E, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3bb0:	80 91 4f 06 	lds	r24, 0x064F
    3bb4:	88 23       	and	r24, r24
    3bb6:	11 f0       	breq	.+4      	; 0x3bbc <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3bb8:	81 e0       	ldi	r24, 0x01	; 1
    3bba:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3bbc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3bbe:	29 96       	adiw	r28, 0x09	; 9
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	de bf       	out	0x3e, r29	; 62
    3bc6:	0f be       	out	0x3f, r0	; 63
    3bc8:	cd bf       	out	0x3d, r28	; 61
    3bca:	cf 91       	pop	r28
    3bcc:	df 91       	pop	r29
    3bce:	08 95       	ret

00003bd0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3bd0:	df 93       	push	r29
    3bd2:	cf 93       	push	r28
    3bd4:	00 d0       	rcall	.+0      	; 0x3bd6 <vTaskSwitchContext+0x6>
    3bd6:	0f 92       	push	r0
    3bd8:	cd b7       	in	r28, 0x3d	; 61
    3bda:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3bdc:	80 91 56 06 	lds	r24, 0x0656
    3be0:	88 23       	and	r24, r24
    3be2:	21 f0       	breq	.+8      	; 0x3bec <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	80 93 4f 06 	sts	0x064F, r24
    3bea:	59 c0       	rjmp	.+178    	; 0x3c9e <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3bec:	10 92 4f 06 	sts	0x064F, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3bf0:	80 91 4c 06 	lds	r24, 0x064C
    3bf4:	8b 83       	std	Y+3, r24	; 0x03
    3bf6:	03 c0       	rjmp	.+6      	; 0x3bfe <vTaskSwitchContext+0x2e>
    3bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfa:	81 50       	subi	r24, 0x01	; 1
    3bfc:	8b 83       	std	Y+3, r24	; 0x03
    3bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    3c00:	28 2f       	mov	r18, r24
    3c02:	30 e0       	ldi	r19, 0x00	; 0
    3c04:	c9 01       	movw	r24, r18
    3c06:	88 0f       	add	r24, r24
    3c08:	99 1f       	adc	r25, r25
    3c0a:	88 0f       	add	r24, r24
    3c0c:	99 1f       	adc	r25, r25
    3c0e:	88 0f       	add	r24, r24
    3c10:	99 1f       	adc	r25, r25
    3c12:	82 0f       	add	r24, r18
    3c14:	93 1f       	adc	r25, r19
    3c16:	fc 01       	movw	r30, r24
    3c18:	e9 5a       	subi	r30, 0xA9	; 169
    3c1a:	f9 4f       	sbci	r31, 0xF9	; 249
    3c1c:	80 81       	ld	r24, Z
    3c1e:	88 23       	and	r24, r24
    3c20:	59 f3       	breq	.-42     	; 0x3bf8 <vTaskSwitchContext+0x28>
    3c22:	8b 81       	ldd	r24, Y+3	; 0x03
    3c24:	28 2f       	mov	r18, r24
    3c26:	30 e0       	ldi	r19, 0x00	; 0
    3c28:	c9 01       	movw	r24, r18
    3c2a:	88 0f       	add	r24, r24
    3c2c:	99 1f       	adc	r25, r25
    3c2e:	88 0f       	add	r24, r24
    3c30:	99 1f       	adc	r25, r25
    3c32:	88 0f       	add	r24, r24
    3c34:	99 1f       	adc	r25, r25
    3c36:	82 0f       	add	r24, r18
    3c38:	93 1f       	adc	r25, r19
    3c3a:	89 5a       	subi	r24, 0xA9	; 169
    3c3c:	99 4f       	sbci	r25, 0xF9	; 249
    3c3e:	9a 83       	std	Y+2, r25	; 0x02
    3c40:	89 83       	std	Y+1, r24	; 0x01
    3c42:	e9 81       	ldd	r30, Y+1	; 0x01
    3c44:	fa 81       	ldd	r31, Y+2	; 0x02
    3c46:	01 80       	ldd	r0, Z+1	; 0x01
    3c48:	f2 81       	ldd	r31, Z+2	; 0x02
    3c4a:	e0 2d       	mov	r30, r0
    3c4c:	82 81       	ldd	r24, Z+2	; 0x02
    3c4e:	93 81       	ldd	r25, Z+3	; 0x03
    3c50:	e9 81       	ldd	r30, Y+1	; 0x01
    3c52:	fa 81       	ldd	r31, Y+2	; 0x02
    3c54:	92 83       	std	Z+2, r25	; 0x02
    3c56:	81 83       	std	Z+1, r24	; 0x01
    3c58:	e9 81       	ldd	r30, Y+1	; 0x01
    3c5a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c5c:	21 81       	ldd	r18, Z+1	; 0x01
    3c5e:	32 81       	ldd	r19, Z+2	; 0x02
    3c60:	89 81       	ldd	r24, Y+1	; 0x01
    3c62:	9a 81       	ldd	r25, Y+2	; 0x02
    3c64:	03 96       	adiw	r24, 0x03	; 3
    3c66:	28 17       	cp	r18, r24
    3c68:	39 07       	cpc	r19, r25
    3c6a:	59 f4       	brne	.+22     	; 0x3c82 <vTaskSwitchContext+0xb2>
    3c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c70:	01 80       	ldd	r0, Z+1	; 0x01
    3c72:	f2 81       	ldd	r31, Z+2	; 0x02
    3c74:	e0 2d       	mov	r30, r0
    3c76:	82 81       	ldd	r24, Z+2	; 0x02
    3c78:	93 81       	ldd	r25, Z+3	; 0x03
    3c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7e:	92 83       	std	Z+2, r25	; 0x02
    3c80:	81 83       	std	Z+1, r24	; 0x01
    3c82:	e9 81       	ldd	r30, Y+1	; 0x01
    3c84:	fa 81       	ldd	r31, Y+2	; 0x02
    3c86:	01 80       	ldd	r0, Z+1	; 0x01
    3c88:	f2 81       	ldd	r31, Z+2	; 0x02
    3c8a:	e0 2d       	mov	r30, r0
    3c8c:	86 81       	ldd	r24, Z+6	; 0x06
    3c8e:	97 81       	ldd	r25, Z+7	; 0x07
    3c90:	90 93 47 06 	sts	0x0647, r25
    3c94:	80 93 46 06 	sts	0x0646, r24
    3c98:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9a:	80 93 4c 06 	sts	0x064C, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3c9e:	0f 90       	pop	r0
    3ca0:	0f 90       	pop	r0
    3ca2:	0f 90       	pop	r0
    3ca4:	cf 91       	pop	r28
    3ca6:	df 91       	pop	r29
    3ca8:	08 95       	ret

00003caa <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3caa:	df 93       	push	r29
    3cac:	cf 93       	push	r28
    3cae:	00 d0       	rcall	.+0      	; 0x3cb0 <vTaskPlaceOnEventList+0x6>
    3cb0:	00 d0       	rcall	.+0      	; 0x3cb2 <vTaskPlaceOnEventList+0x8>
    3cb2:	cd b7       	in	r28, 0x3d	; 61
    3cb4:	de b7       	in	r29, 0x3e	; 62
    3cb6:	9a 83       	std	Y+2, r25	; 0x02
    3cb8:	89 83       	std	Y+1, r24	; 0x01
    3cba:	7c 83       	std	Y+4, r23	; 0x04
    3cbc:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3cbe:	80 91 46 06 	lds	r24, 0x0646
    3cc2:	90 91 47 06 	lds	r25, 0x0647
    3cc6:	9c 01       	movw	r18, r24
    3cc8:	24 5f       	subi	r18, 0xF4	; 244
    3cca:	3f 4f       	sbci	r19, 0xFF	; 255
    3ccc:	89 81       	ldd	r24, Y+1	; 0x01
    3cce:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd0:	b9 01       	movw	r22, r18
    3cd2:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cda:	61 e0       	ldi	r22, 0x01	; 1
    3cdc:	0e 94 76 26 	call	0x4cec	; 0x4cec <prvAddCurrentTaskToDelayedList>
}
    3ce0:	0f 90       	pop	r0
    3ce2:	0f 90       	pop	r0
    3ce4:	0f 90       	pop	r0
    3ce6:	0f 90       	pop	r0
    3ce8:	cf 91       	pop	r28
    3cea:	df 91       	pop	r29
    3cec:	08 95       	ret

00003cee <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3cee:	df 93       	push	r29
    3cf0:	cf 93       	push	r28
    3cf2:	00 d0       	rcall	.+0      	; 0x3cf4 <vTaskPlaceOnUnorderedEventList+0x6>
    3cf4:	00 d0       	rcall	.+0      	; 0x3cf6 <vTaskPlaceOnUnorderedEventList+0x8>
    3cf6:	00 d0       	rcall	.+0      	; 0x3cf8 <vTaskPlaceOnUnorderedEventList+0xa>
    3cf8:	cd b7       	in	r28, 0x3d	; 61
    3cfa:	de b7       	in	r29, 0x3e	; 62
    3cfc:	9a 83       	std	Y+2, r25	; 0x02
    3cfe:	89 83       	std	Y+1, r24	; 0x01
    3d00:	7c 83       	std	Y+4, r23	; 0x04
    3d02:	6b 83       	std	Y+3, r22	; 0x03
    3d04:	5e 83       	std	Y+6, r21	; 0x06
    3d06:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3d08:	e0 91 46 06 	lds	r30, 0x0646
    3d0c:	f0 91 47 06 	lds	r31, 0x0647
    3d10:	8b 81       	ldd	r24, Y+3	; 0x03
    3d12:	9c 81       	ldd	r25, Y+4	; 0x04
    3d14:	90 68       	ori	r25, 0x80	; 128
    3d16:	95 87       	std	Z+13, r25	; 0x0d
    3d18:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3d1a:	80 91 46 06 	lds	r24, 0x0646
    3d1e:	90 91 47 06 	lds	r25, 0x0647
    3d22:	9c 01       	movw	r18, r24
    3d24:	24 5f       	subi	r18, 0xF4	; 244
    3d26:	3f 4f       	sbci	r19, 0xFF	; 255
    3d28:	89 81       	ldd	r24, Y+1	; 0x01
    3d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2c:	b9 01       	movw	r22, r18
    3d2e:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3d32:	8d 81       	ldd	r24, Y+5	; 0x05
    3d34:	9e 81       	ldd	r25, Y+6	; 0x06
    3d36:	61 e0       	ldi	r22, 0x01	; 1
    3d38:	0e 94 76 26 	call	0x4cec	; 0x4cec <prvAddCurrentTaskToDelayedList>
}
    3d3c:	26 96       	adiw	r28, 0x06	; 6
    3d3e:	0f b6       	in	r0, 0x3f	; 63
    3d40:	f8 94       	cli
    3d42:	de bf       	out	0x3e, r29	; 62
    3d44:	0f be       	out	0x3f, r0	; 63
    3d46:	cd bf       	out	0x3d, r28	; 61
    3d48:	cf 91       	pop	r28
    3d4a:	df 91       	pop	r29
    3d4c:	08 95       	ret

00003d4e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3d4e:	df 93       	push	r29
    3d50:	cf 93       	push	r28
    3d52:	00 d0       	rcall	.+0      	; 0x3d54 <xTaskRemoveFromEventList+0x6>
    3d54:	00 d0       	rcall	.+0      	; 0x3d56 <xTaskRemoveFromEventList+0x8>
    3d56:	0f 92       	push	r0
    3d58:	cd b7       	in	r28, 0x3d	; 61
    3d5a:	de b7       	in	r29, 0x3e	; 62
    3d5c:	9d 83       	std	Y+5, r25	; 0x05
    3d5e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d60:	ec 81       	ldd	r30, Y+4	; 0x04
    3d62:	fd 81       	ldd	r31, Y+5	; 0x05
    3d64:	05 80       	ldd	r0, Z+5	; 0x05
    3d66:	f6 81       	ldd	r31, Z+6	; 0x06
    3d68:	e0 2d       	mov	r30, r0
    3d6a:	86 81       	ldd	r24, Z+6	; 0x06
    3d6c:	97 81       	ldd	r25, Z+7	; 0x07
    3d6e:	9b 83       	std	Y+3, r25	; 0x03
    3d70:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3d72:	8a 81       	ldd	r24, Y+2	; 0x02
    3d74:	9b 81       	ldd	r25, Y+3	; 0x03
    3d76:	0c 96       	adiw	r24, 0x0c	; 12
    3d78:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d7c:	80 91 56 06 	lds	r24, 0x0656
    3d80:	88 23       	and	r24, r24
    3d82:	61 f5       	brne	.+88     	; 0x3ddc <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3d84:	8a 81       	ldd	r24, Y+2	; 0x02
    3d86:	9b 81       	ldd	r25, Y+3	; 0x03
    3d88:	02 96       	adiw	r24, 0x02	; 2
    3d8a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3d8e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d90:	fb 81       	ldd	r31, Y+3	; 0x03
    3d92:	96 89       	ldd	r25, Z+22	; 0x16
    3d94:	80 91 4c 06 	lds	r24, 0x064C
    3d98:	89 17       	cp	r24, r25
    3d9a:	28 f4       	brcc	.+10     	; 0x3da6 <xTaskRemoveFromEventList+0x58>
    3d9c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d9e:	fb 81       	ldd	r31, Y+3	; 0x03
    3da0:	86 89       	ldd	r24, Z+22	; 0x16
    3da2:	80 93 4c 06 	sts	0x064C, r24
    3da6:	ea 81       	ldd	r30, Y+2	; 0x02
    3da8:	fb 81       	ldd	r31, Y+3	; 0x03
    3daa:	86 89       	ldd	r24, Z+22	; 0x16
    3dac:	28 2f       	mov	r18, r24
    3dae:	30 e0       	ldi	r19, 0x00	; 0
    3db0:	c9 01       	movw	r24, r18
    3db2:	88 0f       	add	r24, r24
    3db4:	99 1f       	adc	r25, r25
    3db6:	88 0f       	add	r24, r24
    3db8:	99 1f       	adc	r25, r25
    3dba:	88 0f       	add	r24, r24
    3dbc:	99 1f       	adc	r25, r25
    3dbe:	82 0f       	add	r24, r18
    3dc0:	93 1f       	adc	r25, r19
    3dc2:	ac 01       	movw	r20, r24
    3dc4:	49 5a       	subi	r20, 0xA9	; 169
    3dc6:	59 4f       	sbci	r21, 0xF9	; 249
    3dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dca:	9b 81       	ldd	r25, Y+3	; 0x03
    3dcc:	9c 01       	movw	r18, r24
    3dce:	2e 5f       	subi	r18, 0xFE	; 254
    3dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd2:	ca 01       	movw	r24, r20
    3dd4:	b9 01       	movw	r22, r18
    3dd6:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    3dda:	0a c0       	rjmp	.+20     	; 0x3df0 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3ddc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dde:	9b 81       	ldd	r25, Y+3	; 0x03
    3de0:	9c 01       	movw	r18, r24
    3de2:	24 5f       	subi	r18, 0xF4	; 244
    3de4:	3f 4f       	sbci	r19, 0xFF	; 255
    3de6:	81 e9       	ldi	r24, 0x91	; 145
    3de8:	96 e0       	ldi	r25, 0x06	; 6
    3dea:	b9 01       	movw	r22, r18
    3dec:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3df0:	ea 81       	ldd	r30, Y+2	; 0x02
    3df2:	fb 81       	ldd	r31, Y+3	; 0x03
    3df4:	96 89       	ldd	r25, Z+22	; 0x16
    3df6:	e0 91 46 06 	lds	r30, 0x0646
    3dfa:	f0 91 47 06 	lds	r31, 0x0647
    3dfe:	86 89       	ldd	r24, Z+22	; 0x16
    3e00:	89 17       	cp	r24, r25
    3e02:	30 f4       	brcc	.+12     	; 0x3e10 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3e04:	81 e0       	ldi	r24, 0x01	; 1
    3e06:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3e08:	81 e0       	ldi	r24, 0x01	; 1
    3e0a:	80 93 4f 06 	sts	0x064F, r24
    3e0e:	01 c0       	rjmp	.+2      	; 0x3e12 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3e10:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3e12:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e14:	0f 90       	pop	r0
    3e16:	0f 90       	pop	r0
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	cf 91       	pop	r28
    3e20:	df 91       	pop	r29
    3e22:	08 95       	ret

00003e24 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3e24:	df 93       	push	r29
    3e26:	cf 93       	push	r28
    3e28:	00 d0       	rcall	.+0      	; 0x3e2a <vTaskRemoveFromUnorderedEventList+0x6>
    3e2a:	00 d0       	rcall	.+0      	; 0x3e2c <vTaskRemoveFromUnorderedEventList+0x8>
    3e2c:	00 d0       	rcall	.+0      	; 0x3e2e <vTaskRemoveFromUnorderedEventList+0xa>
    3e2e:	cd b7       	in	r28, 0x3d	; 61
    3e30:	de b7       	in	r29, 0x3e	; 62
    3e32:	9c 83       	std	Y+4, r25	; 0x04
    3e34:	8b 83       	std	Y+3, r24	; 0x03
    3e36:	7e 83       	std	Y+6, r23	; 0x06
    3e38:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e3c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e3e:	90 68       	ori	r25, 0x80	; 128
    3e40:	eb 81       	ldd	r30, Y+3	; 0x03
    3e42:	fc 81       	ldd	r31, Y+4	; 0x04
    3e44:	91 83       	std	Z+1, r25	; 0x01
    3e46:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e48:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4c:	86 81       	ldd	r24, Z+6	; 0x06
    3e4e:	97 81       	ldd	r25, Z+7	; 0x07
    3e50:	9a 83       	std	Y+2, r25	; 0x02
    3e52:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3e54:	8b 81       	ldd	r24, Y+3	; 0x03
    3e56:	9c 81       	ldd	r25, Y+4	; 0x04
    3e58:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e60:	02 96       	adiw	r24, 0x02	; 2
    3e62:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3e66:	e9 81       	ldd	r30, Y+1	; 0x01
    3e68:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6a:	96 89       	ldd	r25, Z+22	; 0x16
    3e6c:	80 91 4c 06 	lds	r24, 0x064C
    3e70:	89 17       	cp	r24, r25
    3e72:	28 f4       	brcc	.+10     	; 0x3e7e <vTaskRemoveFromUnorderedEventList+0x5a>
    3e74:	e9 81       	ldd	r30, Y+1	; 0x01
    3e76:	fa 81       	ldd	r31, Y+2	; 0x02
    3e78:	86 89       	ldd	r24, Z+22	; 0x16
    3e7a:	80 93 4c 06 	sts	0x064C, r24
    3e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e80:	fa 81       	ldd	r31, Y+2	; 0x02
    3e82:	86 89       	ldd	r24, Z+22	; 0x16
    3e84:	28 2f       	mov	r18, r24
    3e86:	30 e0       	ldi	r19, 0x00	; 0
    3e88:	c9 01       	movw	r24, r18
    3e8a:	88 0f       	add	r24, r24
    3e8c:	99 1f       	adc	r25, r25
    3e8e:	88 0f       	add	r24, r24
    3e90:	99 1f       	adc	r25, r25
    3e92:	88 0f       	add	r24, r24
    3e94:	99 1f       	adc	r25, r25
    3e96:	82 0f       	add	r24, r18
    3e98:	93 1f       	adc	r25, r19
    3e9a:	ac 01       	movw	r20, r24
    3e9c:	49 5a       	subi	r20, 0xA9	; 169
    3e9e:	59 4f       	sbci	r21, 0xF9	; 249
    3ea0:	89 81       	ldd	r24, Y+1	; 0x01
    3ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea4:	9c 01       	movw	r18, r24
    3ea6:	2e 5f       	subi	r18, 0xFE	; 254
    3ea8:	3f 4f       	sbci	r19, 0xFF	; 255
    3eaa:	ca 01       	movw	r24, r20
    3eac:	b9 01       	movw	r22, r18
    3eae:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb6:	96 89       	ldd	r25, Z+22	; 0x16
    3eb8:	e0 91 46 06 	lds	r30, 0x0646
    3ebc:	f0 91 47 06 	lds	r31, 0x0647
    3ec0:	86 89       	ldd	r24, Z+22	; 0x16
    3ec2:	89 17       	cp	r24, r25
    3ec4:	18 f4       	brcc	.+6      	; 0x3ecc <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3ec6:	81 e0       	ldi	r24, 0x01	; 1
    3ec8:	80 93 4f 06 	sts	0x064F, r24
	}
}
    3ecc:	26 96       	adiw	r28, 0x06	; 6
    3ece:	0f b6       	in	r0, 0x3f	; 63
    3ed0:	f8 94       	cli
    3ed2:	de bf       	out	0x3e, r29	; 62
    3ed4:	0f be       	out	0x3f, r0	; 63
    3ed6:	cd bf       	out	0x3d, r28	; 61
    3ed8:	cf 91       	pop	r28
    3eda:	df 91       	pop	r29
    3edc:	08 95       	ret

00003ede <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3ede:	df 93       	push	r29
    3ee0:	cf 93       	push	r28
    3ee2:	00 d0       	rcall	.+0      	; 0x3ee4 <vTaskSetTimeOutState+0x6>
    3ee4:	cd b7       	in	r28, 0x3d	; 61
    3ee6:	de b7       	in	r29, 0x3e	; 62
    3ee8:	9a 83       	std	Y+2, r25	; 0x02
    3eea:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3eec:	0f b6       	in	r0, 0x3f	; 63
    3eee:	f8 94       	cli
    3ef0:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3ef2:	80 91 50 06 	lds	r24, 0x0650
    3ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    3efa:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3efc:	80 91 4a 06 	lds	r24, 0x064A
    3f00:	90 91 4b 06 	lds	r25, 0x064B
    3f04:	e9 81       	ldd	r30, Y+1	; 0x01
    3f06:	fa 81       	ldd	r31, Y+2	; 0x02
    3f08:	92 83       	std	Z+2, r25	; 0x02
    3f0a:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3f0c:	0f 90       	pop	r0
    3f0e:	0f be       	out	0x3f, r0	; 63
}
    3f10:	0f 90       	pop	r0
    3f12:	0f 90       	pop	r0
    3f14:	cf 91       	pop	r28
    3f16:	df 91       	pop	r29
    3f18:	08 95       	ret

00003f1a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3f1a:	df 93       	push	r29
    3f1c:	cf 93       	push	r28
    3f1e:	00 d0       	rcall	.+0      	; 0x3f20 <vTaskInternalSetTimeOutState+0x6>
    3f20:	cd b7       	in	r28, 0x3d	; 61
    3f22:	de b7       	in	r29, 0x3e	; 62
    3f24:	9a 83       	std	Y+2, r25	; 0x02
    3f26:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3f28:	80 91 50 06 	lds	r24, 0x0650
    3f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f30:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3f32:	80 91 4a 06 	lds	r24, 0x064A
    3f36:	90 91 4b 06 	lds	r25, 0x064B
    3f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f3e:	92 83       	std	Z+2, r25	; 0x02
    3f40:	81 83       	std	Z+1, r24	; 0x01
}
    3f42:	0f 90       	pop	r0
    3f44:	0f 90       	pop	r0
    3f46:	cf 91       	pop	r28
    3f48:	df 91       	pop	r29
    3f4a:	08 95       	ret

00003f4c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3f4c:	df 93       	push	r29
    3f4e:	cf 93       	push	r28
    3f50:	cd b7       	in	r28, 0x3d	; 61
    3f52:	de b7       	in	r29, 0x3e	; 62
    3f54:	29 97       	sbiw	r28, 0x09	; 9
    3f56:	0f b6       	in	r0, 0x3f	; 63
    3f58:	f8 94       	cli
    3f5a:	de bf       	out	0x3e, r29	; 62
    3f5c:	0f be       	out	0x3f, r0	; 63
    3f5e:	cd bf       	out	0x3d, r28	; 61
    3f60:	9f 83       	std	Y+7, r25	; 0x07
    3f62:	8e 83       	std	Y+6, r24	; 0x06
    3f64:	79 87       	std	Y+9, r23	; 0x09
    3f66:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3f68:	0f b6       	in	r0, 0x3f	; 63
    3f6a:	f8 94       	cli
    3f6c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3f6e:	80 91 4a 06 	lds	r24, 0x064A
    3f72:	90 91 4b 06 	lds	r25, 0x064B
    3f76:	9c 83       	std	Y+4, r25	; 0x04
    3f78:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3f7a:	ee 81       	ldd	r30, Y+6	; 0x06
    3f7c:	ff 81       	ldd	r31, Y+7	; 0x07
    3f7e:	21 81       	ldd	r18, Z+1	; 0x01
    3f80:	32 81       	ldd	r19, Z+2	; 0x02
    3f82:	8b 81       	ldd	r24, Y+3	; 0x03
    3f84:	9c 81       	ldd	r25, Y+4	; 0x04
    3f86:	82 1b       	sub	r24, r18
    3f88:	93 0b       	sbc	r25, r19
    3f8a:	9a 83       	std	Y+2, r25	; 0x02
    3f8c:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3f8e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f90:	f9 85       	ldd	r31, Y+9	; 0x09
    3f92:	80 81       	ld	r24, Z
    3f94:	91 81       	ldd	r25, Z+1	; 0x01
    3f96:	2f ef       	ldi	r18, 0xFF	; 255
    3f98:	8f 3f       	cpi	r24, 0xFF	; 255
    3f9a:	92 07       	cpc	r25, r18
    3f9c:	11 f4       	brne	.+4      	; 0x3fa2 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3f9e:	1d 82       	std	Y+5, r1	; 0x05
    3fa0:	36 c0       	rjmp	.+108    	; 0x400e <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3fa2:	ee 81       	ldd	r30, Y+6	; 0x06
    3fa4:	ff 81       	ldd	r31, Y+7	; 0x07
    3fa6:	90 81       	ld	r25, Z
    3fa8:	80 91 50 06 	lds	r24, 0x0650
    3fac:	98 17       	cp	r25, r24
    3fae:	61 f0       	breq	.+24     	; 0x3fc8 <xTaskCheckForTimeOut+0x7c>
    3fb0:	ee 81       	ldd	r30, Y+6	; 0x06
    3fb2:	ff 81       	ldd	r31, Y+7	; 0x07
    3fb4:	21 81       	ldd	r18, Z+1	; 0x01
    3fb6:	32 81       	ldd	r19, Z+2	; 0x02
    3fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fba:	9c 81       	ldd	r25, Y+4	; 0x04
    3fbc:	82 17       	cp	r24, r18
    3fbe:	93 07       	cpc	r25, r19
    3fc0:	18 f0       	brcs	.+6      	; 0x3fc8 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3fc2:	81 e0       	ldi	r24, 0x01	; 1
    3fc4:	8d 83       	std	Y+5, r24	; 0x05
    3fc6:	23 c0       	rjmp	.+70     	; 0x400e <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3fc8:	e8 85       	ldd	r30, Y+8	; 0x08
    3fca:	f9 85       	ldd	r31, Y+9	; 0x09
    3fcc:	20 81       	ld	r18, Z
    3fce:	31 81       	ldd	r19, Z+1	; 0x01
    3fd0:	89 81       	ldd	r24, Y+1	; 0x01
    3fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd4:	82 17       	cp	r24, r18
    3fd6:	93 07       	cpc	r25, r19
    3fd8:	a0 f4       	brcc	.+40     	; 0x4002 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3fda:	e8 85       	ldd	r30, Y+8	; 0x08
    3fdc:	f9 85       	ldd	r31, Y+9	; 0x09
    3fde:	20 81       	ld	r18, Z
    3fe0:	31 81       	ldd	r19, Z+1	; 0x01
    3fe2:	89 81       	ldd	r24, Y+1	; 0x01
    3fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe6:	a9 01       	movw	r20, r18
    3fe8:	48 1b       	sub	r20, r24
    3fea:	59 0b       	sbc	r21, r25
    3fec:	ca 01       	movw	r24, r20
    3fee:	e8 85       	ldd	r30, Y+8	; 0x08
    3ff0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ff2:	91 83       	std	Z+1, r25	; 0x01
    3ff4:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3ff6:	8e 81       	ldd	r24, Y+6	; 0x06
    3ff8:	9f 81       	ldd	r25, Y+7	; 0x07
    3ffa:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3ffe:	1d 82       	std	Y+5, r1	; 0x05
    4000:	06 c0       	rjmp	.+12     	; 0x400e <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4002:	e8 85       	ldd	r30, Y+8	; 0x08
    4004:	f9 85       	ldd	r31, Y+9	; 0x09
    4006:	11 82       	std	Z+1, r1	; 0x01
    4008:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    400a:	81 e0       	ldi	r24, 0x01	; 1
    400c:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    400e:	0f 90       	pop	r0
    4010:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4012:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4014:	29 96       	adiw	r28, 0x09	; 9
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	f8 94       	cli
    401a:	de bf       	out	0x3e, r29	; 62
    401c:	0f be       	out	0x3f, r0	; 63
    401e:	cd bf       	out	0x3d, r28	; 61
    4020:	cf 91       	pop	r28
    4022:	df 91       	pop	r29
    4024:	08 95       	ret

00004026 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4026:	df 93       	push	r29
    4028:	cf 93       	push	r28
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    402e:	81 e0       	ldi	r24, 0x01	; 1
    4030:	80 93 4f 06 	sts	0x064F, r24
}
    4034:	cf 91       	pop	r28
    4036:	df 91       	pop	r29
    4038:	08 95       	ret

0000403a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    403a:	df 93       	push	r29
    403c:	cf 93       	push	r28
    403e:	00 d0       	rcall	.+0      	; 0x4040 <prvIdleTask+0x6>
    4040:	cd b7       	in	r28, 0x3d	; 61
    4042:	de b7       	in	r29, 0x3e	; 62
    4044:	9a 83       	std	Y+2, r25	; 0x02
    4046:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4048:	0e 94 68 20 	call	0x40d0	; 0x40d0 <prvCheckTasksWaitingTermination>
    404c:	fd cf       	rjmp	.-6      	; 0x4048 <prvIdleTask+0xe>

0000404e <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    404e:	df 93       	push	r29
    4050:	cf 93       	push	r28
    4052:	0f 92       	push	r0
    4054:	cd b7       	in	r28, 0x3d	; 61
    4056:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4058:	19 82       	std	Y+1, r1	; 0x01
    405a:	13 c0       	rjmp	.+38     	; 0x4082 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    405c:	89 81       	ldd	r24, Y+1	; 0x01
    405e:	28 2f       	mov	r18, r24
    4060:	30 e0       	ldi	r19, 0x00	; 0
    4062:	c9 01       	movw	r24, r18
    4064:	88 0f       	add	r24, r24
    4066:	99 1f       	adc	r25, r25
    4068:	88 0f       	add	r24, r24
    406a:	99 1f       	adc	r25, r25
    406c:	88 0f       	add	r24, r24
    406e:	99 1f       	adc	r25, r25
    4070:	82 0f       	add	r24, r18
    4072:	93 1f       	adc	r25, r19
    4074:	89 5a       	subi	r24, 0xA9	; 169
    4076:	99 4f       	sbci	r25, 0xF9	; 249
    4078:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    407c:	89 81       	ldd	r24, Y+1	; 0x01
    407e:	8f 5f       	subi	r24, 0xFF	; 255
    4080:	89 83       	std	Y+1, r24	; 0x01
    4082:	89 81       	ldd	r24, Y+1	; 0x01
    4084:	84 30       	cpi	r24, 0x04	; 4
    4086:	50 f3       	brcs	.-44     	; 0x405c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4088:	8b e7       	ldi	r24, 0x7B	; 123
    408a:	96 e0       	ldi	r25, 0x06	; 6
    408c:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4090:	84 e8       	ldi	r24, 0x84	; 132
    4092:	96 e0       	ldi	r25, 0x06	; 6
    4094:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4098:	81 e9       	ldi	r24, 0x91	; 145
    409a:	96 e0       	ldi	r25, 0x06	; 6
    409c:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    40a0:	8a e9       	ldi	r24, 0x9A	; 154
    40a2:	96 e0       	ldi	r25, 0x06	; 6
    40a4:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    40a8:	83 ea       	ldi	r24, 0xA3	; 163
    40aa:	96 e0       	ldi	r25, 0x06	; 6
    40ac:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    40b0:	8b e7       	ldi	r24, 0x7B	; 123
    40b2:	96 e0       	ldi	r25, 0x06	; 6
    40b4:	90 93 8e 06 	sts	0x068E, r25
    40b8:	80 93 8d 06 	sts	0x068D, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    40bc:	84 e8       	ldi	r24, 0x84	; 132
    40be:	96 e0       	ldi	r25, 0x06	; 6
    40c0:	90 93 90 06 	sts	0x0690, r25
    40c4:	80 93 8f 06 	sts	0x068F, r24
}
    40c8:	0f 90       	pop	r0
    40ca:	cf 91       	pop	r28
    40cc:	df 91       	pop	r29
    40ce:	08 95       	ret

000040d0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    40d0:	df 93       	push	r29
    40d2:	cf 93       	push	r28
    40d4:	00 d0       	rcall	.+0      	; 0x40d6 <prvCheckTasksWaitingTermination+0x6>
    40d6:	cd b7       	in	r28, 0x3d	; 61
    40d8:	de b7       	in	r29, 0x3e	; 62
    40da:	20 c0       	rjmp	.+64     	; 0x411c <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	f8 94       	cli
    40e0:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40e2:	e0 91 9f 06 	lds	r30, 0x069F
    40e6:	f0 91 a0 06 	lds	r31, 0x06A0
    40ea:	86 81       	ldd	r24, Z+6	; 0x06
    40ec:	97 81       	ldd	r25, Z+7	; 0x07
    40ee:	9a 83       	std	Y+2, r25	; 0x02
    40f0:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    40f2:	89 81       	ldd	r24, Y+1	; 0x01
    40f4:	9a 81       	ldd	r25, Y+2	; 0x02
    40f6:	02 96       	adiw	r24, 0x02	; 2
    40f8:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
				--uxCurrentNumberOfTasks;
    40fc:	80 91 49 06 	lds	r24, 0x0649
    4100:	81 50       	subi	r24, 0x01	; 1
    4102:	80 93 49 06 	sts	0x0649, r24
				--uxDeletedTasksWaitingCleanUp;
    4106:	80 91 48 06 	lds	r24, 0x0648
    410a:	81 50       	subi	r24, 0x01	; 1
    410c:	80 93 48 06 	sts	0x0648, r24
			}
			taskEXIT_CRITICAL();
    4110:	0f 90       	pop	r0
    4112:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4114:	89 81       	ldd	r24, Y+1	; 0x01
    4116:	9a 81       	ldd	r25, Y+2	; 0x02
    4118:	0e 94 97 20 	call	0x412e	; 0x412e <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    411c:	80 91 48 06 	lds	r24, 0x0648
    4120:	88 23       	and	r24, r24
    4122:	e1 f6       	brne	.-72     	; 0x40dc <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4124:	0f 90       	pop	r0
    4126:	0f 90       	pop	r0
    4128:	cf 91       	pop	r28
    412a:	df 91       	pop	r29
    412c:	08 95       	ret

0000412e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    412e:	df 93       	push	r29
    4130:	cf 93       	push	r28
    4132:	00 d0       	rcall	.+0      	; 0x4134 <prvDeleteTCB+0x6>
    4134:	cd b7       	in	r28, 0x3d	; 61
    4136:	de b7       	in	r29, 0x3e	; 62
    4138:	9a 83       	std	Y+2, r25	; 0x02
    413a:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    413c:	e9 81       	ldd	r30, Y+1	; 0x01
    413e:	fa 81       	ldd	r31, Y+2	; 0x02
    4140:	87 89       	ldd	r24, Z+23	; 0x17
    4142:	90 8d       	ldd	r25, Z+24	; 0x18
    4144:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
			vPortFree( pxTCB );
    4148:	89 81       	ldd	r24, Y+1	; 0x01
    414a:	9a 81       	ldd	r25, Y+2	; 0x02
    414c:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4150:	0f 90       	pop	r0
    4152:	0f 90       	pop	r0
    4154:	cf 91       	pop	r28
    4156:	df 91       	pop	r29
    4158:	08 95       	ret

0000415a <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    415a:	df 93       	push	r29
    415c:	cf 93       	push	r28
    415e:	00 d0       	rcall	.+0      	; 0x4160 <prvResetNextTaskUnblockTime+0x6>
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4164:	e0 91 8d 06 	lds	r30, 0x068D
    4168:	f0 91 8e 06 	lds	r31, 0x068E
    416c:	80 81       	ld	r24, Z
    416e:	88 23       	and	r24, r24
    4170:	39 f4       	brne	.+14     	; 0x4180 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4172:	8f ef       	ldi	r24, 0xFF	; 255
    4174:	9f ef       	ldi	r25, 0xFF	; 255
    4176:	90 93 53 06 	sts	0x0653, r25
    417a:	80 93 52 06 	sts	0x0652, r24
    417e:	13 c0       	rjmp	.+38     	; 0x41a6 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4180:	e0 91 8d 06 	lds	r30, 0x068D
    4184:	f0 91 8e 06 	lds	r31, 0x068E
    4188:	05 80       	ldd	r0, Z+5	; 0x05
    418a:	f6 81       	ldd	r31, Z+6	; 0x06
    418c:	e0 2d       	mov	r30, r0
    418e:	86 81       	ldd	r24, Z+6	; 0x06
    4190:	97 81       	ldd	r25, Z+7	; 0x07
    4192:	9a 83       	std	Y+2, r25	; 0x02
    4194:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4196:	e9 81       	ldd	r30, Y+1	; 0x01
    4198:	fa 81       	ldd	r31, Y+2	; 0x02
    419a:	82 81       	ldd	r24, Z+2	; 0x02
    419c:	93 81       	ldd	r25, Z+3	; 0x03
    419e:	90 93 53 06 	sts	0x0653, r25
    41a2:	80 93 52 06 	sts	0x0652, r24
	}
}
    41a6:	0f 90       	pop	r0
    41a8:	0f 90       	pop	r0
    41aa:	cf 91       	pop	r28
    41ac:	df 91       	pop	r29
    41ae:	08 95       	ret

000041b0 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    41b0:	df 93       	push	r29
    41b2:	cf 93       	push	r28
    41b4:	00 d0       	rcall	.+0      	; 0x41b6 <xTaskGetCurrentTaskHandle+0x6>
    41b6:	cd b7       	in	r28, 0x3d	; 61
    41b8:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    41ba:	80 91 46 06 	lds	r24, 0x0646
    41be:	90 91 47 06 	lds	r25, 0x0647
    41c2:	9a 83       	std	Y+2, r25	; 0x02
    41c4:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    41c6:	89 81       	ldd	r24, Y+1	; 0x01
    41c8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    41ca:	0f 90       	pop	r0
    41cc:	0f 90       	pop	r0
    41ce:	cf 91       	pop	r28
    41d0:	df 91       	pop	r29
    41d2:	08 95       	ret

000041d4 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    41d4:	df 93       	push	r29
    41d6:	cf 93       	push	r28
    41d8:	00 d0       	rcall	.+0      	; 0x41da <xTaskPriorityInherit+0x6>
    41da:	00 d0       	rcall	.+0      	; 0x41dc <xTaskPriorityInherit+0x8>
    41dc:	0f 92       	push	r0
    41de:	cd b7       	in	r28, 0x3d	; 61
    41e0:	de b7       	in	r29, 0x3e	; 62
    41e2:	9d 83       	std	Y+5, r25	; 0x05
    41e4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    41e6:	8c 81       	ldd	r24, Y+4	; 0x04
    41e8:	9d 81       	ldd	r25, Y+5	; 0x05
    41ea:	9b 83       	std	Y+3, r25	; 0x03
    41ec:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    41ee:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    41f0:	8c 81       	ldd	r24, Y+4	; 0x04
    41f2:	9d 81       	ldd	r25, Y+5	; 0x05
    41f4:	00 97       	sbiw	r24, 0x00	; 0
    41f6:	09 f4       	brne	.+2      	; 0x41fa <xTaskPriorityInherit+0x26>
    41f8:	82 c0       	rjmp	.+260    	; 0x42fe <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    41fa:	ea 81       	ldd	r30, Y+2	; 0x02
    41fc:	fb 81       	ldd	r31, Y+3	; 0x03
    41fe:	96 89       	ldd	r25, Z+22	; 0x16
    4200:	e0 91 46 06 	lds	r30, 0x0646
    4204:	f0 91 47 06 	lds	r31, 0x0647
    4208:	86 89       	ldd	r24, Z+22	; 0x16
    420a:	98 17       	cp	r25, r24
    420c:	08 f0       	brcs	.+2      	; 0x4210 <xTaskPriorityInherit+0x3c>
    420e:	6b c0       	rjmp	.+214    	; 0x42e6 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4210:	ea 81       	ldd	r30, Y+2	; 0x02
    4212:	fb 81       	ldd	r31, Y+3	; 0x03
    4214:	84 85       	ldd	r24, Z+12	; 0x0c
    4216:	95 85       	ldd	r25, Z+13	; 0x0d
    4218:	99 23       	and	r25, r25
    421a:	7c f0       	brlt	.+30     	; 0x423a <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    421c:	e0 91 46 06 	lds	r30, 0x0646
    4220:	f0 91 47 06 	lds	r31, 0x0647
    4224:	86 89       	ldd	r24, Z+22	; 0x16
    4226:	28 2f       	mov	r18, r24
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	84 e0       	ldi	r24, 0x04	; 4
    422c:	90 e0       	ldi	r25, 0x00	; 0
    422e:	82 1b       	sub	r24, r18
    4230:	93 0b       	sbc	r25, r19
    4232:	ea 81       	ldd	r30, Y+2	; 0x02
    4234:	fb 81       	ldd	r31, Y+3	; 0x03
    4236:	95 87       	std	Z+13, r25	; 0x0d
    4238:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    423a:	ea 81       	ldd	r30, Y+2	; 0x02
    423c:	fb 81       	ldd	r31, Y+3	; 0x03
    423e:	42 85       	ldd	r20, Z+10	; 0x0a
    4240:	53 85       	ldd	r21, Z+11	; 0x0b
    4242:	ea 81       	ldd	r30, Y+2	; 0x02
    4244:	fb 81       	ldd	r31, Y+3	; 0x03
    4246:	86 89       	ldd	r24, Z+22	; 0x16
    4248:	28 2f       	mov	r18, r24
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	c9 01       	movw	r24, r18
    424e:	88 0f       	add	r24, r24
    4250:	99 1f       	adc	r25, r25
    4252:	88 0f       	add	r24, r24
    4254:	99 1f       	adc	r25, r25
    4256:	88 0f       	add	r24, r24
    4258:	99 1f       	adc	r25, r25
    425a:	82 0f       	add	r24, r18
    425c:	93 1f       	adc	r25, r19
    425e:	89 5a       	subi	r24, 0xA9	; 169
    4260:	99 4f       	sbci	r25, 0xF9	; 249
    4262:	48 17       	cp	r20, r24
    4264:	59 07       	cpc	r21, r25
    4266:	a1 f5       	brne	.+104    	; 0x42d0 <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4268:	8a 81       	ldd	r24, Y+2	; 0x02
    426a:	9b 81       	ldd	r25, Y+3	; 0x03
    426c:	02 96       	adiw	r24, 0x02	; 2
    426e:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4272:	e0 91 46 06 	lds	r30, 0x0646
    4276:	f0 91 47 06 	lds	r31, 0x0647
    427a:	86 89       	ldd	r24, Z+22	; 0x16
    427c:	ea 81       	ldd	r30, Y+2	; 0x02
    427e:	fb 81       	ldd	r31, Y+3	; 0x03
    4280:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    4282:	ea 81       	ldd	r30, Y+2	; 0x02
    4284:	fb 81       	ldd	r31, Y+3	; 0x03
    4286:	96 89       	ldd	r25, Z+22	; 0x16
    4288:	80 91 4c 06 	lds	r24, 0x064C
    428c:	89 17       	cp	r24, r25
    428e:	28 f4       	brcc	.+10     	; 0x429a <xTaskPriorityInherit+0xc6>
    4290:	ea 81       	ldd	r30, Y+2	; 0x02
    4292:	fb 81       	ldd	r31, Y+3	; 0x03
    4294:	86 89       	ldd	r24, Z+22	; 0x16
    4296:	80 93 4c 06 	sts	0x064C, r24
    429a:	ea 81       	ldd	r30, Y+2	; 0x02
    429c:	fb 81       	ldd	r31, Y+3	; 0x03
    429e:	86 89       	ldd	r24, Z+22	; 0x16
    42a0:	28 2f       	mov	r18, r24
    42a2:	30 e0       	ldi	r19, 0x00	; 0
    42a4:	c9 01       	movw	r24, r18
    42a6:	88 0f       	add	r24, r24
    42a8:	99 1f       	adc	r25, r25
    42aa:	88 0f       	add	r24, r24
    42ac:	99 1f       	adc	r25, r25
    42ae:	88 0f       	add	r24, r24
    42b0:	99 1f       	adc	r25, r25
    42b2:	82 0f       	add	r24, r18
    42b4:	93 1f       	adc	r25, r19
    42b6:	ac 01       	movw	r20, r24
    42b8:	49 5a       	subi	r20, 0xA9	; 169
    42ba:	59 4f       	sbci	r21, 0xF9	; 249
    42bc:	8a 81       	ldd	r24, Y+2	; 0x02
    42be:	9b 81       	ldd	r25, Y+3	; 0x03
    42c0:	9c 01       	movw	r18, r24
    42c2:	2e 5f       	subi	r18, 0xFE	; 254
    42c4:	3f 4f       	sbci	r19, 0xFF	; 255
    42c6:	ca 01       	movw	r24, r20
    42c8:	b9 01       	movw	r22, r18
    42ca:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    42ce:	08 c0       	rjmp	.+16     	; 0x42e0 <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    42d0:	e0 91 46 06 	lds	r30, 0x0646
    42d4:	f0 91 47 06 	lds	r31, 0x0647
    42d8:	86 89       	ldd	r24, Z+22	; 0x16
    42da:	ea 81       	ldd	r30, Y+2	; 0x02
    42dc:	fb 81       	ldd	r31, Y+3	; 0x03
    42de:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    42e0:	81 e0       	ldi	r24, 0x01	; 1
    42e2:	89 83       	std	Y+1, r24	; 0x01
    42e4:	0c c0       	rjmp	.+24     	; 0x42fe <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    42e6:	ea 81       	ldd	r30, Y+2	; 0x02
    42e8:	fb 81       	ldd	r31, Y+3	; 0x03
    42ea:	93 a1       	ldd	r25, Z+35	; 0x23
    42ec:	e0 91 46 06 	lds	r30, 0x0646
    42f0:	f0 91 47 06 	lds	r31, 0x0647
    42f4:	86 89       	ldd	r24, Z+22	; 0x16
    42f6:	98 17       	cp	r25, r24
    42f8:	10 f4       	brcc	.+4      	; 0x42fe <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    42fa:	81 e0       	ldi	r24, 0x01	; 1
    42fc:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    42fe:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4300:	0f 90       	pop	r0
    4302:	0f 90       	pop	r0
    4304:	0f 90       	pop	r0
    4306:	0f 90       	pop	r0
    4308:	0f 90       	pop	r0
    430a:	cf 91       	pop	r28
    430c:	df 91       	pop	r29
    430e:	08 95       	ret

00004310 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4310:	df 93       	push	r29
    4312:	cf 93       	push	r28
    4314:	00 d0       	rcall	.+0      	; 0x4316 <xTaskPriorityDisinherit+0x6>
    4316:	00 d0       	rcall	.+0      	; 0x4318 <xTaskPriorityDisinherit+0x8>
    4318:	0f 92       	push	r0
    431a:	cd b7       	in	r28, 0x3d	; 61
    431c:	de b7       	in	r29, 0x3e	; 62
    431e:	9d 83       	std	Y+5, r25	; 0x05
    4320:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    4322:	8c 81       	ldd	r24, Y+4	; 0x04
    4324:	9d 81       	ldd	r25, Y+5	; 0x05
    4326:	9b 83       	std	Y+3, r25	; 0x03
    4328:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    432a:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    432c:	8c 81       	ldd	r24, Y+4	; 0x04
    432e:	9d 81       	ldd	r25, Y+5	; 0x05
    4330:	00 97       	sbiw	r24, 0x00	; 0
    4332:	09 f4       	brne	.+2      	; 0x4336 <xTaskPriorityDisinherit+0x26>
    4334:	56 c0       	rjmp	.+172    	; 0x43e2 <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4336:	ea 81       	ldd	r30, Y+2	; 0x02
    4338:	fb 81       	ldd	r31, Y+3	; 0x03
    433a:	84 a1       	ldd	r24, Z+36	; 0x24
    433c:	81 50       	subi	r24, 0x01	; 1
    433e:	ea 81       	ldd	r30, Y+2	; 0x02
    4340:	fb 81       	ldd	r31, Y+3	; 0x03
    4342:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4344:	ea 81       	ldd	r30, Y+2	; 0x02
    4346:	fb 81       	ldd	r31, Y+3	; 0x03
    4348:	96 89       	ldd	r25, Z+22	; 0x16
    434a:	ea 81       	ldd	r30, Y+2	; 0x02
    434c:	fb 81       	ldd	r31, Y+3	; 0x03
    434e:	83 a1       	ldd	r24, Z+35	; 0x23
    4350:	98 17       	cp	r25, r24
    4352:	09 f4       	brne	.+2      	; 0x4356 <xTaskPriorityDisinherit+0x46>
    4354:	46 c0       	rjmp	.+140    	; 0x43e2 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4356:	ea 81       	ldd	r30, Y+2	; 0x02
    4358:	fb 81       	ldd	r31, Y+3	; 0x03
    435a:	84 a1       	ldd	r24, Z+36	; 0x24
    435c:	88 23       	and	r24, r24
    435e:	09 f0       	breq	.+2      	; 0x4362 <xTaskPriorityDisinherit+0x52>
    4360:	40 c0       	rjmp	.+128    	; 0x43e2 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4362:	8a 81       	ldd	r24, Y+2	; 0x02
    4364:	9b 81       	ldd	r25, Y+3	; 0x03
    4366:	02 96       	adiw	r24, 0x02	; 2
    4368:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    436c:	ea 81       	ldd	r30, Y+2	; 0x02
    436e:	fb 81       	ldd	r31, Y+3	; 0x03
    4370:	83 a1       	ldd	r24, Z+35	; 0x23
    4372:	ea 81       	ldd	r30, Y+2	; 0x02
    4374:	fb 81       	ldd	r31, Y+3	; 0x03
    4376:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4378:	ea 81       	ldd	r30, Y+2	; 0x02
    437a:	fb 81       	ldd	r31, Y+3	; 0x03
    437c:	86 89       	ldd	r24, Z+22	; 0x16
    437e:	28 2f       	mov	r18, r24
    4380:	30 e0       	ldi	r19, 0x00	; 0
    4382:	84 e0       	ldi	r24, 0x04	; 4
    4384:	90 e0       	ldi	r25, 0x00	; 0
    4386:	82 1b       	sub	r24, r18
    4388:	93 0b       	sbc	r25, r19
    438a:	ea 81       	ldd	r30, Y+2	; 0x02
    438c:	fb 81       	ldd	r31, Y+3	; 0x03
    438e:	95 87       	std	Z+13, r25	; 0x0d
    4390:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4392:	ea 81       	ldd	r30, Y+2	; 0x02
    4394:	fb 81       	ldd	r31, Y+3	; 0x03
    4396:	96 89       	ldd	r25, Z+22	; 0x16
    4398:	80 91 4c 06 	lds	r24, 0x064C
    439c:	89 17       	cp	r24, r25
    439e:	28 f4       	brcc	.+10     	; 0x43aa <xTaskPriorityDisinherit+0x9a>
    43a0:	ea 81       	ldd	r30, Y+2	; 0x02
    43a2:	fb 81       	ldd	r31, Y+3	; 0x03
    43a4:	86 89       	ldd	r24, Z+22	; 0x16
    43a6:	80 93 4c 06 	sts	0x064C, r24
    43aa:	ea 81       	ldd	r30, Y+2	; 0x02
    43ac:	fb 81       	ldd	r31, Y+3	; 0x03
    43ae:	86 89       	ldd	r24, Z+22	; 0x16
    43b0:	28 2f       	mov	r18, r24
    43b2:	30 e0       	ldi	r19, 0x00	; 0
    43b4:	c9 01       	movw	r24, r18
    43b6:	88 0f       	add	r24, r24
    43b8:	99 1f       	adc	r25, r25
    43ba:	88 0f       	add	r24, r24
    43bc:	99 1f       	adc	r25, r25
    43be:	88 0f       	add	r24, r24
    43c0:	99 1f       	adc	r25, r25
    43c2:	82 0f       	add	r24, r18
    43c4:	93 1f       	adc	r25, r19
    43c6:	ac 01       	movw	r20, r24
    43c8:	49 5a       	subi	r20, 0xA9	; 169
    43ca:	59 4f       	sbci	r21, 0xF9	; 249
    43cc:	8a 81       	ldd	r24, Y+2	; 0x02
    43ce:	9b 81       	ldd	r25, Y+3	; 0x03
    43d0:	9c 01       	movw	r18, r24
    43d2:	2e 5f       	subi	r18, 0xFE	; 254
    43d4:	3f 4f       	sbci	r19, 0xFF	; 255
    43d6:	ca 01       	movw	r24, r20
    43d8:	b9 01       	movw	r22, r18
    43da:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    43de:	81 e0       	ldi	r24, 0x01	; 1
    43e0:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    43e2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    43e4:	0f 90       	pop	r0
    43e6:	0f 90       	pop	r0
    43e8:	0f 90       	pop	r0
    43ea:	0f 90       	pop	r0
    43ec:	0f 90       	pop	r0
    43ee:	cf 91       	pop	r28
    43f0:	df 91       	pop	r29
    43f2:	08 95       	ret

000043f4 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    43f4:	df 93       	push	r29
    43f6:	cf 93       	push	r28
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    43fc:	28 97       	sbiw	r28, 0x08	; 8
    43fe:	0f b6       	in	r0, 0x3f	; 63
    4400:	f8 94       	cli
    4402:	de bf       	out	0x3e, r29	; 62
    4404:	0f be       	out	0x3f, r0	; 63
    4406:	cd bf       	out	0x3d, r28	; 61
    4408:	9f 83       	std	Y+7, r25	; 0x07
    440a:	8e 83       	std	Y+6, r24	; 0x06
    440c:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    440e:	8e 81       	ldd	r24, Y+6	; 0x06
    4410:	9f 81       	ldd	r25, Y+7	; 0x07
    4412:	9d 83       	std	Y+5, r25	; 0x05
    4414:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    4416:	81 e0       	ldi	r24, 0x01	; 1
    4418:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    441a:	8e 81       	ldd	r24, Y+6	; 0x06
    441c:	9f 81       	ldd	r25, Y+7	; 0x07
    441e:	00 97       	sbiw	r24, 0x00	; 0
    4420:	09 f4       	brne	.+2      	; 0x4424 <vTaskPriorityDisinheritAfterTimeout+0x30>
    4422:	74 c0       	rjmp	.+232    	; 0x450c <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    4424:	ec 81       	ldd	r30, Y+4	; 0x04
    4426:	fd 81       	ldd	r31, Y+5	; 0x05
    4428:	93 a1       	ldd	r25, Z+35	; 0x23
    442a:	88 85       	ldd	r24, Y+8	; 0x08
    442c:	98 17       	cp	r25, r24
    442e:	18 f4       	brcc	.+6      	; 0x4436 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    4430:	88 85       	ldd	r24, Y+8	; 0x08
    4432:	8a 83       	std	Y+2, r24	; 0x02
    4434:	04 c0       	rjmp	.+8      	; 0x443e <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    4436:	ec 81       	ldd	r30, Y+4	; 0x04
    4438:	fd 81       	ldd	r31, Y+5	; 0x05
    443a:	83 a1       	ldd	r24, Z+35	; 0x23
    443c:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    443e:	ec 81       	ldd	r30, Y+4	; 0x04
    4440:	fd 81       	ldd	r31, Y+5	; 0x05
    4442:	96 89       	ldd	r25, Z+22	; 0x16
    4444:	8a 81       	ldd	r24, Y+2	; 0x02
    4446:	98 17       	cp	r25, r24
    4448:	09 f4       	brne	.+2      	; 0x444c <vTaskPriorityDisinheritAfterTimeout+0x58>
    444a:	60 c0       	rjmp	.+192    	; 0x450c <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    444c:	ec 81       	ldd	r30, Y+4	; 0x04
    444e:	fd 81       	ldd	r31, Y+5	; 0x05
    4450:	94 a1       	ldd	r25, Z+36	; 0x24
    4452:	89 81       	ldd	r24, Y+1	; 0x01
    4454:	98 17       	cp	r25, r24
    4456:	09 f0       	breq	.+2      	; 0x445a <vTaskPriorityDisinheritAfterTimeout+0x66>
    4458:	59 c0       	rjmp	.+178    	; 0x450c <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    445a:	ec 81       	ldd	r30, Y+4	; 0x04
    445c:	fd 81       	ldd	r31, Y+5	; 0x05
    445e:	86 89       	ldd	r24, Z+22	; 0x16
    4460:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    4462:	ec 81       	ldd	r30, Y+4	; 0x04
    4464:	fd 81       	ldd	r31, Y+5	; 0x05
    4466:	8a 81       	ldd	r24, Y+2	; 0x02
    4468:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    446a:	ec 81       	ldd	r30, Y+4	; 0x04
    446c:	fd 81       	ldd	r31, Y+5	; 0x05
    446e:	84 85       	ldd	r24, Z+12	; 0x0c
    4470:	95 85       	ldd	r25, Z+13	; 0x0d
    4472:	99 23       	and	r25, r25
    4474:	5c f0       	brlt	.+22     	; 0x448c <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4476:	8a 81       	ldd	r24, Y+2	; 0x02
    4478:	28 2f       	mov	r18, r24
    447a:	30 e0       	ldi	r19, 0x00	; 0
    447c:	84 e0       	ldi	r24, 0x04	; 4
    447e:	90 e0       	ldi	r25, 0x00	; 0
    4480:	82 1b       	sub	r24, r18
    4482:	93 0b       	sbc	r25, r19
    4484:	ec 81       	ldd	r30, Y+4	; 0x04
    4486:	fd 81       	ldd	r31, Y+5	; 0x05
    4488:	95 87       	std	Z+13, r25	; 0x0d
    448a:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    448c:	ec 81       	ldd	r30, Y+4	; 0x04
    448e:	fd 81       	ldd	r31, Y+5	; 0x05
    4490:	42 85       	ldd	r20, Z+10	; 0x0a
    4492:	53 85       	ldd	r21, Z+11	; 0x0b
    4494:	8b 81       	ldd	r24, Y+3	; 0x03
    4496:	28 2f       	mov	r18, r24
    4498:	30 e0       	ldi	r19, 0x00	; 0
    449a:	c9 01       	movw	r24, r18
    449c:	88 0f       	add	r24, r24
    449e:	99 1f       	adc	r25, r25
    44a0:	88 0f       	add	r24, r24
    44a2:	99 1f       	adc	r25, r25
    44a4:	88 0f       	add	r24, r24
    44a6:	99 1f       	adc	r25, r25
    44a8:	82 0f       	add	r24, r18
    44aa:	93 1f       	adc	r25, r19
    44ac:	89 5a       	subi	r24, 0xA9	; 169
    44ae:	99 4f       	sbci	r25, 0xF9	; 249
    44b0:	48 17       	cp	r20, r24
    44b2:	59 07       	cpc	r21, r25
    44b4:	59 f5       	brne	.+86     	; 0x450c <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    44b6:	8c 81       	ldd	r24, Y+4	; 0x04
    44b8:	9d 81       	ldd	r25, Y+5	; 0x05
    44ba:	02 96       	adiw	r24, 0x02	; 2
    44bc:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    44c0:	ec 81       	ldd	r30, Y+4	; 0x04
    44c2:	fd 81       	ldd	r31, Y+5	; 0x05
    44c4:	96 89       	ldd	r25, Z+22	; 0x16
    44c6:	80 91 4c 06 	lds	r24, 0x064C
    44ca:	89 17       	cp	r24, r25
    44cc:	28 f4       	brcc	.+10     	; 0x44d8 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    44ce:	ec 81       	ldd	r30, Y+4	; 0x04
    44d0:	fd 81       	ldd	r31, Y+5	; 0x05
    44d2:	86 89       	ldd	r24, Z+22	; 0x16
    44d4:	80 93 4c 06 	sts	0x064C, r24
    44d8:	ec 81       	ldd	r30, Y+4	; 0x04
    44da:	fd 81       	ldd	r31, Y+5	; 0x05
    44dc:	86 89       	ldd	r24, Z+22	; 0x16
    44de:	28 2f       	mov	r18, r24
    44e0:	30 e0       	ldi	r19, 0x00	; 0
    44e2:	c9 01       	movw	r24, r18
    44e4:	88 0f       	add	r24, r24
    44e6:	99 1f       	adc	r25, r25
    44e8:	88 0f       	add	r24, r24
    44ea:	99 1f       	adc	r25, r25
    44ec:	88 0f       	add	r24, r24
    44ee:	99 1f       	adc	r25, r25
    44f0:	82 0f       	add	r24, r18
    44f2:	93 1f       	adc	r25, r19
    44f4:	ac 01       	movw	r20, r24
    44f6:	49 5a       	subi	r20, 0xA9	; 169
    44f8:	59 4f       	sbci	r21, 0xF9	; 249
    44fa:	8c 81       	ldd	r24, Y+4	; 0x04
    44fc:	9d 81       	ldd	r25, Y+5	; 0x05
    44fe:	9c 01       	movw	r18, r24
    4500:	2e 5f       	subi	r18, 0xFE	; 254
    4502:	3f 4f       	sbci	r19, 0xFF	; 255
    4504:	ca 01       	movw	r24, r20
    4506:	b9 01       	movw	r22, r18
    4508:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    450c:	28 96       	adiw	r28, 0x08	; 8
    450e:	0f b6       	in	r0, 0x3f	; 63
    4510:	f8 94       	cli
    4512:	de bf       	out	0x3e, r29	; 62
    4514:	0f be       	out	0x3f, r0	; 63
    4516:	cd bf       	out	0x3d, r28	; 61
    4518:	cf 91       	pop	r28
    451a:	df 91       	pop	r29
    451c:	08 95       	ret

0000451e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    451e:	df 93       	push	r29
    4520:	cf 93       	push	r28
    4522:	00 d0       	rcall	.+0      	; 0x4524 <uxTaskResetEventItemValue+0x6>
    4524:	cd b7       	in	r28, 0x3d	; 61
    4526:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4528:	e0 91 46 06 	lds	r30, 0x0646
    452c:	f0 91 47 06 	lds	r31, 0x0647
    4530:	84 85       	ldd	r24, Z+12	; 0x0c
    4532:	95 85       	ldd	r25, Z+13	; 0x0d
    4534:	9a 83       	std	Y+2, r25	; 0x02
    4536:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4538:	a0 91 46 06 	lds	r26, 0x0646
    453c:	b0 91 47 06 	lds	r27, 0x0647
    4540:	e0 91 46 06 	lds	r30, 0x0646
    4544:	f0 91 47 06 	lds	r31, 0x0647
    4548:	86 89       	ldd	r24, Z+22	; 0x16
    454a:	28 2f       	mov	r18, r24
    454c:	30 e0       	ldi	r19, 0x00	; 0
    454e:	84 e0       	ldi	r24, 0x04	; 4
    4550:	90 e0       	ldi	r25, 0x00	; 0
    4552:	82 1b       	sub	r24, r18
    4554:	93 0b       	sbc	r25, r19
    4556:	1d 96       	adiw	r26, 0x0d	; 13
    4558:	9c 93       	st	X, r25
    455a:	8e 93       	st	-X, r24
    455c:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    455e:	89 81       	ldd	r24, Y+1	; 0x01
    4560:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4562:	0f 90       	pop	r0
    4564:	0f 90       	pop	r0
    4566:	cf 91       	pop	r28
    4568:	df 91       	pop	r29
    456a:	08 95       	ret

0000456c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    456c:	df 93       	push	r29
    456e:	cf 93       	push	r28
    4570:	cd b7       	in	r28, 0x3d	; 61
    4572:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4574:	80 91 46 06 	lds	r24, 0x0646
    4578:	90 91 47 06 	lds	r25, 0x0647
    457c:	00 97       	sbiw	r24, 0x00	; 0
    457e:	39 f0       	breq	.+14     	; 0x458e <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4580:	e0 91 46 06 	lds	r30, 0x0646
    4584:	f0 91 47 06 	lds	r31, 0x0647
    4588:	84 a1       	ldd	r24, Z+36	; 0x24
    458a:	8f 5f       	subi	r24, 0xFF	; 255
    458c:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    458e:	80 91 46 06 	lds	r24, 0x0646
    4592:	90 91 47 06 	lds	r25, 0x0647
	}
    4596:	cf 91       	pop	r28
    4598:	df 91       	pop	r29
    459a:	08 95       	ret

0000459c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    459c:	df 93       	push	r29
    459e:	cf 93       	push	r28
    45a0:	cd b7       	in	r28, 0x3d	; 61
    45a2:	de b7       	in	r29, 0x3e	; 62
    45a4:	27 97       	sbiw	r28, 0x07	; 7
    45a6:	0f b6       	in	r0, 0x3f	; 63
    45a8:	f8 94       	cli
    45aa:	de bf       	out	0x3e, r29	; 62
    45ac:	0f be       	out	0x3f, r0	; 63
    45ae:	cd bf       	out	0x3d, r28	; 61
    45b0:	8d 83       	std	Y+5, r24	; 0x05
    45b2:	7f 83       	std	Y+7, r23	; 0x07
    45b4:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    45b6:	0f b6       	in	r0, 0x3f	; 63
    45b8:	f8 94       	cli
    45ba:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    45bc:	e0 91 46 06 	lds	r30, 0x0646
    45c0:	f0 91 47 06 	lds	r31, 0x0647
    45c4:	85 a1       	ldd	r24, Z+37	; 0x25
    45c6:	96 a1       	ldd	r25, Z+38	; 0x26
    45c8:	a7 a1       	ldd	r26, Z+39	; 0x27
    45ca:	b0 a5       	ldd	r27, Z+40	; 0x28
    45cc:	00 97       	sbiw	r24, 0x00	; 0
    45ce:	a1 05       	cpc	r26, r1
    45d0:	b1 05       	cpc	r27, r1
    45d2:	89 f4       	brne	.+34     	; 0x45f6 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    45d4:	e0 91 46 06 	lds	r30, 0x0646
    45d8:	f0 91 47 06 	lds	r31, 0x0647
    45dc:	81 e0       	ldi	r24, 0x01	; 1
    45de:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    45e0:	8e 81       	ldd	r24, Y+6	; 0x06
    45e2:	9f 81       	ldd	r25, Y+7	; 0x07
    45e4:	00 97       	sbiw	r24, 0x00	; 0
    45e6:	39 f0       	breq	.+14     	; 0x45f6 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45e8:	8e 81       	ldd	r24, Y+6	; 0x06
    45ea:	9f 81       	ldd	r25, Y+7	; 0x07
    45ec:	61 e0       	ldi	r22, 0x01	; 1
    45ee:	0e 94 76 26 	call	0x4cec	; 0x4cec <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    45f2:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    45f6:	0f 90       	pop	r0
    45f8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    45fa:	0f b6       	in	r0, 0x3f	; 63
    45fc:	f8 94       	cli
    45fe:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4600:	e0 91 46 06 	lds	r30, 0x0646
    4604:	f0 91 47 06 	lds	r31, 0x0647
    4608:	85 a1       	ldd	r24, Z+37	; 0x25
    460a:	96 a1       	ldd	r25, Z+38	; 0x26
    460c:	a7 a1       	ldd	r26, Z+39	; 0x27
    460e:	b0 a5       	ldd	r27, Z+40	; 0x28
    4610:	89 83       	std	Y+1, r24	; 0x01
    4612:	9a 83       	std	Y+2, r25	; 0x02
    4614:	ab 83       	std	Y+3, r26	; 0x03
    4616:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4618:	89 81       	ldd	r24, Y+1	; 0x01
    461a:	9a 81       	ldd	r25, Y+2	; 0x02
    461c:	ab 81       	ldd	r26, Y+3	; 0x03
    461e:	bc 81       	ldd	r27, Y+4	; 0x04
    4620:	00 97       	sbiw	r24, 0x00	; 0
    4622:	a1 05       	cpc	r26, r1
    4624:	b1 05       	cpc	r27, r1
    4626:	d9 f0       	breq	.+54     	; 0x465e <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4628:	8d 81       	ldd	r24, Y+5	; 0x05
    462a:	88 23       	and	r24, r24
    462c:	49 f0       	breq	.+18     	; 0x4640 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    462e:	e0 91 46 06 	lds	r30, 0x0646
    4632:	f0 91 47 06 	lds	r31, 0x0647
    4636:	15 a2       	std	Z+37, r1	; 0x25
    4638:	16 a2       	std	Z+38, r1	; 0x26
    463a:	17 a2       	std	Z+39, r1	; 0x27
    463c:	10 a6       	std	Z+40, r1	; 0x28
    463e:	0f c0       	rjmp	.+30     	; 0x465e <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4640:	e0 91 46 06 	lds	r30, 0x0646
    4644:	f0 91 47 06 	lds	r31, 0x0647
    4648:	89 81       	ldd	r24, Y+1	; 0x01
    464a:	9a 81       	ldd	r25, Y+2	; 0x02
    464c:	ab 81       	ldd	r26, Y+3	; 0x03
    464e:	bc 81       	ldd	r27, Y+4	; 0x04
    4650:	01 97       	sbiw	r24, 0x01	; 1
    4652:	a1 09       	sbc	r26, r1
    4654:	b1 09       	sbc	r27, r1
    4656:	85 a3       	std	Z+37, r24	; 0x25
    4658:	96 a3       	std	Z+38, r25	; 0x26
    465a:	a7 a3       	std	Z+39, r26	; 0x27
    465c:	b0 a7       	std	Z+40, r27	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    465e:	e0 91 46 06 	lds	r30, 0x0646
    4662:	f0 91 47 06 	lds	r31, 0x0647
    4666:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4668:	0f 90       	pop	r0
    466a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    466c:	89 81       	ldd	r24, Y+1	; 0x01
    466e:	9a 81       	ldd	r25, Y+2	; 0x02
    4670:	ab 81       	ldd	r26, Y+3	; 0x03
    4672:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4674:	bc 01       	movw	r22, r24
    4676:	cd 01       	movw	r24, r26
    4678:	27 96       	adiw	r28, 0x07	; 7
    467a:	0f b6       	in	r0, 0x3f	; 63
    467c:	f8 94       	cli
    467e:	de bf       	out	0x3e, r29	; 62
    4680:	0f be       	out	0x3f, r0	; 63
    4682:	cd bf       	out	0x3d, r28	; 61
    4684:	cf 91       	pop	r28
    4686:	df 91       	pop	r29
    4688:	08 95       	ret

0000468a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    468a:	ef 92       	push	r14
    468c:	ff 92       	push	r15
    468e:	0f 93       	push	r16
    4690:	1f 93       	push	r17
    4692:	df 93       	push	r29
    4694:	cf 93       	push	r28
    4696:	cd b7       	in	r28, 0x3d	; 61
    4698:	de b7       	in	r29, 0x3e	; 62
    469a:	2d 97       	sbiw	r28, 0x0d	; 13
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	6a 83       	std	Y+2, r22	; 0x02
    46a8:	7b 83       	std	Y+3, r23	; 0x03
    46aa:	8c 83       	std	Y+4, r24	; 0x04
    46ac:	9d 83       	std	Y+5, r25	; 0x05
    46ae:	2e 83       	std	Y+6, r18	; 0x06
    46b0:	3f 83       	std	Y+7, r19	; 0x07
    46b2:	48 87       	std	Y+8, r20	; 0x08
    46b4:	59 87       	std	Y+9, r21	; 0x09
    46b6:	1b 87       	std	Y+11, r17	; 0x0b
    46b8:	0a 87       	std	Y+10, r16	; 0x0a
    46ba:	fd 86       	std	Y+13, r15	; 0x0d
    46bc:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    46be:	0f b6       	in	r0, 0x3f	; 63
    46c0:	f8 94       	cli
    46c2:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    46c4:	e0 91 46 06 	lds	r30, 0x0646
    46c8:	f0 91 47 06 	lds	r31, 0x0647
    46cc:	81 a5       	ldd	r24, Z+41	; 0x29
    46ce:	82 30       	cpi	r24, 0x02	; 2
    46d0:	49 f1       	breq	.+82     	; 0x4724 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    46d2:	e0 91 46 06 	lds	r30, 0x0646
    46d6:	f0 91 47 06 	lds	r31, 0x0647
    46da:	25 a1       	ldd	r18, Z+37	; 0x25
    46dc:	36 a1       	ldd	r19, Z+38	; 0x26
    46de:	47 a1       	ldd	r20, Z+39	; 0x27
    46e0:	50 a5       	ldd	r21, Z+40	; 0x28
    46e2:	8a 81       	ldd	r24, Y+2	; 0x02
    46e4:	9b 81       	ldd	r25, Y+3	; 0x03
    46e6:	ac 81       	ldd	r26, Y+4	; 0x04
    46e8:	bd 81       	ldd	r27, Y+5	; 0x05
    46ea:	80 95       	com	r24
    46ec:	90 95       	com	r25
    46ee:	a0 95       	com	r26
    46f0:	b0 95       	com	r27
    46f2:	82 23       	and	r24, r18
    46f4:	93 23       	and	r25, r19
    46f6:	a4 23       	and	r26, r20
    46f8:	b5 23       	and	r27, r21
    46fa:	85 a3       	std	Z+37, r24	; 0x25
    46fc:	96 a3       	std	Z+38, r25	; 0x26
    46fe:	a7 a3       	std	Z+39, r26	; 0x27
    4700:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4702:	e0 91 46 06 	lds	r30, 0x0646
    4706:	f0 91 47 06 	lds	r31, 0x0647
    470a:	81 e0       	ldi	r24, 0x01	; 1
    470c:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    470e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4710:	9d 85       	ldd	r25, Y+13	; 0x0d
    4712:	00 97       	sbiw	r24, 0x00	; 0
    4714:	39 f0       	breq	.+14     	; 0x4724 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4716:	8c 85       	ldd	r24, Y+12	; 0x0c
    4718:	9d 85       	ldd	r25, Y+13	; 0x0d
    471a:	61 e0       	ldi	r22, 0x01	; 1
    471c:	0e 94 76 26 	call	0x4cec	; 0x4cec <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4720:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4724:	0f 90       	pop	r0
    4726:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4728:	0f b6       	in	r0, 0x3f	; 63
    472a:	f8 94       	cli
    472c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    472e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4730:	9b 85       	ldd	r25, Y+11	; 0x0b
    4732:	00 97       	sbiw	r24, 0x00	; 0
    4734:	71 f0       	breq	.+28     	; 0x4752 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4736:	e0 91 46 06 	lds	r30, 0x0646
    473a:	f0 91 47 06 	lds	r31, 0x0647
    473e:	85 a1       	ldd	r24, Z+37	; 0x25
    4740:	96 a1       	ldd	r25, Z+38	; 0x26
    4742:	a7 a1       	ldd	r26, Z+39	; 0x27
    4744:	b0 a5       	ldd	r27, Z+40	; 0x28
    4746:	ea 85       	ldd	r30, Y+10	; 0x0a
    4748:	fb 85       	ldd	r31, Y+11	; 0x0b
    474a:	80 83       	st	Z, r24
    474c:	91 83       	std	Z+1, r25	; 0x01
    474e:	a2 83       	std	Z+2, r26	; 0x02
    4750:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4752:	e0 91 46 06 	lds	r30, 0x0646
    4756:	f0 91 47 06 	lds	r31, 0x0647
    475a:	81 a5       	ldd	r24, Z+41	; 0x29
    475c:	82 30       	cpi	r24, 0x02	; 2
    475e:	11 f0       	breq	.+4      	; 0x4764 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4760:	19 82       	std	Y+1, r1	; 0x01
    4762:	1a c0       	rjmp	.+52     	; 0x4798 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4764:	e0 91 46 06 	lds	r30, 0x0646
    4768:	f0 91 47 06 	lds	r31, 0x0647
    476c:	25 a1       	ldd	r18, Z+37	; 0x25
    476e:	36 a1       	ldd	r19, Z+38	; 0x26
    4770:	47 a1       	ldd	r20, Z+39	; 0x27
    4772:	50 a5       	ldd	r21, Z+40	; 0x28
    4774:	8e 81       	ldd	r24, Y+6	; 0x06
    4776:	9f 81       	ldd	r25, Y+7	; 0x07
    4778:	a8 85       	ldd	r26, Y+8	; 0x08
    477a:	b9 85       	ldd	r27, Y+9	; 0x09
    477c:	80 95       	com	r24
    477e:	90 95       	com	r25
    4780:	a0 95       	com	r26
    4782:	b0 95       	com	r27
    4784:	82 23       	and	r24, r18
    4786:	93 23       	and	r25, r19
    4788:	a4 23       	and	r26, r20
    478a:	b5 23       	and	r27, r21
    478c:	85 a3       	std	Z+37, r24	; 0x25
    478e:	96 a3       	std	Z+38, r25	; 0x26
    4790:	a7 a3       	std	Z+39, r26	; 0x27
    4792:	b0 a7       	std	Z+40, r27	; 0x28
				xReturn = pdTRUE;
    4794:	81 e0       	ldi	r24, 0x01	; 1
    4796:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4798:	e0 91 46 06 	lds	r30, 0x0646
    479c:	f0 91 47 06 	lds	r31, 0x0647
    47a0:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    47a2:	0f 90       	pop	r0
    47a4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    47a6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    47a8:	2d 96       	adiw	r28, 0x0d	; 13
    47aa:	0f b6       	in	r0, 0x3f	; 63
    47ac:	f8 94       	cli
    47ae:	de bf       	out	0x3e, r29	; 62
    47b0:	0f be       	out	0x3f, r0	; 63
    47b2:	cd bf       	out	0x3d, r28	; 61
    47b4:	cf 91       	pop	r28
    47b6:	df 91       	pop	r29
    47b8:	1f 91       	pop	r17
    47ba:	0f 91       	pop	r16
    47bc:	ff 90       	pop	r15
    47be:	ef 90       	pop	r14
    47c0:	08 95       	ret

000047c2 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    47c2:	0f 93       	push	r16
    47c4:	1f 93       	push	r17
    47c6:	df 93       	push	r29
    47c8:	cf 93       	push	r28
    47ca:	cd b7       	in	r28, 0x3d	; 61
    47cc:	de b7       	in	r29, 0x3e	; 62
    47ce:	2f 97       	sbiw	r28, 0x0f	; 15
    47d0:	0f b6       	in	r0, 0x3f	; 63
    47d2:	f8 94       	cli
    47d4:	de bf       	out	0x3e, r29	; 62
    47d6:	0f be       	out	0x3f, r0	; 63
    47d8:	cd bf       	out	0x3d, r28	; 61
    47da:	9e 83       	std	Y+6, r25	; 0x06
    47dc:	8d 83       	std	Y+5, r24	; 0x05
    47de:	4f 83       	std	Y+7, r20	; 0x07
    47e0:	58 87       	std	Y+8, r21	; 0x08
    47e2:	69 87       	std	Y+9, r22	; 0x09
    47e4:	7a 87       	std	Y+10, r23	; 0x0a
    47e6:	2b 87       	std	Y+11, r18	; 0x0b
    47e8:	1d 87       	std	Y+13, r17	; 0x0d
    47ea:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    47ec:	81 e0       	ldi	r24, 0x01	; 1
    47ee:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    47f0:	8d 81       	ldd	r24, Y+5	; 0x05
    47f2:	9e 81       	ldd	r25, Y+6	; 0x06
    47f4:	9c 83       	std	Y+4, r25	; 0x04
    47f6:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    47f8:	0f b6       	in	r0, 0x3f	; 63
    47fa:	f8 94       	cli
    47fc:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    47fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    4800:	9d 85       	ldd	r25, Y+13	; 0x0d
    4802:	00 97       	sbiw	r24, 0x00	; 0
    4804:	61 f0       	breq	.+24     	; 0x481e <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4806:	eb 81       	ldd	r30, Y+3	; 0x03
    4808:	fc 81       	ldd	r31, Y+4	; 0x04
    480a:	85 a1       	ldd	r24, Z+37	; 0x25
    480c:	96 a1       	ldd	r25, Z+38	; 0x26
    480e:	a7 a1       	ldd	r26, Z+39	; 0x27
    4810:	b0 a5       	ldd	r27, Z+40	; 0x28
    4812:	ec 85       	ldd	r30, Y+12	; 0x0c
    4814:	fd 85       	ldd	r31, Y+13	; 0x0d
    4816:	80 83       	st	Z, r24
    4818:	91 83       	std	Z+1, r25	; 0x01
    481a:	a2 83       	std	Z+2, r26	; 0x02
    481c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    481e:	eb 81       	ldd	r30, Y+3	; 0x03
    4820:	fc 81       	ldd	r31, Y+4	; 0x04
    4822:	81 a5       	ldd	r24, Z+41	; 0x29
    4824:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4826:	eb 81       	ldd	r30, Y+3	; 0x03
    4828:	fc 81       	ldd	r31, Y+4	; 0x04
    482a:	82 e0       	ldi	r24, 0x02	; 2
    482c:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    482e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4830:	28 2f       	mov	r18, r24
    4832:	30 e0       	ldi	r19, 0x00	; 0
    4834:	3f 87       	std	Y+15, r19	; 0x0f
    4836:	2e 87       	std	Y+14, r18	; 0x0e
    4838:	8e 85       	ldd	r24, Y+14	; 0x0e
    483a:	9f 85       	ldd	r25, Y+15	; 0x0f
    483c:	82 30       	cpi	r24, 0x02	; 2
    483e:	91 05       	cpc	r25, r1
    4840:	59 f1       	breq	.+86     	; 0x4898 <xTaskGenericNotify+0xd6>
    4842:	2e 85       	ldd	r18, Y+14	; 0x0e
    4844:	3f 85       	ldd	r19, Y+15	; 0x0f
    4846:	23 30       	cpi	r18, 0x03	; 3
    4848:	31 05       	cpc	r19, r1
    484a:	34 f4       	brge	.+12     	; 0x4858 <xTaskGenericNotify+0x96>
    484c:	8e 85       	ldd	r24, Y+14	; 0x0e
    484e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4850:	81 30       	cpi	r24, 0x01	; 1
    4852:	91 05       	cpc	r25, r1
    4854:	61 f0       	breq	.+24     	; 0x486e <xTaskGenericNotify+0xac>
    4856:	4a c0       	rjmp	.+148    	; 0x48ec <xTaskGenericNotify+0x12a>
    4858:	2e 85       	ldd	r18, Y+14	; 0x0e
    485a:	3f 85       	ldd	r19, Y+15	; 0x0f
    485c:	23 30       	cpi	r18, 0x03	; 3
    485e:	31 05       	cpc	r19, r1
    4860:	59 f1       	breq	.+86     	; 0x48b8 <xTaskGenericNotify+0xf6>
    4862:	8e 85       	ldd	r24, Y+14	; 0x0e
    4864:	9f 85       	ldd	r25, Y+15	; 0x0f
    4866:	84 30       	cpi	r24, 0x04	; 4
    4868:	91 05       	cpc	r25, r1
    486a:	89 f1       	breq	.+98     	; 0x48ce <xTaskGenericNotify+0x10c>
    486c:	3f c0       	rjmp	.+126    	; 0x48ec <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    486e:	eb 81       	ldd	r30, Y+3	; 0x03
    4870:	fc 81       	ldd	r31, Y+4	; 0x04
    4872:	25 a1       	ldd	r18, Z+37	; 0x25
    4874:	36 a1       	ldd	r19, Z+38	; 0x26
    4876:	47 a1       	ldd	r20, Z+39	; 0x27
    4878:	50 a5       	ldd	r21, Z+40	; 0x28
    487a:	8f 81       	ldd	r24, Y+7	; 0x07
    487c:	98 85       	ldd	r25, Y+8	; 0x08
    487e:	a9 85       	ldd	r26, Y+9	; 0x09
    4880:	ba 85       	ldd	r27, Y+10	; 0x0a
    4882:	82 2b       	or	r24, r18
    4884:	93 2b       	or	r25, r19
    4886:	a4 2b       	or	r26, r20
    4888:	b5 2b       	or	r27, r21
    488a:	eb 81       	ldd	r30, Y+3	; 0x03
    488c:	fc 81       	ldd	r31, Y+4	; 0x04
    488e:	85 a3       	std	Z+37, r24	; 0x25
    4890:	96 a3       	std	Z+38, r25	; 0x26
    4892:	a7 a3       	std	Z+39, r26	; 0x27
    4894:	b0 a7       	std	Z+40, r27	; 0x28
    4896:	2a c0       	rjmp	.+84     	; 0x48ec <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4898:	eb 81       	ldd	r30, Y+3	; 0x03
    489a:	fc 81       	ldd	r31, Y+4	; 0x04
    489c:	85 a1       	ldd	r24, Z+37	; 0x25
    489e:	96 a1       	ldd	r25, Z+38	; 0x26
    48a0:	a7 a1       	ldd	r26, Z+39	; 0x27
    48a2:	b0 a5       	ldd	r27, Z+40	; 0x28
    48a4:	01 96       	adiw	r24, 0x01	; 1
    48a6:	a1 1d       	adc	r26, r1
    48a8:	b1 1d       	adc	r27, r1
    48aa:	eb 81       	ldd	r30, Y+3	; 0x03
    48ac:	fc 81       	ldd	r31, Y+4	; 0x04
    48ae:	85 a3       	std	Z+37, r24	; 0x25
    48b0:	96 a3       	std	Z+38, r25	; 0x26
    48b2:	a7 a3       	std	Z+39, r26	; 0x27
    48b4:	b0 a7       	std	Z+40, r27	; 0x28
    48b6:	1a c0       	rjmp	.+52     	; 0x48ec <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    48b8:	eb 81       	ldd	r30, Y+3	; 0x03
    48ba:	fc 81       	ldd	r31, Y+4	; 0x04
    48bc:	8f 81       	ldd	r24, Y+7	; 0x07
    48be:	98 85       	ldd	r25, Y+8	; 0x08
    48c0:	a9 85       	ldd	r26, Y+9	; 0x09
    48c2:	ba 85       	ldd	r27, Y+10	; 0x0a
    48c4:	85 a3       	std	Z+37, r24	; 0x25
    48c6:	96 a3       	std	Z+38, r25	; 0x26
    48c8:	a7 a3       	std	Z+39, r26	; 0x27
    48ca:	b0 a7       	std	Z+40, r27	; 0x28
    48cc:	0f c0       	rjmp	.+30     	; 0x48ec <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    48ce:	89 81       	ldd	r24, Y+1	; 0x01
    48d0:	82 30       	cpi	r24, 0x02	; 2
    48d2:	59 f0       	breq	.+22     	; 0x48ea <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    48d4:	eb 81       	ldd	r30, Y+3	; 0x03
    48d6:	fc 81       	ldd	r31, Y+4	; 0x04
    48d8:	8f 81       	ldd	r24, Y+7	; 0x07
    48da:	98 85       	ldd	r25, Y+8	; 0x08
    48dc:	a9 85       	ldd	r26, Y+9	; 0x09
    48de:	ba 85       	ldd	r27, Y+10	; 0x0a
    48e0:	85 a3       	std	Z+37, r24	; 0x25
    48e2:	96 a3       	std	Z+38, r25	; 0x26
    48e4:	a7 a3       	std	Z+39, r26	; 0x27
    48e6:	b0 a7       	std	Z+40, r27	; 0x28
    48e8:	01 c0       	rjmp	.+2      	; 0x48ec <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    48ea:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	81 30       	cpi	r24, 0x01	; 1
    48f0:	b9 f5       	brne	.+110    	; 0x4960 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    48f2:	8b 81       	ldd	r24, Y+3	; 0x03
    48f4:	9c 81       	ldd	r25, Y+4	; 0x04
    48f6:	02 96       	adiw	r24, 0x02	; 2
    48f8:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    48fc:	eb 81       	ldd	r30, Y+3	; 0x03
    48fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4900:	96 89       	ldd	r25, Z+22	; 0x16
    4902:	80 91 4c 06 	lds	r24, 0x064C
    4906:	89 17       	cp	r24, r25
    4908:	28 f4       	brcc	.+10     	; 0x4914 <xTaskGenericNotify+0x152>
    490a:	eb 81       	ldd	r30, Y+3	; 0x03
    490c:	fc 81       	ldd	r31, Y+4	; 0x04
    490e:	86 89       	ldd	r24, Z+22	; 0x16
    4910:	80 93 4c 06 	sts	0x064C, r24
    4914:	eb 81       	ldd	r30, Y+3	; 0x03
    4916:	fc 81       	ldd	r31, Y+4	; 0x04
    4918:	86 89       	ldd	r24, Z+22	; 0x16
    491a:	28 2f       	mov	r18, r24
    491c:	30 e0       	ldi	r19, 0x00	; 0
    491e:	c9 01       	movw	r24, r18
    4920:	88 0f       	add	r24, r24
    4922:	99 1f       	adc	r25, r25
    4924:	88 0f       	add	r24, r24
    4926:	99 1f       	adc	r25, r25
    4928:	88 0f       	add	r24, r24
    492a:	99 1f       	adc	r25, r25
    492c:	82 0f       	add	r24, r18
    492e:	93 1f       	adc	r25, r19
    4930:	ac 01       	movw	r20, r24
    4932:	49 5a       	subi	r20, 0xA9	; 169
    4934:	59 4f       	sbci	r21, 0xF9	; 249
    4936:	8b 81       	ldd	r24, Y+3	; 0x03
    4938:	9c 81       	ldd	r25, Y+4	; 0x04
    493a:	9c 01       	movw	r18, r24
    493c:	2e 5f       	subi	r18, 0xFE	; 254
    493e:	3f 4f       	sbci	r19, 0xFF	; 255
    4940:	ca 01       	movw	r24, r20
    4942:	b9 01       	movw	r22, r18
    4944:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4948:	eb 81       	ldd	r30, Y+3	; 0x03
    494a:	fc 81       	ldd	r31, Y+4	; 0x04
    494c:	96 89       	ldd	r25, Z+22	; 0x16
    494e:	e0 91 46 06 	lds	r30, 0x0646
    4952:	f0 91 47 06 	lds	r31, 0x0647
    4956:	86 89       	ldd	r24, Z+22	; 0x16
    4958:	89 17       	cp	r24, r25
    495a:	10 f4       	brcc	.+4      	; 0x4960 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    495c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4960:	0f 90       	pop	r0
    4962:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4964:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4966:	2f 96       	adiw	r28, 0x0f	; 15
    4968:	0f b6       	in	r0, 0x3f	; 63
    496a:	f8 94       	cli
    496c:	de bf       	out	0x3e, r29	; 62
    496e:	0f be       	out	0x3f, r0	; 63
    4970:	cd bf       	out	0x3d, r28	; 61
    4972:	cf 91       	pop	r28
    4974:	df 91       	pop	r29
    4976:	1f 91       	pop	r17
    4978:	0f 91       	pop	r16
    497a:	08 95       	ret

0000497c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    497c:	ef 92       	push	r14
    497e:	ff 92       	push	r15
    4980:	0f 93       	push	r16
    4982:	1f 93       	push	r17
    4984:	df 93       	push	r29
    4986:	cf 93       	push	r28
    4988:	cd b7       	in	r28, 0x3d	; 61
    498a:	de b7       	in	r29, 0x3e	; 62
    498c:	62 97       	sbiw	r28, 0x12	; 18
    498e:	0f b6       	in	r0, 0x3f	; 63
    4990:	f8 94       	cli
    4992:	de bf       	out	0x3e, r29	; 62
    4994:	0f be       	out	0x3f, r0	; 63
    4996:	cd bf       	out	0x3d, r28	; 61
    4998:	9f 83       	std	Y+7, r25	; 0x07
    499a:	8e 83       	std	Y+6, r24	; 0x06
    499c:	48 87       	std	Y+8, r20	; 0x08
    499e:	59 87       	std	Y+9, r21	; 0x09
    49a0:	6a 87       	std	Y+10, r22	; 0x0a
    49a2:	7b 87       	std	Y+11, r23	; 0x0b
    49a4:	2c 87       	std	Y+12, r18	; 0x0c
    49a6:	1e 87       	std	Y+14, r17	; 0x0e
    49a8:	0d 87       	std	Y+13, r16	; 0x0d
    49aa:	f8 8a       	std	Y+16, r15	; 0x10
    49ac:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    49ae:	81 e0       	ldi	r24, 0x01	; 1
    49b0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    49b2:	8e 81       	ldd	r24, Y+6	; 0x06
    49b4:	9f 81       	ldd	r25, Y+7	; 0x07
    49b6:	9d 83       	std	Y+5, r25	; 0x05
    49b8:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    49ba:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    49bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    49be:	9e 85       	ldd	r25, Y+14	; 0x0e
    49c0:	00 97       	sbiw	r24, 0x00	; 0
    49c2:	61 f0       	breq	.+24     	; 0x49dc <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    49c4:	ec 81       	ldd	r30, Y+4	; 0x04
    49c6:	fd 81       	ldd	r31, Y+5	; 0x05
    49c8:	85 a1       	ldd	r24, Z+37	; 0x25
    49ca:	96 a1       	ldd	r25, Z+38	; 0x26
    49cc:	a7 a1       	ldd	r26, Z+39	; 0x27
    49ce:	b0 a5       	ldd	r27, Z+40	; 0x28
    49d0:	ed 85       	ldd	r30, Y+13	; 0x0d
    49d2:	fe 85       	ldd	r31, Y+14	; 0x0e
    49d4:	80 83       	st	Z, r24
    49d6:	91 83       	std	Z+1, r25	; 0x01
    49d8:	a2 83       	std	Z+2, r26	; 0x02
    49da:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    49dc:	ec 81       	ldd	r30, Y+4	; 0x04
    49de:	fd 81       	ldd	r31, Y+5	; 0x05
    49e0:	81 a5       	ldd	r24, Z+41	; 0x29
    49e2:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    49e4:	ec 81       	ldd	r30, Y+4	; 0x04
    49e6:	fd 81       	ldd	r31, Y+5	; 0x05
    49e8:	82 e0       	ldi	r24, 0x02	; 2
    49ea:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    49ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    49ee:	28 2f       	mov	r18, r24
    49f0:	30 e0       	ldi	r19, 0x00	; 0
    49f2:	3a 8b       	std	Y+18, r19	; 0x12
    49f4:	29 8b       	std	Y+17, r18	; 0x11
    49f6:	89 89       	ldd	r24, Y+17	; 0x11
    49f8:	9a 89       	ldd	r25, Y+18	; 0x12
    49fa:	82 30       	cpi	r24, 0x02	; 2
    49fc:	91 05       	cpc	r25, r1
    49fe:	59 f1       	breq	.+86     	; 0x4a56 <xTaskGenericNotifyFromISR+0xda>
    4a00:	29 89       	ldd	r18, Y+17	; 0x11
    4a02:	3a 89       	ldd	r19, Y+18	; 0x12
    4a04:	23 30       	cpi	r18, 0x03	; 3
    4a06:	31 05       	cpc	r19, r1
    4a08:	34 f4       	brge	.+12     	; 0x4a16 <xTaskGenericNotifyFromISR+0x9a>
    4a0a:	89 89       	ldd	r24, Y+17	; 0x11
    4a0c:	9a 89       	ldd	r25, Y+18	; 0x12
    4a0e:	81 30       	cpi	r24, 0x01	; 1
    4a10:	91 05       	cpc	r25, r1
    4a12:	61 f0       	breq	.+24     	; 0x4a2c <xTaskGenericNotifyFromISR+0xb0>
    4a14:	4a c0       	rjmp	.+148    	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
    4a16:	29 89       	ldd	r18, Y+17	; 0x11
    4a18:	3a 89       	ldd	r19, Y+18	; 0x12
    4a1a:	23 30       	cpi	r18, 0x03	; 3
    4a1c:	31 05       	cpc	r19, r1
    4a1e:	59 f1       	breq	.+86     	; 0x4a76 <xTaskGenericNotifyFromISR+0xfa>
    4a20:	89 89       	ldd	r24, Y+17	; 0x11
    4a22:	9a 89       	ldd	r25, Y+18	; 0x12
    4a24:	84 30       	cpi	r24, 0x04	; 4
    4a26:	91 05       	cpc	r25, r1
    4a28:	89 f1       	breq	.+98     	; 0x4a8c <xTaskGenericNotifyFromISR+0x110>
    4a2a:	3f c0       	rjmp	.+126    	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4a2c:	ec 81       	ldd	r30, Y+4	; 0x04
    4a2e:	fd 81       	ldd	r31, Y+5	; 0x05
    4a30:	25 a1       	ldd	r18, Z+37	; 0x25
    4a32:	36 a1       	ldd	r19, Z+38	; 0x26
    4a34:	47 a1       	ldd	r20, Z+39	; 0x27
    4a36:	50 a5       	ldd	r21, Z+40	; 0x28
    4a38:	88 85       	ldd	r24, Y+8	; 0x08
    4a3a:	99 85       	ldd	r25, Y+9	; 0x09
    4a3c:	aa 85       	ldd	r26, Y+10	; 0x0a
    4a3e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4a40:	82 2b       	or	r24, r18
    4a42:	93 2b       	or	r25, r19
    4a44:	a4 2b       	or	r26, r20
    4a46:	b5 2b       	or	r27, r21
    4a48:	ec 81       	ldd	r30, Y+4	; 0x04
    4a4a:	fd 81       	ldd	r31, Y+5	; 0x05
    4a4c:	85 a3       	std	Z+37, r24	; 0x25
    4a4e:	96 a3       	std	Z+38, r25	; 0x26
    4a50:	a7 a3       	std	Z+39, r26	; 0x27
    4a52:	b0 a7       	std	Z+40, r27	; 0x28
    4a54:	2a c0       	rjmp	.+84     	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4a56:	ec 81       	ldd	r30, Y+4	; 0x04
    4a58:	fd 81       	ldd	r31, Y+5	; 0x05
    4a5a:	85 a1       	ldd	r24, Z+37	; 0x25
    4a5c:	96 a1       	ldd	r25, Z+38	; 0x26
    4a5e:	a7 a1       	ldd	r26, Z+39	; 0x27
    4a60:	b0 a5       	ldd	r27, Z+40	; 0x28
    4a62:	01 96       	adiw	r24, 0x01	; 1
    4a64:	a1 1d       	adc	r26, r1
    4a66:	b1 1d       	adc	r27, r1
    4a68:	ec 81       	ldd	r30, Y+4	; 0x04
    4a6a:	fd 81       	ldd	r31, Y+5	; 0x05
    4a6c:	85 a3       	std	Z+37, r24	; 0x25
    4a6e:	96 a3       	std	Z+38, r25	; 0x26
    4a70:	a7 a3       	std	Z+39, r26	; 0x27
    4a72:	b0 a7       	std	Z+40, r27	; 0x28
    4a74:	1a c0       	rjmp	.+52     	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4a76:	ec 81       	ldd	r30, Y+4	; 0x04
    4a78:	fd 81       	ldd	r31, Y+5	; 0x05
    4a7a:	88 85       	ldd	r24, Y+8	; 0x08
    4a7c:	99 85       	ldd	r25, Y+9	; 0x09
    4a7e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4a80:	bb 85       	ldd	r27, Y+11	; 0x0b
    4a82:	85 a3       	std	Z+37, r24	; 0x25
    4a84:	96 a3       	std	Z+38, r25	; 0x26
    4a86:	a7 a3       	std	Z+39, r26	; 0x27
    4a88:	b0 a7       	std	Z+40, r27	; 0x28
    4a8a:	0f c0       	rjmp	.+30     	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a8e:	82 30       	cpi	r24, 0x02	; 2
    4a90:	59 f0       	breq	.+22     	; 0x4aa8 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4a92:	ec 81       	ldd	r30, Y+4	; 0x04
    4a94:	fd 81       	ldd	r31, Y+5	; 0x05
    4a96:	88 85       	ldd	r24, Y+8	; 0x08
    4a98:	99 85       	ldd	r25, Y+9	; 0x09
    4a9a:	aa 85       	ldd	r26, Y+10	; 0x0a
    4a9c:	bb 85       	ldd	r27, Y+11	; 0x0b
    4a9e:	85 a3       	std	Z+37, r24	; 0x25
    4aa0:	96 a3       	std	Z+38, r25	; 0x26
    4aa2:	a7 a3       	std	Z+39, r26	; 0x27
    4aa4:	b0 a7       	std	Z+40, r27	; 0x28
    4aa6:	01 c0       	rjmp	.+2      	; 0x4aaa <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4aa8:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4aac:	81 30       	cpi	r24, 0x01	; 1
    4aae:	09 f0       	breq	.+2      	; 0x4ab2 <xTaskGenericNotifyFromISR+0x136>
    4ab0:	4f c0       	rjmp	.+158    	; 0x4b50 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ab2:	80 91 56 06 	lds	r24, 0x0656
    4ab6:	88 23       	and	r24, r24
    4ab8:	61 f5       	brne	.+88     	; 0x4b12 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4aba:	8c 81       	ldd	r24, Y+4	; 0x04
    4abc:	9d 81       	ldd	r25, Y+5	; 0x05
    4abe:	02 96       	adiw	r24, 0x02	; 2
    4ac0:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4ac4:	ec 81       	ldd	r30, Y+4	; 0x04
    4ac6:	fd 81       	ldd	r31, Y+5	; 0x05
    4ac8:	96 89       	ldd	r25, Z+22	; 0x16
    4aca:	80 91 4c 06 	lds	r24, 0x064C
    4ace:	89 17       	cp	r24, r25
    4ad0:	28 f4       	brcc	.+10     	; 0x4adc <xTaskGenericNotifyFromISR+0x160>
    4ad2:	ec 81       	ldd	r30, Y+4	; 0x04
    4ad4:	fd 81       	ldd	r31, Y+5	; 0x05
    4ad6:	86 89       	ldd	r24, Z+22	; 0x16
    4ad8:	80 93 4c 06 	sts	0x064C, r24
    4adc:	ec 81       	ldd	r30, Y+4	; 0x04
    4ade:	fd 81       	ldd	r31, Y+5	; 0x05
    4ae0:	86 89       	ldd	r24, Z+22	; 0x16
    4ae2:	28 2f       	mov	r18, r24
    4ae4:	30 e0       	ldi	r19, 0x00	; 0
    4ae6:	c9 01       	movw	r24, r18
    4ae8:	88 0f       	add	r24, r24
    4aea:	99 1f       	adc	r25, r25
    4aec:	88 0f       	add	r24, r24
    4aee:	99 1f       	adc	r25, r25
    4af0:	88 0f       	add	r24, r24
    4af2:	99 1f       	adc	r25, r25
    4af4:	82 0f       	add	r24, r18
    4af6:	93 1f       	adc	r25, r19
    4af8:	ac 01       	movw	r20, r24
    4afa:	49 5a       	subi	r20, 0xA9	; 169
    4afc:	59 4f       	sbci	r21, 0xF9	; 249
    4afe:	8c 81       	ldd	r24, Y+4	; 0x04
    4b00:	9d 81       	ldd	r25, Y+5	; 0x05
    4b02:	9c 01       	movw	r18, r24
    4b04:	2e 5f       	subi	r18, 0xFE	; 254
    4b06:	3f 4f       	sbci	r19, 0xFF	; 255
    4b08:	ca 01       	movw	r24, r20
    4b0a:	b9 01       	movw	r22, r18
    4b0c:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4b10:	0a c0       	rjmp	.+20     	; 0x4b26 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4b12:	8c 81       	ldd	r24, Y+4	; 0x04
    4b14:	9d 81       	ldd	r25, Y+5	; 0x05
    4b16:	9c 01       	movw	r18, r24
    4b18:	24 5f       	subi	r18, 0xF4	; 244
    4b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4b1c:	81 e9       	ldi	r24, 0x91	; 145
    4b1e:	96 e0       	ldi	r25, 0x06	; 6
    4b20:	b9 01       	movw	r22, r18
    4b22:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b26:	ec 81       	ldd	r30, Y+4	; 0x04
    4b28:	fd 81       	ldd	r31, Y+5	; 0x05
    4b2a:	96 89       	ldd	r25, Z+22	; 0x16
    4b2c:	e0 91 46 06 	lds	r30, 0x0646
    4b30:	f0 91 47 06 	lds	r31, 0x0647
    4b34:	86 89       	ldd	r24, Z+22	; 0x16
    4b36:	89 17       	cp	r24, r25
    4b38:	58 f4       	brcc	.+22     	; 0x4b50 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4b3a:	8f 85       	ldd	r24, Y+15	; 0x0f
    4b3c:	98 89       	ldd	r25, Y+16	; 0x10
    4b3e:	00 97       	sbiw	r24, 0x00	; 0
    4b40:	21 f0       	breq	.+8      	; 0x4b4a <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4b42:	ef 85       	ldd	r30, Y+15	; 0x0f
    4b44:	f8 89       	ldd	r31, Y+16	; 0x10
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4b4a:	81 e0       	ldi	r24, 0x01	; 1
    4b4c:	80 93 4f 06 	sts	0x064F, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4b50:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4b52:	62 96       	adiw	r28, 0x12	; 18
    4b54:	0f b6       	in	r0, 0x3f	; 63
    4b56:	f8 94       	cli
    4b58:	de bf       	out	0x3e, r29	; 62
    4b5a:	0f be       	out	0x3f, r0	; 63
    4b5c:	cd bf       	out	0x3d, r28	; 61
    4b5e:	cf 91       	pop	r28
    4b60:	df 91       	pop	r29
    4b62:	1f 91       	pop	r17
    4b64:	0f 91       	pop	r16
    4b66:	ff 90       	pop	r15
    4b68:	ef 90       	pop	r14
    4b6a:	08 95       	ret

00004b6c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4b6c:	df 93       	push	r29
    4b6e:	cf 93       	push	r28
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
    4b74:	28 97       	sbiw	r28, 0x08	; 8
    4b76:	0f b6       	in	r0, 0x3f	; 63
    4b78:	f8 94       	cli
    4b7a:	de bf       	out	0x3e, r29	; 62
    4b7c:	0f be       	out	0x3f, r0	; 63
    4b7e:	cd bf       	out	0x3d, r28	; 61
    4b80:	9e 83       	std	Y+6, r25	; 0x06
    4b82:	8d 83       	std	Y+5, r24	; 0x05
    4b84:	78 87       	std	Y+8, r23	; 0x08
    4b86:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4b88:	8d 81       	ldd	r24, Y+5	; 0x05
    4b8a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b8c:	9c 83       	std	Y+4, r25	; 0x04
    4b8e:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4b90:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4b92:	eb 81       	ldd	r30, Y+3	; 0x03
    4b94:	fc 81       	ldd	r31, Y+4	; 0x04
    4b96:	81 a5       	ldd	r24, Z+41	; 0x29
    4b98:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    4b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    4b9e:	82 e0       	ldi	r24, 0x02	; 2
    4ba0:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4ba2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ba4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ba6:	85 a1       	ldd	r24, Z+37	; 0x25
    4ba8:	96 a1       	ldd	r25, Z+38	; 0x26
    4baa:	a7 a1       	ldd	r26, Z+39	; 0x27
    4bac:	b0 a5       	ldd	r27, Z+40	; 0x28
    4bae:	01 96       	adiw	r24, 0x01	; 1
    4bb0:	a1 1d       	adc	r26, r1
    4bb2:	b1 1d       	adc	r27, r1
    4bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    4bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    4bb8:	85 a3       	std	Z+37, r24	; 0x25
    4bba:	96 a3       	std	Z+38, r25	; 0x26
    4bbc:	a7 a3       	std	Z+39, r26	; 0x27
    4bbe:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4bc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4bc2:	81 30       	cpi	r24, 0x01	; 1
    4bc4:	09 f0       	breq	.+2      	; 0x4bc8 <vTaskNotifyGiveFromISR+0x5c>
    4bc6:	4f c0       	rjmp	.+158    	; 0x4c66 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4bc8:	80 91 56 06 	lds	r24, 0x0656
    4bcc:	88 23       	and	r24, r24
    4bce:	61 f5       	brne	.+88     	; 0x4c28 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd4:	02 96       	adiw	r24, 0x02	; 2
    4bd6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4bda:	eb 81       	ldd	r30, Y+3	; 0x03
    4bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    4bde:	96 89       	ldd	r25, Z+22	; 0x16
    4be0:	80 91 4c 06 	lds	r24, 0x064C
    4be4:	89 17       	cp	r24, r25
    4be6:	28 f4       	brcc	.+10     	; 0x4bf2 <vTaskNotifyGiveFromISR+0x86>
    4be8:	eb 81       	ldd	r30, Y+3	; 0x03
    4bea:	fc 81       	ldd	r31, Y+4	; 0x04
    4bec:	86 89       	ldd	r24, Z+22	; 0x16
    4bee:	80 93 4c 06 	sts	0x064C, r24
    4bf2:	eb 81       	ldd	r30, Y+3	; 0x03
    4bf4:	fc 81       	ldd	r31, Y+4	; 0x04
    4bf6:	86 89       	ldd	r24, Z+22	; 0x16
    4bf8:	28 2f       	mov	r18, r24
    4bfa:	30 e0       	ldi	r19, 0x00	; 0
    4bfc:	c9 01       	movw	r24, r18
    4bfe:	88 0f       	add	r24, r24
    4c00:	99 1f       	adc	r25, r25
    4c02:	88 0f       	add	r24, r24
    4c04:	99 1f       	adc	r25, r25
    4c06:	88 0f       	add	r24, r24
    4c08:	99 1f       	adc	r25, r25
    4c0a:	82 0f       	add	r24, r18
    4c0c:	93 1f       	adc	r25, r19
    4c0e:	ac 01       	movw	r20, r24
    4c10:	49 5a       	subi	r20, 0xA9	; 169
    4c12:	59 4f       	sbci	r21, 0xF9	; 249
    4c14:	8b 81       	ldd	r24, Y+3	; 0x03
    4c16:	9c 81       	ldd	r25, Y+4	; 0x04
    4c18:	9c 01       	movw	r18, r24
    4c1a:	2e 5f       	subi	r18, 0xFE	; 254
    4c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    4c1e:	ca 01       	movw	r24, r20
    4c20:	b9 01       	movw	r22, r18
    4c22:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4c26:	0a c0       	rjmp	.+20     	; 0x4c3c <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4c28:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c2c:	9c 01       	movw	r18, r24
    4c2e:	24 5f       	subi	r18, 0xF4	; 244
    4c30:	3f 4f       	sbci	r19, 0xFF	; 255
    4c32:	81 e9       	ldi	r24, 0x91	; 145
    4c34:	96 e0       	ldi	r25, 0x06	; 6
    4c36:	b9 01       	movw	r22, r18
    4c38:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c40:	96 89       	ldd	r25, Z+22	; 0x16
    4c42:	e0 91 46 06 	lds	r30, 0x0646
    4c46:	f0 91 47 06 	lds	r31, 0x0647
    4c4a:	86 89       	ldd	r24, Z+22	; 0x16
    4c4c:	89 17       	cp	r24, r25
    4c4e:	58 f4       	brcc	.+22     	; 0x4c66 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4c50:	8f 81       	ldd	r24, Y+7	; 0x07
    4c52:	98 85       	ldd	r25, Y+8	; 0x08
    4c54:	00 97       	sbiw	r24, 0x00	; 0
    4c56:	21 f0       	breq	.+8      	; 0x4c60 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4c58:	ef 81       	ldd	r30, Y+7	; 0x07
    4c5a:	f8 85       	ldd	r31, Y+8	; 0x08
    4c5c:	81 e0       	ldi	r24, 0x01	; 1
    4c5e:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	80 93 4f 06 	sts	0x064F, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4c66:	28 96       	adiw	r28, 0x08	; 8
    4c68:	0f b6       	in	r0, 0x3f	; 63
    4c6a:	f8 94       	cli
    4c6c:	de bf       	out	0x3e, r29	; 62
    4c6e:	0f be       	out	0x3f, r0	; 63
    4c70:	cd bf       	out	0x3d, r28	; 61
    4c72:	cf 91       	pop	r28
    4c74:	df 91       	pop	r29
    4c76:	08 95       	ret

00004c78 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4c78:	df 93       	push	r29
    4c7a:	cf 93       	push	r28
    4c7c:	cd b7       	in	r28, 0x3d	; 61
    4c7e:	de b7       	in	r29, 0x3e	; 62
    4c80:	27 97       	sbiw	r28, 0x07	; 7
    4c82:	0f b6       	in	r0, 0x3f	; 63
    4c84:	f8 94       	cli
    4c86:	de bf       	out	0x3e, r29	; 62
    4c88:	0f be       	out	0x3f, r0	; 63
    4c8a:	cd bf       	out	0x3d, r28	; 61
    4c8c:	9d 83       	std	Y+5, r25	; 0x05
    4c8e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4c90:	8c 81       	ldd	r24, Y+4	; 0x04
    4c92:	9d 81       	ldd	r25, Y+5	; 0x05
    4c94:	00 97       	sbiw	r24, 0x00	; 0
    4c96:	39 f4       	brne	.+14     	; 0x4ca6 <xTaskNotifyStateClear+0x2e>
    4c98:	80 91 46 06 	lds	r24, 0x0646
    4c9c:	90 91 47 06 	lds	r25, 0x0647
    4ca0:	9f 83       	std	Y+7, r25	; 0x07
    4ca2:	8e 83       	std	Y+6, r24	; 0x06
    4ca4:	04 c0       	rjmp	.+8      	; 0x4cae <xTaskNotifyStateClear+0x36>
    4ca6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ca8:	9d 81       	ldd	r25, Y+5	; 0x05
    4caa:	9f 83       	std	Y+7, r25	; 0x07
    4cac:	8e 83       	std	Y+6, r24	; 0x06
    4cae:	8e 81       	ldd	r24, Y+6	; 0x06
    4cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    4cb2:	9b 83       	std	Y+3, r25	; 0x03
    4cb4:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4cb6:	0f b6       	in	r0, 0x3f	; 63
    4cb8:	f8 94       	cli
    4cba:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4cbc:	ea 81       	ldd	r30, Y+2	; 0x02
    4cbe:	fb 81       	ldd	r31, Y+3	; 0x03
    4cc0:	81 a5       	ldd	r24, Z+41	; 0x29
    4cc2:	82 30       	cpi	r24, 0x02	; 2
    4cc4:	31 f4       	brne	.+12     	; 0x4cd2 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cc6:	ea 81       	ldd	r30, Y+2	; 0x02
    4cc8:	fb 81       	ldd	r31, Y+3	; 0x03
    4cca:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    4ccc:	81 e0       	ldi	r24, 0x01	; 1
    4cce:	89 83       	std	Y+1, r24	; 0x01
    4cd0:	01 c0       	rjmp	.+2      	; 0x4cd4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    4cd2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4cd4:	0f 90       	pop	r0
    4cd6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4cda:	27 96       	adiw	r28, 0x07	; 7
    4cdc:	0f b6       	in	r0, 0x3f	; 63
    4cde:	f8 94       	cli
    4ce0:	de bf       	out	0x3e, r29	; 62
    4ce2:	0f be       	out	0x3f, r0	; 63
    4ce4:	cd bf       	out	0x3d, r28	; 61
    4ce6:	cf 91       	pop	r28
    4ce8:	df 91       	pop	r29
    4cea:	08 95       	ret

00004cec <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4cec:	df 93       	push	r29
    4cee:	cf 93       	push	r28
    4cf0:	cd b7       	in	r28, 0x3d	; 61
    4cf2:	de b7       	in	r29, 0x3e	; 62
    4cf4:	27 97       	sbiw	r28, 0x07	; 7
    4cf6:	0f b6       	in	r0, 0x3f	; 63
    4cf8:	f8 94       	cli
    4cfa:	de bf       	out	0x3e, r29	; 62
    4cfc:	0f be       	out	0x3f, r0	; 63
    4cfe:	cd bf       	out	0x3d, r28	; 61
    4d00:	9e 83       	std	Y+6, r25	; 0x06
    4d02:	8d 83       	std	Y+5, r24	; 0x05
    4d04:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4d06:	80 91 4a 06 	lds	r24, 0x064A
    4d0a:	90 91 4b 06 	lds	r25, 0x064B
    4d0e:	9a 83       	std	Y+2, r25	; 0x02
    4d10:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4d12:	80 91 46 06 	lds	r24, 0x0646
    4d16:	90 91 47 06 	lds	r25, 0x0647
    4d1a:	02 96       	adiw	r24, 0x02	; 2
    4d1c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4d20:	8d 81       	ldd	r24, Y+5	; 0x05
    4d22:	9e 81       	ldd	r25, Y+6	; 0x06
    4d24:	2f ef       	ldi	r18, 0xFF	; 255
    4d26:	8f 3f       	cpi	r24, 0xFF	; 255
    4d28:	92 07       	cpc	r25, r18
    4d2a:	81 f4       	brne	.+32     	; 0x4d4c <prvAddCurrentTaskToDelayedList+0x60>
    4d2c:	8f 81       	ldd	r24, Y+7	; 0x07
    4d2e:	88 23       	and	r24, r24
    4d30:	69 f0       	breq	.+26     	; 0x4d4c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4d32:	80 91 46 06 	lds	r24, 0x0646
    4d36:	90 91 47 06 	lds	r25, 0x0647
    4d3a:	9c 01       	movw	r18, r24
    4d3c:	2e 5f       	subi	r18, 0xFE	; 254
    4d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d40:	83 ea       	ldi	r24, 0xA3	; 163
    4d42:	96 e0       	ldi	r25, 0x06	; 6
    4d44:	b9 01       	movw	r22, r18
    4d46:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4d4a:	43 c0       	rjmp	.+134    	; 0x4dd2 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    4d4c:	29 81       	ldd	r18, Y+1	; 0x01
    4d4e:	3a 81       	ldd	r19, Y+2	; 0x02
    4d50:	8d 81       	ldd	r24, Y+5	; 0x05
    4d52:	9e 81       	ldd	r25, Y+6	; 0x06
    4d54:	82 0f       	add	r24, r18
    4d56:	93 1f       	adc	r25, r19
    4d58:	9c 83       	std	Y+4, r25	; 0x04
    4d5a:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4d5c:	e0 91 46 06 	lds	r30, 0x0646
    4d60:	f0 91 47 06 	lds	r31, 0x0647
    4d64:	8b 81       	ldd	r24, Y+3	; 0x03
    4d66:	9c 81       	ldd	r25, Y+4	; 0x04
    4d68:	93 83       	std	Z+3, r25	; 0x03
    4d6a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4d6c:	2b 81       	ldd	r18, Y+3	; 0x03
    4d6e:	3c 81       	ldd	r19, Y+4	; 0x04
    4d70:	89 81       	ldd	r24, Y+1	; 0x01
    4d72:	9a 81       	ldd	r25, Y+2	; 0x02
    4d74:	28 17       	cp	r18, r24
    4d76:	39 07       	cpc	r19, r25
    4d78:	70 f4       	brcc	.+28     	; 0x4d96 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4d7a:	80 91 8f 06 	lds	r24, 0x068F
    4d7e:	90 91 90 06 	lds	r25, 0x0690
    4d82:	20 91 46 06 	lds	r18, 0x0646
    4d86:	30 91 47 06 	lds	r19, 0x0647
    4d8a:	2e 5f       	subi	r18, 0xFE	; 254
    4d8c:	3f 4f       	sbci	r19, 0xFF	; 255
    4d8e:	b9 01       	movw	r22, r18
    4d90:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>
    4d94:	1e c0       	rjmp	.+60     	; 0x4dd2 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4d96:	40 91 8d 06 	lds	r20, 0x068D
    4d9a:	50 91 8e 06 	lds	r21, 0x068E
    4d9e:	80 91 46 06 	lds	r24, 0x0646
    4da2:	90 91 47 06 	lds	r25, 0x0647
    4da6:	9c 01       	movw	r18, r24
    4da8:	2e 5f       	subi	r18, 0xFE	; 254
    4daa:	3f 4f       	sbci	r19, 0xFF	; 255
    4dac:	ca 01       	movw	r24, r20
    4dae:	b9 01       	movw	r22, r18
    4db0:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4db4:	20 91 52 06 	lds	r18, 0x0652
    4db8:	30 91 53 06 	lds	r19, 0x0653
    4dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    4dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    4dc0:	82 17       	cp	r24, r18
    4dc2:	93 07       	cpc	r25, r19
    4dc4:	30 f4       	brcc	.+12     	; 0x4dd2 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    4dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    4dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dca:	90 93 53 06 	sts	0x0653, r25
    4dce:	80 93 52 06 	sts	0x0652, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4dd2:	27 96       	adiw	r28, 0x07	; 7
    4dd4:	0f b6       	in	r0, 0x3f	; 63
    4dd6:	f8 94       	cli
    4dd8:	de bf       	out	0x3e, r29	; 62
    4dda:	0f be       	out	0x3f, r0	; 63
    4ddc:	cd bf       	out	0x3d, r28	; 61
    4dde:	cf 91       	pop	r28
    4de0:	df 91       	pop	r29
    4de2:	08 95       	ret

00004de4 <DIO_VidSetPinValue>:
#include"lib/STD_TYPES.h"
#include"lib/BIT_MATH.h"
#include"DIO_private.h"
#include "DIO_interface.h"

void DIO_VidSetPinValue(u8 copy_u8port , u8 Copy_u8PinNumber , u8 Copy_u8Value){
    4de4:	df 93       	push	r29
    4de6:	cf 93       	push	r28
    4de8:	cd b7       	in	r28, 0x3d	; 61
    4dea:	de b7       	in	r29, 0x3e	; 62
    4dec:	27 97       	sbiw	r28, 0x07	; 7
    4dee:	0f b6       	in	r0, 0x3f	; 63
    4df0:	f8 94       	cli
    4df2:	de bf       	out	0x3e, r29	; 62
    4df4:	0f be       	out	0x3f, r0	; 63
    4df6:	cd bf       	out	0x3d, r28	; 61
    4df8:	89 83       	std	Y+1, r24	; 0x01
    4dfa:	6a 83       	std	Y+2, r22	; 0x02
    4dfc:	4b 83       	std	Y+3, r20	; 0x03
	if (Copy_u8Value == high){
    4dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    4e00:	81 30       	cpi	r24, 0x01	; 1
    4e02:	09 f0       	breq	.+2      	; 0x4e06 <DIO_VidSetPinValue+0x22>
    4e04:	70 c0       	rjmp	.+224    	; 0x4ee6 <DIO_VidSetPinValue+0x102>
		switch (copy_u8port)
    4e06:	89 81       	ldd	r24, Y+1	; 0x01
    4e08:	28 2f       	mov	r18, r24
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	3f 83       	std	Y+7, r19	; 0x07
    4e0e:	2e 83       	std	Y+6, r18	; 0x06
    4e10:	8e 81       	ldd	r24, Y+6	; 0x06
    4e12:	9f 81       	ldd	r25, Y+7	; 0x07
    4e14:	83 30       	cpi	r24, 0x03	; 3
    4e16:	91 05       	cpc	r25, r1
    4e18:	51 f1       	breq	.+84     	; 0x4e6e <DIO_VidSetPinValue+0x8a>
    4e1a:	2e 81       	ldd	r18, Y+6	; 0x06
    4e1c:	3f 81       	ldd	r19, Y+7	; 0x07
    4e1e:	24 30       	cpi	r18, 0x04	; 4
    4e20:	31 05       	cpc	r19, r1
    4e22:	34 f4       	brge	.+12     	; 0x4e30 <DIO_VidSetPinValue+0x4c>
    4e24:	8e 81       	ldd	r24, Y+6	; 0x06
    4e26:	9f 81       	ldd	r25, Y+7	; 0x07
    4e28:	82 30       	cpi	r24, 0x02	; 2
    4e2a:	91 05       	cpc	r25, r1
    4e2c:	61 f0       	breq	.+24     	; 0x4e46 <DIO_VidSetPinValue+0x62>
    4e2e:	d3 c0       	rjmp	.+422    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
    4e30:	2e 81       	ldd	r18, Y+6	; 0x06
    4e32:	3f 81       	ldd	r19, Y+7	; 0x07
    4e34:	24 30       	cpi	r18, 0x04	; 4
    4e36:	31 05       	cpc	r19, r1
    4e38:	71 f1       	breq	.+92     	; 0x4e96 <DIO_VidSetPinValue+0xb2>
    4e3a:	8e 81       	ldd	r24, Y+6	; 0x06
    4e3c:	9f 81       	ldd	r25, Y+7	; 0x07
    4e3e:	85 30       	cpi	r24, 0x05	; 5
    4e40:	91 05       	cpc	r25, r1
    4e42:	e9 f1       	breq	.+122    	; 0x4ebe <DIO_VidSetPinValue+0xda>
    4e44:	c8 c0       	rjmp	.+400    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
				{
				case(Port_A) :SET_BIT(PORTA,Copy_u8PinNumber);break;
    4e46:	ab e3       	ldi	r26, 0x3B	; 59
    4e48:	b0 e0       	ldi	r27, 0x00	; 0
    4e4a:	eb e3       	ldi	r30, 0x3B	; 59
    4e4c:	f0 e0       	ldi	r31, 0x00	; 0
    4e4e:	80 81       	ld	r24, Z
    4e50:	48 2f       	mov	r20, r24
    4e52:	8a 81       	ldd	r24, Y+2	; 0x02
    4e54:	28 2f       	mov	r18, r24
    4e56:	30 e0       	ldi	r19, 0x00	; 0
    4e58:	81 e0       	ldi	r24, 0x01	; 1
    4e5a:	90 e0       	ldi	r25, 0x00	; 0
    4e5c:	02 2e       	mov	r0, r18
    4e5e:	02 c0       	rjmp	.+4      	; 0x4e64 <DIO_VidSetPinValue+0x80>
    4e60:	88 0f       	add	r24, r24
    4e62:	99 1f       	adc	r25, r25
    4e64:	0a 94       	dec	r0
    4e66:	e2 f7       	brpl	.-8      	; 0x4e60 <DIO_VidSetPinValue+0x7c>
    4e68:	84 2b       	or	r24, r20
    4e6a:	8c 93       	st	X, r24
    4e6c:	b4 c0       	rjmp	.+360    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
				case(Port_B) :SET_BIT(PORTB,Copy_u8PinNumber);break;
    4e6e:	a8 e3       	ldi	r26, 0x38	; 56
    4e70:	b0 e0       	ldi	r27, 0x00	; 0
    4e72:	e8 e3       	ldi	r30, 0x38	; 56
    4e74:	f0 e0       	ldi	r31, 0x00	; 0
    4e76:	80 81       	ld	r24, Z
    4e78:	48 2f       	mov	r20, r24
    4e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7c:	28 2f       	mov	r18, r24
    4e7e:	30 e0       	ldi	r19, 0x00	; 0
    4e80:	81 e0       	ldi	r24, 0x01	; 1
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	02 2e       	mov	r0, r18
    4e86:	02 c0       	rjmp	.+4      	; 0x4e8c <DIO_VidSetPinValue+0xa8>
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	0a 94       	dec	r0
    4e8e:	e2 f7       	brpl	.-8      	; 0x4e88 <DIO_VidSetPinValue+0xa4>
    4e90:	84 2b       	or	r24, r20
    4e92:	8c 93       	st	X, r24
    4e94:	a0 c0       	rjmp	.+320    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
				case(Port_C) :SET_BIT(PORTC,Copy_u8PinNumber);break;
    4e96:	a5 e3       	ldi	r26, 0x35	; 53
    4e98:	b0 e0       	ldi	r27, 0x00	; 0
    4e9a:	e5 e3       	ldi	r30, 0x35	; 53
    4e9c:	f0 e0       	ldi	r31, 0x00	; 0
    4e9e:	80 81       	ld	r24, Z
    4ea0:	48 2f       	mov	r20, r24
    4ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea4:	28 2f       	mov	r18, r24
    4ea6:	30 e0       	ldi	r19, 0x00	; 0
    4ea8:	81 e0       	ldi	r24, 0x01	; 1
    4eaa:	90 e0       	ldi	r25, 0x00	; 0
    4eac:	02 2e       	mov	r0, r18
    4eae:	02 c0       	rjmp	.+4      	; 0x4eb4 <DIO_VidSetPinValue+0xd0>
    4eb0:	88 0f       	add	r24, r24
    4eb2:	99 1f       	adc	r25, r25
    4eb4:	0a 94       	dec	r0
    4eb6:	e2 f7       	brpl	.-8      	; 0x4eb0 <DIO_VidSetPinValue+0xcc>
    4eb8:	84 2b       	or	r24, r20
    4eba:	8c 93       	st	X, r24
    4ebc:	8c c0       	rjmp	.+280    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
				case(Port_D) :SET_BIT(PORTD,Copy_u8PinNumber);break;
    4ebe:	a2 e3       	ldi	r26, 0x32	; 50
    4ec0:	b0 e0       	ldi	r27, 0x00	; 0
    4ec2:	e2 e3       	ldi	r30, 0x32	; 50
    4ec4:	f0 e0       	ldi	r31, 0x00	; 0
    4ec6:	80 81       	ld	r24, Z
    4ec8:	48 2f       	mov	r20, r24
    4eca:	8a 81       	ldd	r24, Y+2	; 0x02
    4ecc:	28 2f       	mov	r18, r24
    4ece:	30 e0       	ldi	r19, 0x00	; 0
    4ed0:	81 e0       	ldi	r24, 0x01	; 1
    4ed2:	90 e0       	ldi	r25, 0x00	; 0
    4ed4:	02 2e       	mov	r0, r18
    4ed6:	02 c0       	rjmp	.+4      	; 0x4edc <DIO_VidSetPinValue+0xf8>
    4ed8:	88 0f       	add	r24, r24
    4eda:	99 1f       	adc	r25, r25
    4edc:	0a 94       	dec	r0
    4ede:	e2 f7       	brpl	.-8      	; 0x4ed8 <DIO_VidSetPinValue+0xf4>
    4ee0:	84 2b       	or	r24, r20
    4ee2:	8c 93       	st	X, r24
    4ee4:	78 c0       	rjmp	.+240    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
				}
	}
	else if(Copy_u8Value == low){
    4ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ee8:	88 23       	and	r24, r24
    4eea:	09 f0       	breq	.+2      	; 0x4eee <DIO_VidSetPinValue+0x10a>
    4eec:	74 c0       	rjmp	.+232    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
		switch (copy_u8port)
    4eee:	89 81       	ldd	r24, Y+1	; 0x01
    4ef0:	28 2f       	mov	r18, r24
    4ef2:	30 e0       	ldi	r19, 0x00	; 0
    4ef4:	3d 83       	std	Y+5, r19	; 0x05
    4ef6:	2c 83       	std	Y+4, r18	; 0x04
    4ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    4efa:	9d 81       	ldd	r25, Y+5	; 0x05
    4efc:	83 30       	cpi	r24, 0x03	; 3
    4efe:	91 05       	cpc	r25, r1
    4f00:	61 f1       	breq	.+88     	; 0x4f5a <DIO_VidSetPinValue+0x176>
    4f02:	2c 81       	ldd	r18, Y+4	; 0x04
    4f04:	3d 81       	ldd	r19, Y+5	; 0x05
    4f06:	24 30       	cpi	r18, 0x04	; 4
    4f08:	31 05       	cpc	r19, r1
    4f0a:	34 f4       	brge	.+12     	; 0x4f18 <DIO_VidSetPinValue+0x134>
    4f0c:	8c 81       	ldd	r24, Y+4	; 0x04
    4f0e:	9d 81       	ldd	r25, Y+5	; 0x05
    4f10:	82 30       	cpi	r24, 0x02	; 2
    4f12:	91 05       	cpc	r25, r1
    4f14:	69 f0       	breq	.+26     	; 0x4f30 <DIO_VidSetPinValue+0x14c>
    4f16:	5f c0       	rjmp	.+190    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
    4f18:	2c 81       	ldd	r18, Y+4	; 0x04
    4f1a:	3d 81       	ldd	r19, Y+5	; 0x05
    4f1c:	24 30       	cpi	r18, 0x04	; 4
    4f1e:	31 05       	cpc	r19, r1
    4f20:	89 f1       	breq	.+98     	; 0x4f84 <DIO_VidSetPinValue+0x1a0>
    4f22:	8c 81       	ldd	r24, Y+4	; 0x04
    4f24:	9d 81       	ldd	r25, Y+5	; 0x05
    4f26:	85 30       	cpi	r24, 0x05	; 5
    4f28:	91 05       	cpc	r25, r1
    4f2a:	09 f4       	brne	.+2      	; 0x4f2e <DIO_VidSetPinValue+0x14a>
    4f2c:	40 c0       	rjmp	.+128    	; 0x4fae <DIO_VidSetPinValue+0x1ca>
    4f2e:	53 c0       	rjmp	.+166    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
						{
						case(Port_A) :CLEAR_BIT(PORTA,Copy_u8PinNumber);break;
    4f30:	ab e3       	ldi	r26, 0x3B	; 59
    4f32:	b0 e0       	ldi	r27, 0x00	; 0
    4f34:	eb e3       	ldi	r30, 0x3B	; 59
    4f36:	f0 e0       	ldi	r31, 0x00	; 0
    4f38:	80 81       	ld	r24, Z
    4f3a:	48 2f       	mov	r20, r24
    4f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f3e:	28 2f       	mov	r18, r24
    4f40:	30 e0       	ldi	r19, 0x00	; 0
    4f42:	81 e0       	ldi	r24, 0x01	; 1
    4f44:	90 e0       	ldi	r25, 0x00	; 0
    4f46:	02 2e       	mov	r0, r18
    4f48:	02 c0       	rjmp	.+4      	; 0x4f4e <DIO_VidSetPinValue+0x16a>
    4f4a:	88 0f       	add	r24, r24
    4f4c:	99 1f       	adc	r25, r25
    4f4e:	0a 94       	dec	r0
    4f50:	e2 f7       	brpl	.-8      	; 0x4f4a <DIO_VidSetPinValue+0x166>
    4f52:	80 95       	com	r24
    4f54:	84 23       	and	r24, r20
    4f56:	8c 93       	st	X, r24
    4f58:	3e c0       	rjmp	.+124    	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
						case(Port_B) :CLEAR_BIT(PORTB,Copy_u8PinNumber);break;
    4f5a:	a8 e3       	ldi	r26, 0x38	; 56
    4f5c:	b0 e0       	ldi	r27, 0x00	; 0
    4f5e:	e8 e3       	ldi	r30, 0x38	; 56
    4f60:	f0 e0       	ldi	r31, 0x00	; 0
    4f62:	80 81       	ld	r24, Z
    4f64:	48 2f       	mov	r20, r24
    4f66:	8a 81       	ldd	r24, Y+2	; 0x02
    4f68:	28 2f       	mov	r18, r24
    4f6a:	30 e0       	ldi	r19, 0x00	; 0
    4f6c:	81 e0       	ldi	r24, 0x01	; 1
    4f6e:	90 e0       	ldi	r25, 0x00	; 0
    4f70:	02 2e       	mov	r0, r18
    4f72:	02 c0       	rjmp	.+4      	; 0x4f78 <DIO_VidSetPinValue+0x194>
    4f74:	88 0f       	add	r24, r24
    4f76:	99 1f       	adc	r25, r25
    4f78:	0a 94       	dec	r0
    4f7a:	e2 f7       	brpl	.-8      	; 0x4f74 <DIO_VidSetPinValue+0x190>
    4f7c:	80 95       	com	r24
    4f7e:	84 23       	and	r24, r20
    4f80:	8c 93       	st	X, r24
    4f82:	29 c0       	rjmp	.+82     	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
						case(Port_C) :CLEAR_BIT(PORTC,Copy_u8PinNumber);break;
    4f84:	a5 e3       	ldi	r26, 0x35	; 53
    4f86:	b0 e0       	ldi	r27, 0x00	; 0
    4f88:	e5 e3       	ldi	r30, 0x35	; 53
    4f8a:	f0 e0       	ldi	r31, 0x00	; 0
    4f8c:	80 81       	ld	r24, Z
    4f8e:	48 2f       	mov	r20, r24
    4f90:	8a 81       	ldd	r24, Y+2	; 0x02
    4f92:	28 2f       	mov	r18, r24
    4f94:	30 e0       	ldi	r19, 0x00	; 0
    4f96:	81 e0       	ldi	r24, 0x01	; 1
    4f98:	90 e0       	ldi	r25, 0x00	; 0
    4f9a:	02 2e       	mov	r0, r18
    4f9c:	02 c0       	rjmp	.+4      	; 0x4fa2 <DIO_VidSetPinValue+0x1be>
    4f9e:	88 0f       	add	r24, r24
    4fa0:	99 1f       	adc	r25, r25
    4fa2:	0a 94       	dec	r0
    4fa4:	e2 f7       	brpl	.-8      	; 0x4f9e <DIO_VidSetPinValue+0x1ba>
    4fa6:	80 95       	com	r24
    4fa8:	84 23       	and	r24, r20
    4faa:	8c 93       	st	X, r24
    4fac:	14 c0       	rjmp	.+40     	; 0x4fd6 <DIO_VidSetPinValue+0x1f2>
						case(Port_D) :CLEAR_BIT(PORTD,Copy_u8PinNumber);break;
    4fae:	a2 e3       	ldi	r26, 0x32	; 50
    4fb0:	b0 e0       	ldi	r27, 0x00	; 0
    4fb2:	e2 e3       	ldi	r30, 0x32	; 50
    4fb4:	f0 e0       	ldi	r31, 0x00	; 0
    4fb6:	80 81       	ld	r24, Z
    4fb8:	48 2f       	mov	r20, r24
    4fba:	8a 81       	ldd	r24, Y+2	; 0x02
    4fbc:	28 2f       	mov	r18, r24
    4fbe:	30 e0       	ldi	r19, 0x00	; 0
    4fc0:	81 e0       	ldi	r24, 0x01	; 1
    4fc2:	90 e0       	ldi	r25, 0x00	; 0
    4fc4:	02 2e       	mov	r0, r18
    4fc6:	02 c0       	rjmp	.+4      	; 0x4fcc <DIO_VidSetPinValue+0x1e8>
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	0a 94       	dec	r0
    4fce:	e2 f7       	brpl	.-8      	; 0x4fc8 <DIO_VidSetPinValue+0x1e4>
    4fd0:	80 95       	com	r24
    4fd2:	84 23       	and	r24, r20
    4fd4:	8c 93       	st	X, r24
						}

	}

}
    4fd6:	27 96       	adiw	r28, 0x07	; 7
    4fd8:	0f b6       	in	r0, 0x3f	; 63
    4fda:	f8 94       	cli
    4fdc:	de bf       	out	0x3e, r29	; 62
    4fde:	0f be       	out	0x3f, r0	; 63
    4fe0:	cd bf       	out	0x3d, r28	; 61
    4fe2:	cf 91       	pop	r28
    4fe4:	df 91       	pop	r29
    4fe6:	08 95       	ret

00004fe8 <DIO_VidSetPinDirection>:
void DIO_VidSetPinDirection(u8 copy_u8port , u8 Copy_u8PinNumber , u8 Copy_u8PinDeriction)
{
    4fe8:	df 93       	push	r29
    4fea:	cf 93       	push	r28
    4fec:	cd b7       	in	r28, 0x3d	; 61
    4fee:	de b7       	in	r29, 0x3e	; 62
    4ff0:	27 97       	sbiw	r28, 0x07	; 7
    4ff2:	0f b6       	in	r0, 0x3f	; 63
    4ff4:	f8 94       	cli
    4ff6:	de bf       	out	0x3e, r29	; 62
    4ff8:	0f be       	out	0x3f, r0	; 63
    4ffa:	cd bf       	out	0x3d, r28	; 61
    4ffc:	89 83       	std	Y+1, r24	; 0x01
    4ffe:	6a 83       	std	Y+2, r22	; 0x02
    5000:	4b 83       	std	Y+3, r20	; 0x03
	if(Copy_u8PinDeriction == input )
    5002:	8b 81       	ldd	r24, Y+3	; 0x03
    5004:	88 23       	and	r24, r24
    5006:	09 f0       	breq	.+2      	; 0x500a <DIO_VidSetPinDirection+0x22>
    5008:	75 c0       	rjmp	.+234    	; 0x50f4 <DIO_VidSetPinDirection+0x10c>
	{
		switch (copy_u8port)
    500a:	89 81       	ldd	r24, Y+1	; 0x01
    500c:	28 2f       	mov	r18, r24
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	3f 83       	std	Y+7, r19	; 0x07
    5012:	2e 83       	std	Y+6, r18	; 0x06
    5014:	8e 81       	ldd	r24, Y+6	; 0x06
    5016:	9f 81       	ldd	r25, Y+7	; 0x07
    5018:	83 30       	cpi	r24, 0x03	; 3
    501a:	91 05       	cpc	r25, r1
    501c:	61 f1       	breq	.+88     	; 0x5076 <DIO_VidSetPinDirection+0x8e>
    501e:	2e 81       	ldd	r18, Y+6	; 0x06
    5020:	3f 81       	ldd	r19, Y+7	; 0x07
    5022:	24 30       	cpi	r18, 0x04	; 4
    5024:	31 05       	cpc	r19, r1
    5026:	34 f4       	brge	.+12     	; 0x5034 <DIO_VidSetPinDirection+0x4c>
    5028:	8e 81       	ldd	r24, Y+6	; 0x06
    502a:	9f 81       	ldd	r25, Y+7	; 0x07
    502c:	82 30       	cpi	r24, 0x02	; 2
    502e:	91 05       	cpc	r25, r1
    5030:	69 f0       	breq	.+26     	; 0x504c <DIO_VidSetPinDirection+0x64>
    5032:	d3 c0       	rjmp	.+422    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
    5034:	2e 81       	ldd	r18, Y+6	; 0x06
    5036:	3f 81       	ldd	r19, Y+7	; 0x07
    5038:	24 30       	cpi	r18, 0x04	; 4
    503a:	31 05       	cpc	r19, r1
    503c:	89 f1       	breq	.+98     	; 0x50a0 <DIO_VidSetPinDirection+0xb8>
    503e:	8e 81       	ldd	r24, Y+6	; 0x06
    5040:	9f 81       	ldd	r25, Y+7	; 0x07
    5042:	85 30       	cpi	r24, 0x05	; 5
    5044:	91 05       	cpc	r25, r1
    5046:	09 f4       	brne	.+2      	; 0x504a <DIO_VidSetPinDirection+0x62>
    5048:	40 c0       	rjmp	.+128    	; 0x50ca <DIO_VidSetPinDirection+0xe2>
    504a:	c7 c0       	rjmp	.+398    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
		{
		case(Port_A) :CLEAR_BIT(DDRA,Copy_u8PinNumber);break;
    504c:	aa e3       	ldi	r26, 0x3A	; 58
    504e:	b0 e0       	ldi	r27, 0x00	; 0
    5050:	ea e3       	ldi	r30, 0x3A	; 58
    5052:	f0 e0       	ldi	r31, 0x00	; 0
    5054:	80 81       	ld	r24, Z
    5056:	48 2f       	mov	r20, r24
    5058:	8a 81       	ldd	r24, Y+2	; 0x02
    505a:	28 2f       	mov	r18, r24
    505c:	30 e0       	ldi	r19, 0x00	; 0
    505e:	81 e0       	ldi	r24, 0x01	; 1
    5060:	90 e0       	ldi	r25, 0x00	; 0
    5062:	02 2e       	mov	r0, r18
    5064:	02 c0       	rjmp	.+4      	; 0x506a <DIO_VidSetPinDirection+0x82>
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	0a 94       	dec	r0
    506c:	e2 f7       	brpl	.-8      	; 0x5066 <DIO_VidSetPinDirection+0x7e>
    506e:	80 95       	com	r24
    5070:	84 23       	and	r24, r20
    5072:	8c 93       	st	X, r24
    5074:	b2 c0       	rjmp	.+356    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
		case(Port_B) :CLEAR_BIT(DDRB,Copy_u8PinNumber);break;
    5076:	a7 e3       	ldi	r26, 0x37	; 55
    5078:	b0 e0       	ldi	r27, 0x00	; 0
    507a:	e7 e3       	ldi	r30, 0x37	; 55
    507c:	f0 e0       	ldi	r31, 0x00	; 0
    507e:	80 81       	ld	r24, Z
    5080:	48 2f       	mov	r20, r24
    5082:	8a 81       	ldd	r24, Y+2	; 0x02
    5084:	28 2f       	mov	r18, r24
    5086:	30 e0       	ldi	r19, 0x00	; 0
    5088:	81 e0       	ldi	r24, 0x01	; 1
    508a:	90 e0       	ldi	r25, 0x00	; 0
    508c:	02 2e       	mov	r0, r18
    508e:	02 c0       	rjmp	.+4      	; 0x5094 <DIO_VidSetPinDirection+0xac>
    5090:	88 0f       	add	r24, r24
    5092:	99 1f       	adc	r25, r25
    5094:	0a 94       	dec	r0
    5096:	e2 f7       	brpl	.-8      	; 0x5090 <DIO_VidSetPinDirection+0xa8>
    5098:	80 95       	com	r24
    509a:	84 23       	and	r24, r20
    509c:	8c 93       	st	X, r24
    509e:	9d c0       	rjmp	.+314    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
		case(Port_C) :CLEAR_BIT(DDRC,Copy_u8PinNumber);break;
    50a0:	a4 e3       	ldi	r26, 0x34	; 52
    50a2:	b0 e0       	ldi	r27, 0x00	; 0
    50a4:	e4 e3       	ldi	r30, 0x34	; 52
    50a6:	f0 e0       	ldi	r31, 0x00	; 0
    50a8:	80 81       	ld	r24, Z
    50aa:	48 2f       	mov	r20, r24
    50ac:	8a 81       	ldd	r24, Y+2	; 0x02
    50ae:	28 2f       	mov	r18, r24
    50b0:	30 e0       	ldi	r19, 0x00	; 0
    50b2:	81 e0       	ldi	r24, 0x01	; 1
    50b4:	90 e0       	ldi	r25, 0x00	; 0
    50b6:	02 2e       	mov	r0, r18
    50b8:	02 c0       	rjmp	.+4      	; 0x50be <DIO_VidSetPinDirection+0xd6>
    50ba:	88 0f       	add	r24, r24
    50bc:	99 1f       	adc	r25, r25
    50be:	0a 94       	dec	r0
    50c0:	e2 f7       	brpl	.-8      	; 0x50ba <DIO_VidSetPinDirection+0xd2>
    50c2:	80 95       	com	r24
    50c4:	84 23       	and	r24, r20
    50c6:	8c 93       	st	X, r24
    50c8:	88 c0       	rjmp	.+272    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
		case(Port_D) :CLEAR_BIT(DDRD,Copy_u8PinNumber);break;
    50ca:	a1 e3       	ldi	r26, 0x31	; 49
    50cc:	b0 e0       	ldi	r27, 0x00	; 0
    50ce:	e1 e3       	ldi	r30, 0x31	; 49
    50d0:	f0 e0       	ldi	r31, 0x00	; 0
    50d2:	80 81       	ld	r24, Z
    50d4:	48 2f       	mov	r20, r24
    50d6:	8a 81       	ldd	r24, Y+2	; 0x02
    50d8:	28 2f       	mov	r18, r24
    50da:	30 e0       	ldi	r19, 0x00	; 0
    50dc:	81 e0       	ldi	r24, 0x01	; 1
    50de:	90 e0       	ldi	r25, 0x00	; 0
    50e0:	02 2e       	mov	r0, r18
    50e2:	02 c0       	rjmp	.+4      	; 0x50e8 <DIO_VidSetPinDirection+0x100>
    50e4:	88 0f       	add	r24, r24
    50e6:	99 1f       	adc	r25, r25
    50e8:	0a 94       	dec	r0
    50ea:	e2 f7       	brpl	.-8      	; 0x50e4 <DIO_VidSetPinDirection+0xfc>
    50ec:	80 95       	com	r24
    50ee:	84 23       	and	r24, r20
    50f0:	8c 93       	st	X, r24
    50f2:	73 c0       	rjmp	.+230    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
		}


	}
	else if(Copy_u8PinDeriction == output )
    50f4:	8b 81       	ldd	r24, Y+3	; 0x03
    50f6:	81 30       	cpi	r24, 0x01	; 1
    50f8:	09 f0       	breq	.+2      	; 0x50fc <DIO_VidSetPinDirection+0x114>
    50fa:	6f c0       	rjmp	.+222    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
	{
		switch (copy_u8port)
    50fc:	89 81       	ldd	r24, Y+1	; 0x01
    50fe:	28 2f       	mov	r18, r24
    5100:	30 e0       	ldi	r19, 0x00	; 0
    5102:	3d 83       	std	Y+5, r19	; 0x05
    5104:	2c 83       	std	Y+4, r18	; 0x04
    5106:	8c 81       	ldd	r24, Y+4	; 0x04
    5108:	9d 81       	ldd	r25, Y+5	; 0x05
    510a:	83 30       	cpi	r24, 0x03	; 3
    510c:	91 05       	cpc	r25, r1
    510e:	51 f1       	breq	.+84     	; 0x5164 <DIO_VidSetPinDirection+0x17c>
    5110:	2c 81       	ldd	r18, Y+4	; 0x04
    5112:	3d 81       	ldd	r19, Y+5	; 0x05
    5114:	24 30       	cpi	r18, 0x04	; 4
    5116:	31 05       	cpc	r19, r1
    5118:	34 f4       	brge	.+12     	; 0x5126 <DIO_VidSetPinDirection+0x13e>
    511a:	8c 81       	ldd	r24, Y+4	; 0x04
    511c:	9d 81       	ldd	r25, Y+5	; 0x05
    511e:	82 30       	cpi	r24, 0x02	; 2
    5120:	91 05       	cpc	r25, r1
    5122:	61 f0       	breq	.+24     	; 0x513c <DIO_VidSetPinDirection+0x154>
    5124:	5a c0       	rjmp	.+180    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
    5126:	2c 81       	ldd	r18, Y+4	; 0x04
    5128:	3d 81       	ldd	r19, Y+5	; 0x05
    512a:	24 30       	cpi	r18, 0x04	; 4
    512c:	31 05       	cpc	r19, r1
    512e:	71 f1       	breq	.+92     	; 0x518c <DIO_VidSetPinDirection+0x1a4>
    5130:	8c 81       	ldd	r24, Y+4	; 0x04
    5132:	9d 81       	ldd	r25, Y+5	; 0x05
    5134:	85 30       	cpi	r24, 0x05	; 5
    5136:	91 05       	cpc	r25, r1
    5138:	e9 f1       	breq	.+122    	; 0x51b4 <DIO_VidSetPinDirection+0x1cc>
    513a:	4f c0       	rjmp	.+158    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
				{
				case(Port_A) :SET_BIT(DDRA,Copy_u8PinNumber);break;
    513c:	aa e3       	ldi	r26, 0x3A	; 58
    513e:	b0 e0       	ldi	r27, 0x00	; 0
    5140:	ea e3       	ldi	r30, 0x3A	; 58
    5142:	f0 e0       	ldi	r31, 0x00	; 0
    5144:	80 81       	ld	r24, Z
    5146:	48 2f       	mov	r20, r24
    5148:	8a 81       	ldd	r24, Y+2	; 0x02
    514a:	28 2f       	mov	r18, r24
    514c:	30 e0       	ldi	r19, 0x00	; 0
    514e:	81 e0       	ldi	r24, 0x01	; 1
    5150:	90 e0       	ldi	r25, 0x00	; 0
    5152:	02 2e       	mov	r0, r18
    5154:	02 c0       	rjmp	.+4      	; 0x515a <DIO_VidSetPinDirection+0x172>
    5156:	88 0f       	add	r24, r24
    5158:	99 1f       	adc	r25, r25
    515a:	0a 94       	dec	r0
    515c:	e2 f7       	brpl	.-8      	; 0x5156 <DIO_VidSetPinDirection+0x16e>
    515e:	84 2b       	or	r24, r20
    5160:	8c 93       	st	X, r24
    5162:	3b c0       	rjmp	.+118    	; 0x51da <DIO_VidSetPinDirection+0x1f2>
				case(Port_B) :SET_BIT(DDRB,Copy_u8PinNumber);break;
    5164:	a7 e3       	ldi	r26, 0x37	; 55
    5166:	b0 e0       	ldi	r27, 0x00	; 0
    5168:	e7 e3       	ldi	r30, 0x37	; 55
    516a:	f0 e0       	ldi	r31, 0x00	; 0
    516c:	80 81       	ld	r24, Z
    516e:	48 2f       	mov	r20, r24
    5170:	8a 81       	ldd	r24, Y+2	; 0x02
    5172:	28 2f       	mov	r18, r24
    5174:	30 e0       	ldi	r19, 0x00	; 0
    5176:	81 e0       	ldi	r24, 0x01	; 1
    5178:	90 e0       	ldi	r25, 0x00	; 0
    517a:	02 2e       	mov	r0, r18
    517c:	02 c0       	rjmp	.+4      	; 0x5182 <DIO_VidSetPinDirection+0x19a>
    517e:	88 0f       	add	r24, r24
    5180:	99 1f       	adc	r25, r25
    5182:	0a 94       	dec	r0
    5184:	e2 f7       	brpl	.-8      	; 0x517e <DIO_VidSetPinDirection+0x196>
    5186:	84 2b       	or	r24, r20
    5188:	8c 93       	st	X, r24
    518a:	27 c0       	rjmp	.+78     	; 0x51da <DIO_VidSetPinDirection+0x1f2>
				case(Port_C) :SET_BIT(DDRC,Copy_u8PinNumber);break;
    518c:	a4 e3       	ldi	r26, 0x34	; 52
    518e:	b0 e0       	ldi	r27, 0x00	; 0
    5190:	e4 e3       	ldi	r30, 0x34	; 52
    5192:	f0 e0       	ldi	r31, 0x00	; 0
    5194:	80 81       	ld	r24, Z
    5196:	48 2f       	mov	r20, r24
    5198:	8a 81       	ldd	r24, Y+2	; 0x02
    519a:	28 2f       	mov	r18, r24
    519c:	30 e0       	ldi	r19, 0x00	; 0
    519e:	81 e0       	ldi	r24, 0x01	; 1
    51a0:	90 e0       	ldi	r25, 0x00	; 0
    51a2:	02 2e       	mov	r0, r18
    51a4:	02 c0       	rjmp	.+4      	; 0x51aa <DIO_VidSetPinDirection+0x1c2>
    51a6:	88 0f       	add	r24, r24
    51a8:	99 1f       	adc	r25, r25
    51aa:	0a 94       	dec	r0
    51ac:	e2 f7       	brpl	.-8      	; 0x51a6 <DIO_VidSetPinDirection+0x1be>
    51ae:	84 2b       	or	r24, r20
    51b0:	8c 93       	st	X, r24
    51b2:	13 c0       	rjmp	.+38     	; 0x51da <DIO_VidSetPinDirection+0x1f2>
				case(Port_D) :SET_BIT(DDRD,Copy_u8PinNumber);break;
    51b4:	a1 e3       	ldi	r26, 0x31	; 49
    51b6:	b0 e0       	ldi	r27, 0x00	; 0
    51b8:	e1 e3       	ldi	r30, 0x31	; 49
    51ba:	f0 e0       	ldi	r31, 0x00	; 0
    51bc:	80 81       	ld	r24, Z
    51be:	48 2f       	mov	r20, r24
    51c0:	8a 81       	ldd	r24, Y+2	; 0x02
    51c2:	28 2f       	mov	r18, r24
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	81 e0       	ldi	r24, 0x01	; 1
    51c8:	90 e0       	ldi	r25, 0x00	; 0
    51ca:	02 2e       	mov	r0, r18
    51cc:	02 c0       	rjmp	.+4      	; 0x51d2 <DIO_VidSetPinDirection+0x1ea>
    51ce:	88 0f       	add	r24, r24
    51d0:	99 1f       	adc	r25, r25
    51d2:	0a 94       	dec	r0
    51d4:	e2 f7       	brpl	.-8      	; 0x51ce <DIO_VidSetPinDirection+0x1e6>
    51d6:	84 2b       	or	r24, r20
    51d8:	8c 93       	st	X, r24
				}
	}
}
    51da:	27 96       	adiw	r28, 0x07	; 7
    51dc:	0f b6       	in	r0, 0x3f	; 63
    51de:	f8 94       	cli
    51e0:	de bf       	out	0x3e, r29	; 62
    51e2:	0f be       	out	0x3f, r0	; 63
    51e4:	cd bf       	out	0x3d, r28	; 61
    51e6:	cf 91       	pop	r28
    51e8:	df 91       	pop	r29
    51ea:	08 95       	ret

000051ec <DIO_VidGetPinValue>:

void DIO_VidGetPinValue(u8 copy_u8port , u8 Copy_u8PinNumber,u8 *Copy_pu8PinValue){
    51ec:	df 93       	push	r29
    51ee:	cf 93       	push	r28
    51f0:	00 d0       	rcall	.+0      	; 0x51f2 <DIO_VidGetPinValue+0x6>
    51f2:	00 d0       	rcall	.+0      	; 0x51f4 <DIO_VidGetPinValue+0x8>
    51f4:	00 d0       	rcall	.+0      	; 0x51f6 <DIO_VidGetPinValue+0xa>
    51f6:	cd b7       	in	r28, 0x3d	; 61
    51f8:	de b7       	in	r29, 0x3e	; 62
    51fa:	89 83       	std	Y+1, r24	; 0x01
    51fc:	6a 83       	std	Y+2, r22	; 0x02
    51fe:	5c 83       	std	Y+4, r21	; 0x04
    5200:	4b 83       	std	Y+3, r20	; 0x03
	switch (copy_u8port)
    5202:	89 81       	ldd	r24, Y+1	; 0x01
    5204:	28 2f       	mov	r18, r24
    5206:	30 e0       	ldi	r19, 0x00	; 0
    5208:	3e 83       	std	Y+6, r19	; 0x06
    520a:	2d 83       	std	Y+5, r18	; 0x05
    520c:	4d 81       	ldd	r20, Y+5	; 0x05
    520e:	5e 81       	ldd	r21, Y+6	; 0x06
    5210:	43 30       	cpi	r20, 0x03	; 3
    5212:	51 05       	cpc	r21, r1
    5214:	59 f1       	breq	.+86     	; 0x526c <DIO_VidGetPinValue+0x80>
    5216:	8d 81       	ldd	r24, Y+5	; 0x05
    5218:	9e 81       	ldd	r25, Y+6	; 0x06
    521a:	84 30       	cpi	r24, 0x04	; 4
    521c:	91 05       	cpc	r25, r1
    521e:	34 f4       	brge	.+12     	; 0x522c <DIO_VidGetPinValue+0x40>
    5220:	2d 81       	ldd	r18, Y+5	; 0x05
    5222:	3e 81       	ldd	r19, Y+6	; 0x06
    5224:	22 30       	cpi	r18, 0x02	; 2
    5226:	31 05       	cpc	r19, r1
    5228:	69 f0       	breq	.+26     	; 0x5244 <DIO_VidGetPinValue+0x58>
    522a:	5b c0       	rjmp	.+182    	; 0x52e2 <DIO_VidGetPinValue+0xf6>
    522c:	4d 81       	ldd	r20, Y+5	; 0x05
    522e:	5e 81       	ldd	r21, Y+6	; 0x06
    5230:	44 30       	cpi	r20, 0x04	; 4
    5232:	51 05       	cpc	r21, r1
    5234:	79 f1       	breq	.+94     	; 0x5294 <DIO_VidGetPinValue+0xa8>
    5236:	8d 81       	ldd	r24, Y+5	; 0x05
    5238:	9e 81       	ldd	r25, Y+6	; 0x06
    523a:	85 30       	cpi	r24, 0x05	; 5
    523c:	91 05       	cpc	r25, r1
    523e:	09 f4       	brne	.+2      	; 0x5242 <DIO_VidGetPinValue+0x56>
    5240:	3d c0       	rjmp	.+122    	; 0x52bc <DIO_VidGetPinValue+0xd0>
    5242:	4f c0       	rjmp	.+158    	; 0x52e2 <DIO_VidGetPinValue+0xf6>
			{
			case(Port_A) :*Copy_pu8PinValue= GET_BIT(PINA,Copy_u8PinNumber);break;
    5244:	e9 e3       	ldi	r30, 0x39	; 57
    5246:	f0 e0       	ldi	r31, 0x00	; 0
    5248:	80 81       	ld	r24, Z
    524a:	28 2f       	mov	r18, r24
    524c:	30 e0       	ldi	r19, 0x00	; 0
    524e:	8a 81       	ldd	r24, Y+2	; 0x02
    5250:	88 2f       	mov	r24, r24
    5252:	90 e0       	ldi	r25, 0x00	; 0
    5254:	a9 01       	movw	r20, r18
    5256:	02 c0       	rjmp	.+4      	; 0x525c <DIO_VidGetPinValue+0x70>
    5258:	55 95       	asr	r21
    525a:	47 95       	ror	r20
    525c:	8a 95       	dec	r24
    525e:	e2 f7       	brpl	.-8      	; 0x5258 <DIO_VidGetPinValue+0x6c>
    5260:	ca 01       	movw	r24, r20
    5262:	81 70       	andi	r24, 0x01	; 1
    5264:	eb 81       	ldd	r30, Y+3	; 0x03
    5266:	fc 81       	ldd	r31, Y+4	; 0x04
    5268:	80 83       	st	Z, r24
    526a:	3b c0       	rjmp	.+118    	; 0x52e2 <DIO_VidGetPinValue+0xf6>
			case(Port_B) :*Copy_pu8PinValue= GET_BIT(PINB,Copy_u8PinNumber);break;
    526c:	e6 e3       	ldi	r30, 0x36	; 54
    526e:	f0 e0       	ldi	r31, 0x00	; 0
    5270:	80 81       	ld	r24, Z
    5272:	28 2f       	mov	r18, r24
    5274:	30 e0       	ldi	r19, 0x00	; 0
    5276:	8a 81       	ldd	r24, Y+2	; 0x02
    5278:	88 2f       	mov	r24, r24
    527a:	90 e0       	ldi	r25, 0x00	; 0
    527c:	a9 01       	movw	r20, r18
    527e:	02 c0       	rjmp	.+4      	; 0x5284 <DIO_VidGetPinValue+0x98>
    5280:	55 95       	asr	r21
    5282:	47 95       	ror	r20
    5284:	8a 95       	dec	r24
    5286:	e2 f7       	brpl	.-8      	; 0x5280 <DIO_VidGetPinValue+0x94>
    5288:	ca 01       	movw	r24, r20
    528a:	81 70       	andi	r24, 0x01	; 1
    528c:	eb 81       	ldd	r30, Y+3	; 0x03
    528e:	fc 81       	ldd	r31, Y+4	; 0x04
    5290:	80 83       	st	Z, r24
    5292:	27 c0       	rjmp	.+78     	; 0x52e2 <DIO_VidGetPinValue+0xf6>
			case(Port_C) :*Copy_pu8PinValue= GET_BIT(PINC,Copy_u8PinNumber);break;
    5294:	e3 e3       	ldi	r30, 0x33	; 51
    5296:	f0 e0       	ldi	r31, 0x00	; 0
    5298:	80 81       	ld	r24, Z
    529a:	28 2f       	mov	r18, r24
    529c:	30 e0       	ldi	r19, 0x00	; 0
    529e:	8a 81       	ldd	r24, Y+2	; 0x02
    52a0:	88 2f       	mov	r24, r24
    52a2:	90 e0       	ldi	r25, 0x00	; 0
    52a4:	a9 01       	movw	r20, r18
    52a6:	02 c0       	rjmp	.+4      	; 0x52ac <DIO_VidGetPinValue+0xc0>
    52a8:	55 95       	asr	r21
    52aa:	47 95       	ror	r20
    52ac:	8a 95       	dec	r24
    52ae:	e2 f7       	brpl	.-8      	; 0x52a8 <DIO_VidGetPinValue+0xbc>
    52b0:	ca 01       	movw	r24, r20
    52b2:	81 70       	andi	r24, 0x01	; 1
    52b4:	eb 81       	ldd	r30, Y+3	; 0x03
    52b6:	fc 81       	ldd	r31, Y+4	; 0x04
    52b8:	80 83       	st	Z, r24
    52ba:	13 c0       	rjmp	.+38     	; 0x52e2 <DIO_VidGetPinValue+0xf6>
			case(Port_D) :*Copy_pu8PinValue= GET_BIT(PIND,Copy_u8PinNumber);break;
    52bc:	e0 e3       	ldi	r30, 0x30	; 48
    52be:	f0 e0       	ldi	r31, 0x00	; 0
    52c0:	80 81       	ld	r24, Z
    52c2:	28 2f       	mov	r18, r24
    52c4:	30 e0       	ldi	r19, 0x00	; 0
    52c6:	8a 81       	ldd	r24, Y+2	; 0x02
    52c8:	88 2f       	mov	r24, r24
    52ca:	90 e0       	ldi	r25, 0x00	; 0
    52cc:	a9 01       	movw	r20, r18
    52ce:	02 c0       	rjmp	.+4      	; 0x52d4 <DIO_VidGetPinValue+0xe8>
    52d0:	55 95       	asr	r21
    52d2:	47 95       	ror	r20
    52d4:	8a 95       	dec	r24
    52d6:	e2 f7       	brpl	.-8      	; 0x52d0 <DIO_VidGetPinValue+0xe4>
    52d8:	ca 01       	movw	r24, r20
    52da:	81 70       	andi	r24, 0x01	; 1
    52dc:	eb 81       	ldd	r30, Y+3	; 0x03
    52de:	fc 81       	ldd	r31, Y+4	; 0x04
    52e0:	80 83       	st	Z, r24
			}

}
    52e2:	26 96       	adiw	r28, 0x06	; 6
    52e4:	0f b6       	in	r0, 0x3f	; 63
    52e6:	f8 94       	cli
    52e8:	de bf       	out	0x3e, r29	; 62
    52ea:	0f be       	out	0x3f, r0	; 63
    52ec:	cd bf       	out	0x3d, r28	; 61
    52ee:	cf 91       	pop	r28
    52f0:	df 91       	pop	r29
    52f2:	08 95       	ret

000052f4 <DIO_VidSetPortValue>:



/*Set_Port*/

void DIO_VidSetPortValue(u8 copy_u8port , u8 Copy_u8Value ){
    52f4:	df 93       	push	r29
    52f6:	cf 93       	push	r28
    52f8:	00 d0       	rcall	.+0      	; 0x52fa <DIO_VidSetPortValue+0x6>
    52fa:	00 d0       	rcall	.+0      	; 0x52fc <DIO_VidSetPortValue+0x8>
    52fc:	cd b7       	in	r28, 0x3d	; 61
    52fe:	de b7       	in	r29, 0x3e	; 62
    5300:	89 83       	std	Y+1, r24	; 0x01
    5302:	6a 83       	std	Y+2, r22	; 0x02

			switch (copy_u8port)
    5304:	89 81       	ldd	r24, Y+1	; 0x01
    5306:	28 2f       	mov	r18, r24
    5308:	30 e0       	ldi	r19, 0x00	; 0
    530a:	3c 83       	std	Y+4, r19	; 0x04
    530c:	2b 83       	std	Y+3, r18	; 0x03
    530e:	8b 81       	ldd	r24, Y+3	; 0x03
    5310:	9c 81       	ldd	r25, Y+4	; 0x04
    5312:	83 30       	cpi	r24, 0x03	; 3
    5314:	91 05       	cpc	r25, r1
    5316:	d9 f0       	breq	.+54     	; 0x534e <DIO_VidSetPortValue+0x5a>
    5318:	2b 81       	ldd	r18, Y+3	; 0x03
    531a:	3c 81       	ldd	r19, Y+4	; 0x04
    531c:	24 30       	cpi	r18, 0x04	; 4
    531e:	31 05       	cpc	r19, r1
    5320:	34 f4       	brge	.+12     	; 0x532e <DIO_VidSetPortValue+0x3a>
    5322:	8b 81       	ldd	r24, Y+3	; 0x03
    5324:	9c 81       	ldd	r25, Y+4	; 0x04
    5326:	82 30       	cpi	r24, 0x02	; 2
    5328:	91 05       	cpc	r25, r1
    532a:	61 f0       	breq	.+24     	; 0x5344 <DIO_VidSetPortValue+0x50>
    532c:	1e c0       	rjmp	.+60     	; 0x536a <DIO_VidSetPortValue+0x76>
    532e:	2b 81       	ldd	r18, Y+3	; 0x03
    5330:	3c 81       	ldd	r19, Y+4	; 0x04
    5332:	24 30       	cpi	r18, 0x04	; 4
    5334:	31 05       	cpc	r19, r1
    5336:	81 f0       	breq	.+32     	; 0x5358 <DIO_VidSetPortValue+0x64>
    5338:	8b 81       	ldd	r24, Y+3	; 0x03
    533a:	9c 81       	ldd	r25, Y+4	; 0x04
    533c:	85 30       	cpi	r24, 0x05	; 5
    533e:	91 05       	cpc	r25, r1
    5340:	81 f0       	breq	.+32     	; 0x5362 <DIO_VidSetPortValue+0x6e>
    5342:	13 c0       	rjmp	.+38     	; 0x536a <DIO_VidSetPortValue+0x76>
					{
					case(Port_A) :PORTA=Copy_u8Value;break;
    5344:	eb e3       	ldi	r30, 0x3B	; 59
    5346:	f0 e0       	ldi	r31, 0x00	; 0
    5348:	8a 81       	ldd	r24, Y+2	; 0x02
    534a:	80 83       	st	Z, r24
    534c:	0e c0       	rjmp	.+28     	; 0x536a <DIO_VidSetPortValue+0x76>
					case(Port_B) :PORTB=Copy_u8Value;break;
    534e:	e8 e3       	ldi	r30, 0x38	; 56
    5350:	f0 e0       	ldi	r31, 0x00	; 0
    5352:	8a 81       	ldd	r24, Y+2	; 0x02
    5354:	80 83       	st	Z, r24
    5356:	09 c0       	rjmp	.+18     	; 0x536a <DIO_VidSetPortValue+0x76>
					case(Port_C) :PORTC=Copy_u8Value;break;
    5358:	e5 e3       	ldi	r30, 0x35	; 53
    535a:	f0 e0       	ldi	r31, 0x00	; 0
    535c:	8a 81       	ldd	r24, Y+2	; 0x02
    535e:	80 83       	st	Z, r24
    5360:	04 c0       	rjmp	.+8      	; 0x536a <DIO_VidSetPortValue+0x76>
					case(Port_D) :PORTD=Copy_u8Value;break;
    5362:	e2 e3       	ldi	r30, 0x32	; 50
    5364:	f0 e0       	ldi	r31, 0x00	; 0
    5366:	8a 81       	ldd	r24, Y+2	; 0x02
    5368:	80 83       	st	Z, r24
					}

}
    536a:	0f 90       	pop	r0
    536c:	0f 90       	pop	r0
    536e:	0f 90       	pop	r0
    5370:	0f 90       	pop	r0
    5372:	cf 91       	pop	r28
    5374:	df 91       	pop	r29
    5376:	08 95       	ret

00005378 <DIO_VidSetPortDirection>:
void DIO_VidSetPortDirection(u8 copy_u8port , u8 Copy_u8PortDeriction ){
    5378:	df 93       	push	r29
    537a:	cf 93       	push	r28
    537c:	00 d0       	rcall	.+0      	; 0x537e <DIO_VidSetPortDirection+0x6>
    537e:	00 d0       	rcall	.+0      	; 0x5380 <DIO_VidSetPortDirection+0x8>
    5380:	cd b7       	in	r28, 0x3d	; 61
    5382:	de b7       	in	r29, 0x3e	; 62
    5384:	89 83       	std	Y+1, r24	; 0x01
    5386:	6a 83       	std	Y+2, r22	; 0x02

		switch (copy_u8port)
    5388:	89 81       	ldd	r24, Y+1	; 0x01
    538a:	28 2f       	mov	r18, r24
    538c:	30 e0       	ldi	r19, 0x00	; 0
    538e:	3c 83       	std	Y+4, r19	; 0x04
    5390:	2b 83       	std	Y+3, r18	; 0x03
    5392:	8b 81       	ldd	r24, Y+3	; 0x03
    5394:	9c 81       	ldd	r25, Y+4	; 0x04
    5396:	83 30       	cpi	r24, 0x03	; 3
    5398:	91 05       	cpc	r25, r1
    539a:	d9 f0       	breq	.+54     	; 0x53d2 <DIO_VidSetPortDirection+0x5a>
    539c:	2b 81       	ldd	r18, Y+3	; 0x03
    539e:	3c 81       	ldd	r19, Y+4	; 0x04
    53a0:	24 30       	cpi	r18, 0x04	; 4
    53a2:	31 05       	cpc	r19, r1
    53a4:	34 f4       	brge	.+12     	; 0x53b2 <DIO_VidSetPortDirection+0x3a>
    53a6:	8b 81       	ldd	r24, Y+3	; 0x03
    53a8:	9c 81       	ldd	r25, Y+4	; 0x04
    53aa:	82 30       	cpi	r24, 0x02	; 2
    53ac:	91 05       	cpc	r25, r1
    53ae:	61 f0       	breq	.+24     	; 0x53c8 <DIO_VidSetPortDirection+0x50>
    53b0:	1e c0       	rjmp	.+60     	; 0x53ee <DIO_VidSetPortDirection+0x76>
    53b2:	2b 81       	ldd	r18, Y+3	; 0x03
    53b4:	3c 81       	ldd	r19, Y+4	; 0x04
    53b6:	24 30       	cpi	r18, 0x04	; 4
    53b8:	31 05       	cpc	r19, r1
    53ba:	81 f0       	breq	.+32     	; 0x53dc <DIO_VidSetPortDirection+0x64>
    53bc:	8b 81       	ldd	r24, Y+3	; 0x03
    53be:	9c 81       	ldd	r25, Y+4	; 0x04
    53c0:	85 30       	cpi	r24, 0x05	; 5
    53c2:	91 05       	cpc	r25, r1
    53c4:	81 f0       	breq	.+32     	; 0x53e6 <DIO_VidSetPortDirection+0x6e>
    53c6:	13 c0       	rjmp	.+38     	; 0x53ee <DIO_VidSetPortDirection+0x76>
		{
			case(Port_A) :DDRA = Copy_u8PortDeriction ; break;
    53c8:	ea e3       	ldi	r30, 0x3A	; 58
    53ca:	f0 e0       	ldi	r31, 0x00	; 0
    53cc:	8a 81       	ldd	r24, Y+2	; 0x02
    53ce:	80 83       	st	Z, r24
    53d0:	0e c0       	rjmp	.+28     	; 0x53ee <DIO_VidSetPortDirection+0x76>
			case(Port_B) :DDRB = Copy_u8PortDeriction ; break;
    53d2:	e7 e3       	ldi	r30, 0x37	; 55
    53d4:	f0 e0       	ldi	r31, 0x00	; 0
    53d6:	8a 81       	ldd	r24, Y+2	; 0x02
    53d8:	80 83       	st	Z, r24
    53da:	09 c0       	rjmp	.+18     	; 0x53ee <DIO_VidSetPortDirection+0x76>
			case(Port_C) :DDRC = Copy_u8PortDeriction ; break;
    53dc:	e4 e3       	ldi	r30, 0x34	; 52
    53de:	f0 e0       	ldi	r31, 0x00	; 0
    53e0:	8a 81       	ldd	r24, Y+2	; 0x02
    53e2:	80 83       	st	Z, r24
    53e4:	04 c0       	rjmp	.+8      	; 0x53ee <DIO_VidSetPortDirection+0x76>
			case(Port_D) :DDRD = Copy_u8PortDeriction ; break;
    53e6:	e1 e3       	ldi	r30, 0x31	; 49
    53e8:	f0 e0       	ldi	r31, 0x00	; 0
    53ea:	8a 81       	ldd	r24, Y+2	; 0x02
    53ec:	80 83       	st	Z, r24
		}
}
    53ee:	0f 90       	pop	r0
    53f0:	0f 90       	pop	r0
    53f2:	0f 90       	pop	r0
    53f4:	0f 90       	pop	r0
    53f6:	cf 91       	pop	r28
    53f8:	df 91       	pop	r29
    53fa:	08 95       	ret

000053fc <DIO_VidGetPortValue>:
void DIO_VidGetPortValue(u8 copy_u8port , u8 *Copy_Pu8PortValue ){
    53fc:	df 93       	push	r29
    53fe:	cf 93       	push	r28
    5400:	00 d0       	rcall	.+0      	; 0x5402 <DIO_VidGetPortValue+0x6>
    5402:	00 d0       	rcall	.+0      	; 0x5404 <DIO_VidGetPortValue+0x8>
    5404:	0f 92       	push	r0
    5406:	cd b7       	in	r28, 0x3d	; 61
    5408:	de b7       	in	r29, 0x3e	; 62
    540a:	89 83       	std	Y+1, r24	; 0x01
    540c:	7b 83       	std	Y+3, r23	; 0x03
    540e:	6a 83       	std	Y+2, r22	; 0x02
	switch (copy_u8port)
    5410:	89 81       	ldd	r24, Y+1	; 0x01
    5412:	28 2f       	mov	r18, r24
    5414:	30 e0       	ldi	r19, 0x00	; 0
    5416:	3d 83       	std	Y+5, r19	; 0x05
    5418:	2c 83       	std	Y+4, r18	; 0x04
    541a:	8c 81       	ldd	r24, Y+4	; 0x04
    541c:	9d 81       	ldd	r25, Y+5	; 0x05
    541e:	83 30       	cpi	r24, 0x03	; 3
    5420:	91 05       	cpc	r25, r1
    5422:	e9 f0       	breq	.+58     	; 0x545e <DIO_VidGetPortValue+0x62>
    5424:	2c 81       	ldd	r18, Y+4	; 0x04
    5426:	3d 81       	ldd	r19, Y+5	; 0x05
    5428:	24 30       	cpi	r18, 0x04	; 4
    542a:	31 05       	cpc	r19, r1
    542c:	34 f4       	brge	.+12     	; 0x543a <DIO_VidGetPortValue+0x3e>
    542e:	8c 81       	ldd	r24, Y+4	; 0x04
    5430:	9d 81       	ldd	r25, Y+5	; 0x05
    5432:	82 30       	cpi	r24, 0x02	; 2
    5434:	91 05       	cpc	r25, r1
    5436:	61 f0       	breq	.+24     	; 0x5450 <DIO_VidGetPortValue+0x54>
    5438:	26 c0       	rjmp	.+76     	; 0x5486 <DIO_VidGetPortValue+0x8a>
    543a:	2c 81       	ldd	r18, Y+4	; 0x04
    543c:	3d 81       	ldd	r19, Y+5	; 0x05
    543e:	24 30       	cpi	r18, 0x04	; 4
    5440:	31 05       	cpc	r19, r1
    5442:	a1 f0       	breq	.+40     	; 0x546c <DIO_VidGetPortValue+0x70>
    5444:	8c 81       	ldd	r24, Y+4	; 0x04
    5446:	9d 81       	ldd	r25, Y+5	; 0x05
    5448:	85 30       	cpi	r24, 0x05	; 5
    544a:	91 05       	cpc	r25, r1
    544c:	b1 f0       	breq	.+44     	; 0x547a <DIO_VidGetPortValue+0x7e>
    544e:	1b c0       	rjmp	.+54     	; 0x5486 <DIO_VidGetPortValue+0x8a>
				{
				case(Port_A) :*Copy_Pu8PortValue= PINA ; break;
    5450:	e9 e3       	ldi	r30, 0x39	; 57
    5452:	f0 e0       	ldi	r31, 0x00	; 0
    5454:	80 81       	ld	r24, Z
    5456:	ea 81       	ldd	r30, Y+2	; 0x02
    5458:	fb 81       	ldd	r31, Y+3	; 0x03
    545a:	80 83       	st	Z, r24
    545c:	14 c0       	rjmp	.+40     	; 0x5486 <DIO_VidGetPortValue+0x8a>
				case(Port_B) :*Copy_Pu8PortValue= PINB ; break;
    545e:	e6 e3       	ldi	r30, 0x36	; 54
    5460:	f0 e0       	ldi	r31, 0x00	; 0
    5462:	80 81       	ld	r24, Z
    5464:	ea 81       	ldd	r30, Y+2	; 0x02
    5466:	fb 81       	ldd	r31, Y+3	; 0x03
    5468:	80 83       	st	Z, r24
    546a:	0d c0       	rjmp	.+26     	; 0x5486 <DIO_VidGetPortValue+0x8a>
				case(Port_C) :*Copy_Pu8PortValue= PINC ; break;
    546c:	e3 e3       	ldi	r30, 0x33	; 51
    546e:	f0 e0       	ldi	r31, 0x00	; 0
    5470:	80 81       	ld	r24, Z
    5472:	ea 81       	ldd	r30, Y+2	; 0x02
    5474:	fb 81       	ldd	r31, Y+3	; 0x03
    5476:	80 83       	st	Z, r24
    5478:	06 c0       	rjmp	.+12     	; 0x5486 <DIO_VidGetPortValue+0x8a>
				case(Port_D) :*Copy_Pu8PortValue= PIND ; break;
    547a:	e0 e3       	ldi	r30, 0x30	; 48
    547c:	f0 e0       	ldi	r31, 0x00	; 0
    547e:	80 81       	ld	r24, Z
    5480:	ea 81       	ldd	r30, Y+2	; 0x02
    5482:	fb 81       	ldd	r31, Y+3	; 0x03
    5484:	80 83       	st	Z, r24
				}
}
    5486:	0f 90       	pop	r0
    5488:	0f 90       	pop	r0
    548a:	0f 90       	pop	r0
    548c:	0f 90       	pop	r0
    548e:	0f 90       	pop	r0
    5490:	cf 91       	pop	r28
    5492:	df 91       	pop	r29
    5494:	08 95       	ret

00005496 <main>:
void Task3 (void *p);
void Task4 (void *p);



void main (void){
    5496:	ef 92       	push	r14
    5498:	ff 92       	push	r15
    549a:	0f 93       	push	r16
    549c:	df 93       	push	r29
    549e:	cf 93       	push	r28
    54a0:	cd b7       	in	r28, 0x3d	; 61
    54a2:	de b7       	in	r29, 0x3e	; 62


DIO_VidSetPortDirection(Port_D , 0xFF );
    54a4:	85 e0       	ldi	r24, 0x05	; 5
    54a6:	6f ef       	ldi	r22, 0xFF	; 255
    54a8:	0e 94 bc 29 	call	0x5378	; 0x5378 <DIO_VidSetPortDirection>


xTaskCreate(   Task1        // Function Address
    54ac:	8d e8       	ldi	r24, 0x8D	; 141
    54ae:	9a e2       	ldi	r25, 0x2A	; 42
    54b0:	60 e0       	ldi	r22, 0x00	; 0
    54b2:	70 e0       	ldi	r23, 0x00	; 0
    54b4:	44 e6       	ldi	r20, 0x64	; 100
    54b6:	50 e0       	ldi	r21, 0x00	; 0
    54b8:	20 e0       	ldi	r18, 0x00	; 0
    54ba:	30 e0       	ldi	r19, 0x00	; 0
    54bc:	01 e0       	ldi	r16, 0x01	; 1
    54be:	ee 24       	eor	r14, r14
    54c0:	ff 24       	eor	r15, r15
    54c2:	0e 94 15 18 	call	0x302a	; 0x302a <xTaskCreate>
			 , 1     		//task priority
			 , NULL);		//Handle task used with other Functions like Delete task

										/*******/

xTaskCreate(   Task2        // Function Address
    54c6:	89 ea       	ldi	r24, 0xA9	; 169
    54c8:	9a e2       	ldi	r25, 0x2A	; 42
    54ca:	60 e0       	ldi	r22, 0x00	; 0
    54cc:	70 e0       	ldi	r23, 0x00	; 0
    54ce:	44 e6       	ldi	r20, 0x64	; 100
    54d0:	50 e0       	ldi	r21, 0x00	; 0
    54d2:	20 e0       	ldi	r18, 0x00	; 0
    54d4:	30 e0       	ldi	r19, 0x00	; 0
    54d6:	01 e0       	ldi	r16, 0x01	; 1
    54d8:	ee 24       	eor	r14, r14
    54da:	ff 24       	eor	r15, r15
    54dc:	0e 94 15 18 	call	0x302a	; 0x302a <xTaskCreate>
			 , NULL 		//Pointer to void , will be passed to tas
			 , 1     		//task priority
			 , NULL);		//Handle task used with other Functions like Delete task
										/*******/

xTaskCreate(    Task3       // Function Address
    54e0:	85 ec       	ldi	r24, 0xC5	; 197
    54e2:	9a e2       	ldi	r25, 0x2A	; 42
    54e4:	60 e0       	ldi	r22, 0x00	; 0
    54e6:	70 e0       	ldi	r23, 0x00	; 0
    54e8:	44 e6       	ldi	r20, 0x64	; 100
    54ea:	50 e0       	ldi	r21, 0x00	; 0
    54ec:	20 e0       	ldi	r18, 0x00	; 0
    54ee:	30 e0       	ldi	r19, 0x00	; 0
    54f0:	01 e0       	ldi	r16, 0x01	; 1
    54f2:	ee 24       	eor	r14, r14
    54f4:	ff 24       	eor	r15, r15
    54f6:	0e 94 15 18 	call	0x302a	; 0x302a <xTaskCreate>
				, 1    		//task priority
				, NULL);	//Handle task used with other Functions like Delete task

										/*******/

xTaskCreate(    Task4       // Function Address
    54fa:	81 ee       	ldi	r24, 0xE1	; 225
    54fc:	9a e2       	ldi	r25, 0x2A	; 42
    54fe:	60 e0       	ldi	r22, 0x00	; 0
    5500:	70 e0       	ldi	r23, 0x00	; 0
    5502:	44 e6       	ldi	r20, 0x64	; 100
    5504:	50 e0       	ldi	r21, 0x00	; 0
    5506:	20 e0       	ldi	r18, 0x00	; 0
    5508:	30 e0       	ldi	r19, 0x00	; 0
    550a:	01 e0       	ldi	r16, 0x01	; 1
    550c:	ee 24       	eor	r14, r14
    550e:	ff 24       	eor	r15, r15
    5510:	0e 94 15 18 	call	0x302a	; 0x302a <xTaskCreate>
				, NULL 		//Pointer to void , will be passed to tas
				, 1    		//task priority
				, NULL);	//Handle task used with other Functions like Delete task

										/*******/
vTaskStartScheduler();
    5514:	0e 94 c9 1b 	call	0x3792	; 0x3792 <vTaskStartScheduler>
    5518:	ff cf       	rjmp	.-2      	; 0x5518 <main+0x82>

0000551a <Task1>:
	}
}
										/*******/

void Task1 (void *p)
{
    551a:	df 93       	push	r29
    551c:	cf 93       	push	r28
    551e:	00 d0       	rcall	.+0      	; 0x5520 <Task1+0x6>
    5520:	00 d0       	rcall	.+0      	; 0x5522 <Task1+0x8>
    5522:	cd b7       	in	r28, 0x3d	; 61
    5524:	de b7       	in	r29, 0x3e	; 62
    5526:	9b 83       	std	Y+3, r25	; 0x03
    5528:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 1 ;
    552a:	81 e0       	ldi	r24, 0x01	; 1
    552c:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		DIO_VidSetPinValue(Port_D ,pin1  ,state);
    552e:	85 e0       	ldi	r24, 0x05	; 5
    5530:	61 e0       	ldi	r22, 0x01	; 1
    5532:	49 81       	ldd	r20, Y+1	; 0x01
    5534:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <DIO_VidSetPinValue>
		state = !state ;
    5538:	1c 82       	std	Y+4, r1	; 0x04
    553a:	89 81       	ldd	r24, Y+1	; 0x01
    553c:	88 23       	and	r24, r24
    553e:	11 f4       	brne	.+4      	; 0x5544 <Task1+0x2a>
    5540:	81 e0       	ldi	r24, 0x01	; 1
    5542:	8c 83       	std	Y+4, r24	; 0x04
    5544:	8c 81       	ldd	r24, Y+4	; 0x04
    5546:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelay(500);    /* Tics Number */
    5548:	84 ef       	ldi	r24, 0xF4	; 244
    554a:	91 e0       	ldi	r25, 0x01	; 1
    554c:	0e 94 3a 1a 	call	0x3474	; 0x3474 <vTaskDelay>
    5550:	ee cf       	rjmp	.-36     	; 0x552e <Task1+0x14>

00005552 <Task2>:
	}
}
										/*******/
void Task2 (void *p)
{
    5552:	df 93       	push	r29
    5554:	cf 93       	push	r28
    5556:	00 d0       	rcall	.+0      	; 0x5558 <Task2+0x6>
    5558:	00 d0       	rcall	.+0      	; 0x555a <Task2+0x8>
    555a:	cd b7       	in	r28, 0x3d	; 61
    555c:	de b7       	in	r29, 0x3e	; 62
    555e:	9b 83       	std	Y+3, r25	; 0x03
    5560:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 1 ;
    5562:	81 e0       	ldi	r24, 0x01	; 1
    5564:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		DIO_VidSetPinValue(Port_D ,pin2  ,state);
    5566:	85 e0       	ldi	r24, 0x05	; 5
    5568:	62 e0       	ldi	r22, 0x02	; 2
    556a:	49 81       	ldd	r20, Y+1	; 0x01
    556c:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <DIO_VidSetPinValue>
		state = !state ;
    5570:	1c 82       	std	Y+4, r1	; 0x04
    5572:	89 81       	ldd	r24, Y+1	; 0x01
    5574:	88 23       	and	r24, r24
    5576:	11 f4       	brne	.+4      	; 0x557c <Task2+0x2a>
    5578:	81 e0       	ldi	r24, 0x01	; 1
    557a:	8c 83       	std	Y+4, r24	; 0x04
    557c:	8c 81       	ldd	r24, Y+4	; 0x04
    557e:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelay(1000);
    5580:	88 ee       	ldi	r24, 0xE8	; 232
    5582:	93 e0       	ldi	r25, 0x03	; 3
    5584:	0e 94 3a 1a 	call	0x3474	; 0x3474 <vTaskDelay>
    5588:	ee cf       	rjmp	.-36     	; 0x5566 <Task2+0x14>

0000558a <Task3>:
	}
}
										/*******/
void Task3 (void *p)
{
    558a:	df 93       	push	r29
    558c:	cf 93       	push	r28
    558e:	00 d0       	rcall	.+0      	; 0x5590 <Task3+0x6>
    5590:	00 d0       	rcall	.+0      	; 0x5592 <Task3+0x8>
    5592:	cd b7       	in	r28, 0x3d	; 61
    5594:	de b7       	in	r29, 0x3e	; 62
    5596:	9b 83       	std	Y+3, r25	; 0x03
    5598:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 1 ;
    559a:	81 e0       	ldi	r24, 0x01	; 1
    559c:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		DIO_VidSetPinValue(Port_D ,pin3  ,state);
    559e:	85 e0       	ldi	r24, 0x05	; 5
    55a0:	63 e0       	ldi	r22, 0x03	; 3
    55a2:	49 81       	ldd	r20, Y+1	; 0x01
    55a4:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <DIO_VidSetPinValue>
		state = !state ;
    55a8:	1c 82       	std	Y+4, r1	; 0x04
    55aa:	89 81       	ldd	r24, Y+1	; 0x01
    55ac:	88 23       	and	r24, r24
    55ae:	11 f4       	brne	.+4      	; 0x55b4 <Task3+0x2a>
    55b0:	81 e0       	ldi	r24, 0x01	; 1
    55b2:	8c 83       	std	Y+4, r24	; 0x04
    55b4:	8c 81       	ldd	r24, Y+4	; 0x04
    55b6:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelay(1500);
    55b8:	8c ed       	ldi	r24, 0xDC	; 220
    55ba:	95 e0       	ldi	r25, 0x05	; 5
    55bc:	0e 94 3a 1a 	call	0x3474	; 0x3474 <vTaskDelay>
    55c0:	ee cf       	rjmp	.-36     	; 0x559e <Task3+0x14>

000055c2 <Task4>:
	}
}
										/*******/
void Task4 (void *p)
{
    55c2:	df 93       	push	r29
    55c4:	cf 93       	push	r28
    55c6:	00 d0       	rcall	.+0      	; 0x55c8 <Task4+0x6>
    55c8:	00 d0       	rcall	.+0      	; 0x55ca <Task4+0x8>
    55ca:	cd b7       	in	r28, 0x3d	; 61
    55cc:	de b7       	in	r29, 0x3e	; 62
    55ce:	9b 83       	std	Y+3, r25	; 0x03
    55d0:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 1 ;
    55d2:	81 e0       	ldi	r24, 0x01	; 1
    55d4:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		DIO_VidSetPinValue(Port_D ,pin4  ,state);
    55d6:	85 e0       	ldi	r24, 0x05	; 5
    55d8:	64 e0       	ldi	r22, 0x04	; 4
    55da:	49 81       	ldd	r20, Y+1	; 0x01
    55dc:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <DIO_VidSetPinValue>
		state = !state ;
    55e0:	1c 82       	std	Y+4, r1	; 0x04
    55e2:	89 81       	ldd	r24, Y+1	; 0x01
    55e4:	88 23       	and	r24, r24
    55e6:	11 f4       	brne	.+4      	; 0x55ec <Task4+0x2a>
    55e8:	81 e0       	ldi	r24, 0x01	; 1
    55ea:	8c 83       	std	Y+4, r24	; 0x04
    55ec:	8c 81       	ldd	r24, Y+4	; 0x04
    55ee:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelay(2000);
    55f0:	80 ed       	ldi	r24, 0xD0	; 208
    55f2:	97 e0       	ldi	r25, 0x07	; 7
    55f4:	0e 94 3a 1a 	call	0x3474	; 0x3474 <vTaskDelay>
    55f8:	ee cf       	rjmp	.-36     	; 0x55d6 <Task4+0x14>

000055fa <memcpy>:
    55fa:	fb 01       	movw	r30, r22
    55fc:	dc 01       	movw	r26, r24
    55fe:	02 c0       	rjmp	.+4      	; 0x5604 <memcpy+0xa>
    5600:	01 90       	ld	r0, Z+
    5602:	0d 92       	st	X+, r0
    5604:	41 50       	subi	r20, 0x01	; 1
    5606:	50 40       	sbci	r21, 0x00	; 0
    5608:	d8 f7       	brcc	.-10     	; 0x5600 <memcpy+0x6>
    560a:	08 95       	ret

0000560c <memset>:
    560c:	dc 01       	movw	r26, r24
    560e:	01 c0       	rjmp	.+2      	; 0x5612 <memset+0x6>
    5610:	6d 93       	st	X+, r22
    5612:	41 50       	subi	r20, 0x01	; 1
    5614:	50 40       	sbci	r21, 0x00	; 0
    5616:	e0 f7       	brcc	.-8      	; 0x5610 <memset+0x4>
    5618:	08 95       	ret

0000561a <_exit>:
    561a:	f8 94       	cli

0000561c <__stop_program>:
    561c:	ff cf       	rjmp	.-2      	; 0x561c <__stop_program>
